<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Definitional Abstract Interpreters for Higher-Order Programming Languages</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="acmart.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="autobib.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="main.html" class="tocviewselflink" data-pltdoc="x">Definitional Abstract Interpreters for Higher-<wbr></wbr>Order Programming Languages</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="main.html#%28part._.Introduction%29" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="main.html#%28part._s~3aaam%29" class="tocviewlink" data-pltdoc="x">From Machines to Compositional Evaluators</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="main.html#%28part._s~3ainterp%29" class="tocviewlink" data-pltdoc="x">A Definitional Interpreter</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="main.html#%28part._s~3acache%29" class="tocviewlink" data-pltdoc="x">Caching and Finding Fixed-<wbr></wbr>points</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="main.html#%28part._s~3areynolds%29" class="tocviewlink" data-pltdoc="x">Pushdown <span style="font-style: italic">&#224; la</span> Reynolds</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="main.html#%28part._s~3awidening%29" class="tocviewlink" data-pltdoc="x">Widening the Store</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="main.html#%28part._s~3aalt-abstraction%29" class="tocviewlink" data-pltdoc="x">An Alternative Abstraction</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="main.html#%28part._s~3asymbolic%29" class="tocviewlink" data-pltdoc="x">Symbolic execution</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="main.html#%28part._s~3agc%29" class="tocviewlink" data-pltdoc="x">Garbage Collection</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="main.html#%28part._s~3arelated-work%29" class="tocviewlink" data-pltdoc="x">Related work</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="main.html#%28part._s~3aconclusion%29" class="tocviewlink" data-pltdoc="x">Conclusions</a></td></tr><tr><td align="right"></td><td><a href="main.html#%28part._doc-bibliography%29" class="tocviewlink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Definitional_.Abstract_.Interpreters_for_.Higher-.Order_.Programming_.Languages%29" class="tocsubseclink" data-pltdoc="x">Definitional Abstract Interpreters for Higher-<wbr></wbr>Order Programming Languages</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Introduction%29" class="tocsubseclink" data-pltdoc="x">Introduction</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Style%29" class="tocsubseclink" data-pltdoc="x">Style</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._s~3aaam%29" class="tocsubseclink" data-pltdoc="x">From Machines to Compositional Evaluators</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._s~3ainterp%29" class="tocsubseclink" data-pltdoc="x">A Definitional Interpreter</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._s~3acollecting%29" class="tocsubseclink" data-pltdoc="x">Collecting Variations</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._s~3abase%29" class="tocsubseclink" data-pltdoc="x">Abstracting Base Values</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._s~3aabstracting-closures%29" class="tocsubseclink" data-pltdoc="x">Abstracting Closures</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._s~3acache%29" class="tocsubseclink" data-pltdoc="x">Caching and Finding Fixed-<wbr></wbr>points</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._s~3acache~3aformalism%29" class="tocsubseclink" data-pltdoc="x">Formal soundness and termination</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._s~3areynolds%29" class="tocsubseclink" data-pltdoc="x">Pushdown <span style="font-style: italic">&#224; la</span> Reynolds</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._s~3awidening%29" class="tocsubseclink" data-pltdoc="x">Widening the Store</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._s~3aalt-abstraction%29" class="tocsubseclink" data-pltdoc="x">An Alternative Abstraction</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#%28part._s~3asymbolic%29" class="tocsubseclink" data-pltdoc="x">Symbolic execution</a></td></tr><tr><td><span class="tocsublinknumber">9<tt>&nbsp;</tt></span><a href="#%28part._s~3agc%29" class="tocsubseclink" data-pltdoc="x">Garbage Collection</a></td></tr><tr><td><span class="tocsublinknumber">10<tt>&nbsp;</tt></span><a href="#%28part._s~3arelated-work%29" class="tocsubseclink" data-pltdoc="x">Related work</a></td></tr><tr><td><span class="tocsublinknumber">11<tt>&nbsp;</tt></span><a href="#%28part._s~3aconclusion%29" class="tocsubseclink" data-pltdoc="x">Conclusions</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._doc-bibliography%29" class="tocsubseclink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Definitional_.Abstract_.Interpreters_for_.Higher-.Order_.Programming_.Languages)"></a>Definitional Abstract Interpreters for Higher-Order Programming Languages</h2><p><span class="subtitle">Functional Pearl</span></p><blockquote class="abstract"><p>In this functional pearl, we examine the use of
definitional interpreters as a basis for abstract
interpretation of higher-order programming languages. As it
turns out, definitional interpreters, especially those
written in monadic style, can provide a nice basis for a
wide variety of collecting semantics, abstract
interpretations, symbolic executions, and their
intermixings.</p><p>But the real insight of this story is a replaying of an
insight from Reynold&rsquo;s landmark paper, <span style="font-style: italic">Definitional
Interpreters for Higher-Order Programming Languages</span>, in
which he observes definitional interpreters enable the
defined-language to inherit properties of the
defining-language. We show the same holds true for
definitional <span style="font-style: italic">abstract</span> interpreters. Remarkably, we
observe that abstract definitional interpreters can inherit
the so-called &ldquo;pushdown control flow&rdquo; property, wherein
function calls and returns are precisely matched in the
abstract semantics, simply by virtue of the function call
mechanism of the defining-language.</p><p>The first approaches to achieve this property for
higher-order languages appeared within the last ten years,
and have since been the subject of many papers. These
approaches start from a state-machine semantics and
uniformly involve significant technical engineering to
recover the precision of pushdown control flow. In contrast,
starting from a definitional interpreter, the pushdown
control flow property is inherent in the meta-language and
requires no further technical mechanism to achieve.</p></blockquote><h3>1<tt>&nbsp;</tt><a name="(part._.Introduction)"></a>Introduction</h3><p>An abstract interpreter is intended to soundly and effectively compute
an over-approximation to its concrete counterpart.  For higher-order
languages, these concrete interpreters tend to be formulated as
state-machines (e.g<span class="Sendabbrev">.</span> <a href="main.html#%28autobib._.Jagannathan%2C._.Suresh._and._.Weeks%2C._.Stephen.A._unified._treatment._of._flow._analysis._in._higher-order._languages.In._.Proc..._.P.O.P.L._%2795~3a._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995%29" data-pltdoc="x">Suresh and Stephen</a>&nbsp;(<a href="main.html#%28autobib._.Jagannathan%2C._.Suresh._and._.Weeks%2C._.Stephen.A._unified._treatment._of._flow._analysis._in._higher-order._languages.In._.Proc..._.P.O.P.L._%2795~3a._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995%29" data-pltdoc="x">1995</a>);
<a href="main.html#%28autobib._.Jagannathan%2C._.Suresh%2C._.Thiemann%2C._.Peter%2C._.Weeks%2C._.Stephen%2C._and._.Wright%2C._.Andrew.Single._and._loving._it~3a._must-alias._analysis._for._higher-order._languages.In._.Proc..._.P.O.P.L._%2798~3a._.Proceedings._of._the._25th._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1998%29" data-pltdoc="x">Suresh et al.</a>&nbsp;(<a href="main.html#%28autobib._.Jagannathan%2C._.Suresh%2C._.Thiemann%2C._.Peter%2C._.Weeks%2C._.Stephen%2C._and._.Wright%2C._.Andrew.Single._and._loving._it~3a._must-alias._analysis._for._higher-order._languages.In._.Proc..._.P.O.P.L._%2798~3a._.Proceedings._of._the._25th._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1998%29" data-pltdoc="x">1998</a>);
<a href="main.html#%28autobib._.Wright%2C._.Andrew._.K..._and._.Jagannathan%2C._.Suresh.Polymorphic._splitting~3a._an._effective._polyvariant._flow._analysis.A.C.M._.Trans..._.Program..._.Lang..._.Syst..1998%29" data-pltdoc="x">K. and Suresh</a>&nbsp;(<a href="main.html#%28autobib._.Wright%2C._.Andrew._.K..._and._.Jagannathan%2C._.Suresh.Polymorphic._splitting~3a._an._effective._polyvariant._flow._analysis.A.C.M._.Trans..._.Program..._.Lang..._.Syst..1998%29" data-pltdoc="x">1998</a>);
<a href="main.html#%28autobib._.Might%2C._.Matthew._and._.Shivers%2C._.Olin.Environment._analysis._via._~5c%28~5c.Delta~5c%29-.C.F.A.In._.Proc..._.P.O.P.L._%2706~3a._.Conference._record._of._the._33rd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2006%29" data-pltdoc="x">Matthew and Olin</a>&nbsp;(<a href="main.html#%28autobib._.Might%2C._.Matthew._and._.Shivers%2C._.Olin.Environment._analysis._via._~5c%28~5c.Delta~5c%29-.C.F.A.In._.Proc..._.P.O.P.L._%2706~3a._.Conference._record._of._the._33rd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2006%29" data-pltdoc="x">2006a</a>);
<a href="main.html#%28autobib._.Midtgaard%2C._.Jan._and._.Jensen%2C._.Thomas.A._.Calculational._.Approach._to._.Control-.Flow.Analysis._by._.Abstract._.Interpretation.In._.Proc..._.Static._.Analysis._.Symposium2008%29" data-pltdoc="x">Jan and Thomas</a>&nbsp;(<a href="main.html#%28autobib._.Midtgaard%2C._.Jan._and._.Jensen%2C._.Thomas.A._.Calculational._.Approach._to._.Control-.Flow.Analysis._by._.Abstract._.Interpretation.In._.Proc..._.Static._.Analysis._.Symposium2008%29" data-pltdoc="x">2008</a>);
<a href="main.html#%28autobib._.Midtgaard%2C._.Jan._and._.Jensen%2C._.Thomas._.P...Control-flow._.Analysis._of._.Function._.Calls._and._.Returns._by._.Abstract._.Interpretation.In._.Proc..._.I.C.F.P._%2709~3a._.Proceedings._of._the._14th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2009%29" data-pltdoc="x">Jan and P.</a>&nbsp;(<a href="main.html#%28autobib._.Midtgaard%2C._.Jan._and._.Jensen%2C._.Thomas._.P...Control-flow._.Analysis._of._.Function._.Calls._and._.Returns._by._.Abstract._.Interpretation.In._.Proc..._.I.C.F.P._%2709~3a._.Proceedings._of._the._14th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2009%29" data-pltdoc="x">2009</a>);
<a href="main.html#%28autobib._.Might%2C._.Matthew._and._.Van._.Horn%2C._.David.A._.Family._of._.Abstract._.Interpretations._for._.Static._.Analysis._of._.Concurrent._.Higher-.Order.Programs.In._.Proc..._.Static._.Analysis2011%29" data-pltdoc="x">Matthew and David</a>&nbsp;(<a href="main.html#%28autobib._.Might%2C._.Matthew._and._.Van._.Horn%2C._.David.A._.Family._of._.Abstract._.Interpretations._for._.Static._.Analysis._of._.Concurrent._.Higher-.Order.Programs.In._.Proc..._.Static._.Analysis2011%29" data-pltdoc="x">2011</a>); and
<a href="main.html#%28autobib._.Sergey%2C._.Ilya%2C._.Devriese%2C._.Dominique%2C._.Might%2C._.Matthew%2C._.Midtgaard%2C._.Jan%2C._.Darais%2C._.David%2C._.Clarke%2C._.Dave%2C._and._.Piessens%2C._.Frank.Monadic._.Abstract._.Interpreters.In._.Proc..._.Proceedings._of._the._34th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2013%29" data-pltdoc="x">Ilya et al.</a>&nbsp;(<a href="main.html#%28autobib._.Sergey%2C._.Ilya%2C._.Devriese%2C._.Dominique%2C._.Might%2C._.Matthew%2C._.Midtgaard%2C._.Jan%2C._.Darais%2C._.David%2C._.Clarke%2C._.Dave%2C._and._.Piessens%2C._.Frank.Monadic._.Abstract._.Interpreters.In._.Proc..._.Proceedings._of._the._34th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2013%29" data-pltdoc="x">2013</a>)).  There are several reasons for
this choice: they operate with simple transfer functions defined over
similarly simple data structures, they make explicit all aspects of
the state of a computation, and computing fixed-points in the set of
reachable states is straightforward.  The essence of the state-machine
based approach was distilled by Van Horn and Might in their
&ldquo;abstracting abstract machines&rdquo; (AAM) technique, which provides a
systematic method for constructing abstract interpreters from standard
abstract machines like the CEK- or Krivine-machines
&nbsp;(<a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Abstracting._.Abstract._.Machines.In._.Proc..._.Proceedings._of._the._15th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">David and Matthew</a> <a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Abstracting._.Abstract._.Machines.In._.Proc..._.Proceedings._of._the._15th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">2010</a>).  Language designers who would
like to build abstract interpreters and program analysis tools for
their language can now, in principle at least, first build a
state-machine interpreter and then turn the crank to construct the
approximating abstract counterpart.</p><p><div class="SIntrapara">A natural pair of questions that arise from this past work is to
wonder:
</div><div class="SIntrapara"><ol><li><p>can a systematic abstraction technique similar to AAM  be
carried out for interpreters written, <span style="font-style: italic">not</span> as state-machines,
but instead as high-level definitional interpreters, i.e. recursive,
compositional evaluators?</p></li><li><p>is such a perspective fruitful?</p></li></ol></div><div class="SIntrapara">In this functional pearl, we seek to answer both questions in the
affirmative.</div></p><p>For the first question, we show the AAM recipe can be applied
to definitional interpreters in a straightforward adaptation of the
original method. The primary technical challenge in this new setting
is handling interpreter fixed-points in a way that is both sound and
always terminates&#8212;<wbr></wbr>a naive abstraction of fixed-points will be sound but
isn&rsquo;t always terminating, and a naive use of caching for fixed-points
will guarantee termination but is inherently unsound. We address this
technical challenge with a straightforward caching fixed-point-finding
algorithm which is both sound and guaranteed to terminate when abstracting
arbitrary definitional interpreters.</p><p>For the second question, we claim that the abstract definitional
interpreter perspective is fruitful in two regards.  The first is
unsurprising: high-level abstract interpreters offer the usual
beneficial properties of their concrete counterparts in terms of being
re-usable and extensible.  In particular, we show that abstract
interpreters can be structured with monad transformers to good effect.
The second regard is more surprising, and we consider its observation
to be the main contribution of this pearl.</p><p>Definitional interpreters, in contrast to abstract machines, can leave
aspects of computation implicit, relying on the semantics of the
defin<span style="font-style: italic">ing</span>-language to define the semantics of the
defin<span style="font-style: italic">ed</span>-language, an observation made by Reynolds in his landmark
paper, <span style="font-style: italic">Definitional Interpreters for Higher-order Programming
Languages</span> &nbsp;(<a href="main.html#%28autobib._.Reynolds%2C._.John._.C...Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._%2772~3a._.Proceedings._of._the._.A.C.M._.Annual._.Conference1972%29" data-pltdoc="x">C.</a> <a href="main.html#%28autobib._.Reynolds%2C._.John._.C...Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._%2772~3a._.Proceedings._of._the._.A.C.M._.Annual._.Conference1972%29" data-pltdoc="x">1972</a>).  For example, Reynolds showed it is
possible to write a definitional interpreter such that it defines a
call-by-value language when the metalanguage is call-by-value, and
defines a call-by-name language when the metalanguage is call-by-name.
Inspired by Reynolds, we show that <span style="font-style: italic">abstract</span> definitional interpreters can likewise
inherit properties of the metalanguage.  In particular we construct an
abstract definitional interpreter where there is no explicit
representation of continuations or a call stack.  Instead the
interpreter is written in a straightforward recursive style, and the
call stack is implicitly handled by the metalangauge.  What emerges
from this construction is a total abstract evaluation function that
soundly approximates all possible concrete executions of a given
program.  But remarkably, since the abstract evaluator relies on the
metalanguage to manage the call stack implicitly, it is easy to
observe that it introduces no approximation in the matching of calls
and returns, and therefore implements a &ldquo;pushdown&rdquo;
analysis &nbsp;(<a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._control-flow._analysis._of._higher-order._programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">Christopher et al.</a> <a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._control-flow._analysis._of._higher-order._programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">2010</a>; <a href="main.html#%28autobib._.Vardoulakis%2C._.Dimitrios._and._.Shivers%2C._.Olin.C.F.A2~3a._a._.Context-.Free.Approach._to._.Control-.Flow.Analysis.Logical._.Methods._in._.Computer._.Science2011%29" data-pltdoc="x">Dimitrios and Olin</a> <a href="main.html#%28autobib._.Vardoulakis%2C._.Dimitrios._and._.Shivers%2C._.Olin.C.F.A2~3a._a._.Context-.Free.Approach._to._.Control-.Flow.Analysis.Logical._.Methods._in._.Computer._.Science2011%29" data-pltdoc="x">2011</a>), all without the need for any explicit
machinery to do so.</p><h4><a name="(part._.Outline)"></a>Outline</h4><p>In the remainder of this pearl, we present an adaptation of the AAM
method to the setting of recursively-defined, compositional evaluation
functions, a.k.a.~definitional interpreters.  We first briefly review
the basic ingredients in the AAM recipe (<a href="main.html#%28part._s~3aaam%29" data-pltdoc="x">From Machines to Compositional Evaluators</a>) and then
define our definitional interpreter (<a href="main.html#%28part._s~3ainterp%29" data-pltdoc="x">A Definitional Interpreter</a>).  The
interpreter is largely standard, but is written in a monadic and
extensible style, so as to be re-usable for various forms of semantics
we examine.  The AAM technique applies in a basically straightforward
way by store-allocating bindings and soundly finitizing the heap.  But
when naively run, the interpreter will not always terminate.  To solve
this problem we introduce a caching strategy and a simple fixed-point
computation to ensure the interpreter terminates (<a href="main.html#%28part._s~3acache%29" data-pltdoc="x">Caching and Finding Fixed-points</a>).
It is at this point that we observe the interpreter we have built
enjoys the &ldquo;pushdown&rdquo; property <span style="font-style: italic">&#224; la</span> Reynolds&#8212;<wbr></wbr>it is
inherited from the defining language of our interpreter and requires
no explicit mechanism (<a href="main.html#%28part._s~3areynolds%29" data-pltdoc="x">Pushdown <span style="font-style: italic">&#224; la</span> Reynolds</a>).</p><p>Having established the main results, we then explore some variations
in brief vignettes that showcase the flexibility of our definitional
abstract interpreter approach.  First we consider the widely used
technique of so-called &ldquo;store-widening,&rdquo; which trades precision for
efficiency by modelling the abstract store globally instead of locally
(<a href="main.html#%28part._s~3awidening%29" data-pltdoc="x">Widening the Store</a>).  Thanks to our monadic formulation of the
interpreter, this is achieved by a simple re-ordering of the monad
transformer stack.  We also explore some alternative abstractions,
showing that due to the extensible construction, it&rsquo;s easy to
experiment with alternative components for the abstract interpreter.
In particular, we define an alternative interpretation of the primitive
operations that remains completely precise until forced by joins in
the store to introduce approximation (<a href="main.html#%28part._s~3aalt-abstraction%29" data-pltdoc="x">An Alternative Abstraction</a>).  As
another variation, we explore computing a form of symbolic execution
as yet another instance of our interpreter (<a href="main.html#%28part._s~3asymbolic%29" data-pltdoc="x">Symbolic execution</a>).  Lastly, we
show how to incorporate so-called &ldquo;abstract garbage collection,&rdquo; a
well-known technique for improving the precision of abstract
interpretation by clearing out unreachable store locations, thus
avoiding future joins which cause imprecision (<a href="main.html#%28part._s~3agc%29" data-pltdoc="x">Garbage Collection</a>).  This
last variation is significant because it demonstrates that even though
we have no explicit representation of the stack, it is possible to
compute analyses that typically require such explicit representations
in order to calculate root sets for garbage collection.</p><p>Finally, we place our work in the context of the prior literature on
higher-order abstract interpretation (<a href="main.html#%28part._s~3arelated-work%29" data-pltdoc="x">Related work</a>) and draw
some conclusions (<a href="main.html#%28part._s~3aconclusion%29" data-pltdoc="x">Conclusions</a>).</p><h4><a name="(part._.Style)"></a>Style</h4><p>To convey the ideas of this paper as concretely as possible, we
present code implementing our definitional abstract interpreter and
all its variations.  As a metalanguage, we use an applicative subset
of Racket &nbsp;(<a href="main.html#%28autobib._.Flatt%2C._.Matthew._and._.P.L.T.Reference~3a._.Racket.P.L.T._.Inc..2010%29" data-pltdoc="x">Matthew and PLT</a> <a href="main.html#%28autobib._.Flatt%2C._.Matthew._and._.P.L.T.Reference~3a._.Racket.P.L.T._.Inc..2010%29" data-pltdoc="x">2010</a>), a dialect of Scheme.  This choice
is largely immaterial: any functional language would do.  However, to
aide extensibility, we use Racket&rsquo;s <span style="font-style: italic">unit</span>
system &nbsp;(<a href="main.html#%28autobib._.Flatt%2C._.Matthew._and._.Felleisen%2C._.Matthias.Units~3a._.Cool._.Modules._for._.H.O.T._.Languages.In._.Proc..._.Proceedings._of._the._.A.C.M._.S.I.G.P.L.A.N._1998._.Conference._on._.Programming._.Language._.Design._and._.Implementation1998%29" data-pltdoc="x">Matthew and Matthias</a> <a href="main.html#%28autobib._.Flatt%2C._.Matthew._and._.Felleisen%2C._.Matthias.Units~3a._.Cool._.Modules._for._.H.O.T._.Languages.In._.Proc..._.Proceedings._of._the._.A.C.M._.S.I.G.P.L.A.N._1998._.Conference._on._.Programming._.Language._.Design._and._.Implementation1998%29" data-pltdoc="x">1998</a>) to write program components that can
be linked together.</p><p>All of the code presented in this pearl runs; this document is a
literate Racket program.  We have also implemented a small DSL for
composing and experimenting with these interpreters easily.  Assuming
Racket is installed, you can install the <span class="stt">monadic-eval</span> package with
<span style="font-weight: bold">(URL redacted for double-blind)</span> and a brief tutorial is
available on github.</p><h3>2<tt>&nbsp;</tt><a name="(part._s~3aaam)"></a>From Machines to Compositional Evaluators</h3><p><div class="SIntrapara">In recent years, there has been considerable effort in the systematic
construction of abstract interpreters for higher-order languages using abstract
machines&#8212;<wbr></wbr>first-order transition systems&#8212;<wbr></wbr>as a semantic basis.  The so-called
<span style="font-style: italic">Abstracting Abstract Machines</span> (AAM) approach to abstract
interpretation &nbsp;(<a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Abstracting._.Abstract._.Machines.In._.Proc..._.Proceedings._of._the._15th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">David and Matthew</a> <a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Abstracting._.Abstract._.Machines.In._.Proc..._.Proceedings._of._the._15th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">2010</a>) is a recipe for
transforming a machine semantics into an easily abstractable form. The
transformation includes the following ingredients:
</div><div class="SIntrapara"><ul><li><p>Allocating continuations in the store;</p></li><li><p>Allocating variable bindings in the store;</p></li><li><p>Using a store that maps addresses to <span style="font-style: italic">sets</span> of values;</p></li><li><p>Interpreting store updates as a join; and</p></li><li><p>Interpreting store dereference as a non-deterministic choice.</p></li></ul></div><div class="SIntrapara">These transformations are semantics-preserving due to the original and derived
machines operating in a lock-step correspondence.  After transforming the
semantics in this way, a <span style="font-style: italic">computable</span> abstract interpreter is achieved by:
</div><div class="SIntrapara"><ul><li><p>Bounding store allocation to a finite set of addresses; and</p></li><li><p>Widening base values to some abstract domain.</p></li></ul></div><div class="SIntrapara">After performing these transformations, the soundness and computability of the
resulting abstract interpreter are then self-evident and easily proved.</div></p><p>The AAM approach has been applied to a wide variety of languages and
applications, and given the success of the approach it&rsquo;s natural to wonder what
is essential about its use of low-level machines. It is not at all clear
whether a similar approach is possible with a higher-level formulation of the
semantics, such as a compositional evaluation function defined recursively over
the syntax of expressions.</p><p>This paper shows that the essence of the AAM approach can be applied to a
high-level semantic basis.  We show that compositional evaluators written in
monadic style can express similar abstractions to that of AAM, and like AAM,
the design remains systematic.  Moreover, we show that the high-level semantics
offers a number of benefits not available to the machine model.</p><p>There is a rich body of work concerning tools and techniques for
<span style="font-style: italic">extensible</span> interpreters &nbsp;(<a href="main.html#%28autobib._.Jaskelioff%2C._.Mauro._.Javier.Lifting._of._operations._in._modular._monadic._semantics.University._of._.Nottingham2009%29" data-pltdoc="x">Javier</a> <a href="main.html#%28autobib._.Jaskelioff%2C._.Mauro._.Javier.Lifting._of._operations._in._modular._monadic._semantics.University._of._.Nottingham2009%29" data-pltdoc="x">2009</a>; <a href="main.html#%28autobib._.Kiselyov%2C._.Oleg.Typed._tagless._final._interpreters.In._.Proc..._.Generic._and._.Indexed._.Programming2012%29" data-pltdoc="x">Oleg</a> <a href="main.html#%28autobib._.Kiselyov%2C._.Oleg.Typed._tagless._final._interpreters.In._.Proc..._.Generic._and._.Indexed._.Programming2012%29" data-pltdoc="x">2012</a>; <a href="main.html#%28autobib._.Liang%2C._.Sheng%2C._.Hudak%2C._.Paul%2C._and._.Jones%2C._.Mark.Monad._.Transformers._and._.Modular._.Interpreters.In._.Proc..._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995%29" data-pltdoc="x">Sheng et al.</a> <a href="main.html#%28autobib._.Liang%2C._.Sheng%2C._.Hudak%2C._.Paul%2C._and._.Jones%2C._.Mark.Monad._.Transformers._and._.Modular._.Interpreters.In._.Proc..._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995%29" data-pltdoc="x">1995</a>), all of which
applies to high-level semantics.  By putting abstract interpretation
for higher-order languages on a high-level semantic basis, we can
bring these results to bear on the construction of extensible abstract
interpreters.</p><h3>3<tt>&nbsp;</tt><a name="(part._s~3ainterp)"></a>A Definitional Interpreter</h3><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><table cellspacing="0" cellpadding="0"><tr><td align="left"><p><span style="font-style: italic">e &#8712; exp</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="center"><p><span class="stt">::=</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">(vbl </span><span style="font-style: italic">x</span><span class="stt">)</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">variable</span>]</p></td></tr><tr><td align="left"><p></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="center"><p><span class="stt">|</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">(num </span><span style="font-style: italic">n</span><span class="stt">)</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">conditional</span>]</p></td></tr><tr><td align="left"><p></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="center"><p><span class="stt">|</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">(if0 </span><span style="font-style: italic">e</span><span class="stt"> </span><span style="font-style: italic">e</span><span class="stt"> </span><span style="font-style: italic">e</span><span class="stt">)</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">binary op</span>]</p></td></tr><tr><td align="left"><p></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="center"><p><span class="stt">|</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">(app </span><span style="font-style: italic">e</span><span class="stt"> </span><span style="font-style: italic">e</span><span class="stt">)</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">application</span>]</p></td></tr><tr><td align="left"><p></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="center"><p><span class="stt">|</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">(rec </span><span style="font-style: italic">x</span><span class="stt"> </span><span style="font-style: italic">&#8467;</span><span class="stt"> </span><span style="font-style: italic">e</span><span class="stt">)</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">letrec</span>]</p></td></tr><tr><td align="left"><p></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="center"><p><span class="stt">|</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span style="font-style: italic">&#8467;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">lambda</span>]</p></td></tr><tr><td align="left"><p><span style="font-style: italic">&#8467; &#8712; lam</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="center"><p><span class="stt">::=</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">(lam </span><span style="font-style: italic">x</span><span class="stt"> </span><span style="font-style: italic">e</span><span class="stt">)</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">function defn</span>]</p></td></tr><tr><td align="left"><p><span style="font-style: italic">x &#8712; var</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="center"><p><span class="stt">::=</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">x</span>, <span class="stt">y</span>, ...</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">variable name</span>]</p></td></tr><tr><td align="left"><p><span style="font-style: italic">b &#8712; bin</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="center"><p><span class="stt">::=</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">+</span>, <span class="stt">-</span>, ...</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">binary prim</span>]</p></td></tr></table></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3asyntax))" x-target-lift="Figure"></a>Figure&nbsp;1: </span>Programming Language Syntax</span></p></blockquote><p>We begin by constructing a definitional interpreter for a small but
representative higher-order, functional language.  The abstract syntax
of the language is defined in <a href="main.html#%28counter._%28figure._f~3asyntax%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">1</span></a>; it includes
variables, numbers, binary operations on numbers, conditionals,
<span class="RktSym">letrec</span> expressions, functions and applications.</p><p>The interpreter for the language is defined in
<a href="main.html#%28counter._%28figure._f~3ainterpreter%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">2</span></a>. At first glance, it has many conventional
aspects: it is compositionally defined by structural recursion on the
syntax of expressions; it represents function values as a closure data
structure which pairs the lambda term with the evaluation environment;
it is structured monadically and uses monad operations to interact
with the environment and store; and it relies on a helper function
<span class="RktSym">&#948;</span> to interpret primitive operations.</p><p><div class="SIntrapara">There are a few superficial aspects that deserve a quick note:
environments <span class="RktSym">&#961;</span> are finite maps and the syntax <span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span>
denotes <span style="font-style: italic">&#961;</span>(<span style="font-style: italic">x</span>)<span style="font-style: italic"></span> while <span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">)</span> denotes <span style="font-style: italic">&#961;</span>[<span style="font-style: italic">x&#8614;a</span>]<span style="font-style: italic"></span>.  For
simplicity, recursive function definitions (<span class="RktSym">rec</span>) are assumed
to be syntactic values.  The <span class="RktSym">do</span>-notation is just shorthand for
<span class="RktSym">bind</span>, as usual:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8801;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8801;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">_</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8801;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8801;</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span></td></tr></table></blockquote></div><div class="SIntrapara">Finally, there are two unconventional aspects worth noting.</div></p><p>First, the interpreter is written in an <span style="font-style: italic">open recursive style</span>;
the evaluator does not call itself recursively, instead it takes as an
argument a function <span class="RktSym">ev</span>&#8212;shadowing the name of the function
<span class="RktSym">ev</span> being defined&#8212;and <span class="RktSym">ev</span> (the argument) is called
instead of self-recursion.  This is a standard encoding for recursive
functions in a setting without recursive binding.  It is up to an
external function, such as the Y-combinator, to close the recursive
loop.  This open recursive form is crucial because it allows
intercepting recursive calls to perform &#8220;deep&#8221; instrumentation of the
interpreter.</p><p>Second, the code is clearly <span style="font-style: italic">incomplete</span>.  There are a number of free
variables, typeset as italics, which implement the following:</p><ul><li><p>The underlying monad of the interpreter: <span class="RktVar">return</span> and <span class="RktVar">bind</span>;</p></li><li><p>An interpretation of primitives: <span class="RktVar">&#948;</span> and <span class="RktVar">zero?</span>;</p></li><li><p>Environment operations: <span class="RktVar">ask-env</span> for retrieving the
environment and <span class="RktVar">local-env</span> for installing an environment;</p></li><li><p>Store operations: <span class="RktVar">ext</span> for updating the store, and <span class="RktVar">find</span> for
dereferencing locations; and</p></li><li><p>An operation for <span class="RktVar">alloc</span>ating new store locations.</p></li></ul><p>Going forward, we make frequent use of definitions involving free
variables, and we call such a collection of such definitions a
<span style="font-style: italic">component</span>. We assume components can be named (in this case,
we&rsquo;ve named the component <span class="RktSym">ev@</span>, indicated by the box in the
upper-right corner) and linked together to eliminate free
variables.<span class="NoteBox"><span class="NoteContent">We use Racket <span style="font-style: italic">units</span> &nbsp;(<a href="main.html#%28autobib._.Flatt%2C._.Matthew._and._.Felleisen%2C._.Matthias.Units~3a._.Cool._.Modules._for._.H.O.T._.Languages.In._.Proc..._.Proceedings._of._the._.A.C.M._.S.I.G.P.L.A.N._1998._.Conference._on._.Programming._.Language._.Design._and._.Implementation1998%29" data-pltdoc="x">Matthew and Matthias</a> <a href="main.html#%28autobib._.Flatt%2C._.Matthew._and._.Felleisen%2C._.Matthias.Units~3a._.Cool._.Modules._for._.H.O.T._.Languages.In._.Proc..._.Proceedings._of._the._.A.C.M._.S.I.G.P.L.A.N._1998._.Conference._on._.Programming._.Language._.Design._and._.Implementation1998%29" data-pltdoc="x">1998</a>)
to model components in our implementation.</span></span></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">vbl</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">find</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">op2</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">v&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">&#948;</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-env</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">alloc</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#961;&#8242;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;&#8242;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">local-env</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;&#8242;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">lam</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lam</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">app</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lam</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">alloc</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">local-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3ainterpreter))" x-target-lift="Figure"></a>Figure&nbsp;2: </span>The Extensible Definitional Interpreter</span></p></blockquote><p>Next we examine a set of components which complete the definitional
interpreter, shown in <a href="main.html#%28counter._%28figure._f~3aconcrete-components%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">3</span></a>. The first
component <span class="RktSym">monad@</span> uses a macro <span class="RktSym">define-monad</span> which
generates a set of bindings based on a monad transformer stack.  We
use a failure monad to model divide-by-zero errors, a state monad to
model the store, and a reader monad to model the environment.  The
<span class="RktSym">define-monad</span> form generates bindings for <span class="RktSym">return</span>,
<span class="RktSym">bind</span>, <span class="RktSym">ask-env</span>, <span class="RktSym">local-env</span>,
<span class="RktSym">get-store</span> and <span class="RktSym">update-store</span>; their definitions are
standard &nbsp;(<a href="main.html#%28autobib._.Liang%2C._.Sheng%2C._.Hudak%2C._.Paul%2C._and._.Jones%2C._.Mark.Monad._.Transformers._and._.Modular._.Interpreters.In._.Proc..._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995%29" data-pltdoc="x">Sheng et al.</a> <a href="main.html#%28autobib._.Liang%2C._.Sheng%2C._.Hudak%2C._.Paul%2C._and._.Jones%2C._.Mark.Monad._.Transformers._and._.Modular._.Interpreters.In._.Proc..._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995%29" data-pltdoc="x">1995</a>).</p><p><div class="SIntrapara">We also define <span class="RktSym">run</span> for running monadic computations, starting with the empty
environment and store <span class="RktSym">&#8709;</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-StateT</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-ReaderT</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">While the <span class="RktSym">define-monad</span> form is hiding some details, this
component could have equivalently been written out explicitly. For
example, <span class="RktSym">return</span> and <span class="RktSym">bind</span> can be defined as:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktSym">ma</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ma</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">s&#8242;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s&#8242;</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">failure</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">failure</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">So far our use of monad transformers is as a mere convenience, however
the monad abstraction will become essential for easily deriving new
analyses later on.</div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">monad@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define-monad</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">&#948;@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">/</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">fail</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">store@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">find</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">update-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">alloc@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">alloc</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3aconcrete-components))" x-target-lift="Figure"></a>Figure&nbsp;3: </span>Components for Definitional Interpreters</span></p></blockquote><p>The <span class="RktSym">&#948;@</span> component defines the interpretation of primitives,
which is given in terms of the underlying monad.  The <span class="RktSym">alloc@</span>
component provides a definition of <span class="RktSym">alloc</span>, which fetches the
store and uses its size to return a fresh address, assuming the
invariant <span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="stt"> </span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym">&#963;</span><span class="RktPn">)</span> <span style="font-style: italic">&#8660;</span> <span class="RktPn">(</span><span class="RktSym">&lt;</span><span class="stt"> </span><span class="RktSym">a</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">size</span><span class="stt"> </span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span>.  The
<span class="RktSym">alloc</span> function takes a single argument, which is the name of
the variable whose binding is being allocated.  For the time being, it
is ignored, but will become relevant when abstracting closures
(<a href="main.html#%28part._s~3aabstracting-closures%29" data-pltdoc="x">Abstracting Closures</a>).  The <span class="RktSym">store@</span> component
defines <span class="RktSym">find</span> and <span class="RktSym">ext</span> for finding and extending
values in the store.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">trace-monad@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define-monad</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">WriterT</span><span class="hspace">&nbsp;</span><span class="RktSym">List</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-tell@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-tell</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-env</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tell</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3atrace))" x-target-lift="Figure"></a>Figure&nbsp;4: </span>Trace Collecting Semantics</span></p></blockquote><p><div class="SIntrapara">The only remaining pieces of the puzzle are a fixed-point combinator and the
main entry-point for the interpreter, which are straightforward to define:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>By taking advantage of Racket&rsquo;s languages-as-libraries features
&nbsp;(<a href="main.html#%28autobib._.Tobin-.Hochstadt%2C._.Sam%2C._.St-.Amour%2C._.Vincent%2C._.Culpepper%2C._.Ryan%2C._.Flatt%2C._.Matthew%2C._and._.Felleisen%2C._.Matthias.Languages._.As._.Libraries.In._.Proc..._.Proceedings._of._the._32nd._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2011%29" data-pltdoc="x">Sam et al.</a> <a href="main.html#%28autobib._.Tobin-.Hochstadt%2C._.Sam%2C._.St-.Amour%2C._.Vincent%2C._.Culpepper%2C._.Ryan%2C._.Flatt%2C._.Matthew%2C._and._.Felleisen%2C._.Matthias.Languages._.As._.Libraries.In._.Proc..._.Proceedings._of._the._32nd._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2011%29" data-pltdoc="x">2011</a>), we construct REPLs for
interacting with this interpreter.  Here are a few evaluation examples
in a succinct concrete syntax:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Closure over the empty environment paired with the empty store.</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(((&#955; (x) x) . ()) . ())</span></p></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Closure over a non-empty environment and store.</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(((&#955; (y) x) . ((x . 0))) . ((0 . 4)))</span></p></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Primitive operations work as expected.</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(63 . ())</span></p></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Divide-by-zero errors result in failures.</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(failure . ())</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Because our monad stack places <span class="RktSym">FailT</span> above <span class="RktSym">StateT</span>,
the answer includes the (empty) store at the point of the error. Had
we changed <span class="RktSym">monad@</span> to use <span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="stt"> </span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span> then failures would not include the store:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'failure</span></p></td></tr></table></blockquote></div><div class="SIntrapara">At this point we&rsquo;ve defined a simple definitional interpreter, although the
extensible components involved&#8212;monadic operations and open recursion&#8212;will allow
us to instantiate the same interpreter to achieve a wide range of useful
abstract interpretations.</div></p><h4>3.1<tt>&nbsp;</tt><a name="(part._s~3acollecting)"></a>Collecting Variations</h4><p><div class="SIntrapara">The formal development of abstract interpretation often starts from a
so-called &ldquo;non-standard collecting semantics.&rdquo;  A common form of
collecting semantics is a trace semantics, which collects streams of
states the interpreter reaches.  <a href="main.html#%28counter._%28figure._f~3atrace%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">4</span></a> shows the monad
stack for a tracing interpreter and a &ldquo;mix-in&rdquo; for the evaluator.
The monad stack adds <span class="RktSym">WriterT</span><span class="stt"> </span><span class="RktSym">List</span>, which provides a new
operation <span class="RktSym">tell</span> for writing lists of items to the stream of
reached states.  The <span class="RktSym">ev-tell</span> function is a wrapper around an
underlying <span class="RktSym">ev&#8320;</span> unfixed evaluator, and interposes itself
between each recursive call by <span class="RktSym">tell</span>ing the current state of
the evaluator: the current expression, environment and store.  The
top-level evaluation function is then:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-tell</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">dead-monad@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-dead@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-dead</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#952;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-dead</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">put-dead</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-remove</span><span class="hspace">&nbsp;</span><span class="RktSym">&#952;</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">eval-dead@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">eval-dead</span><span class="hspace">&nbsp;</span><span class="RktSym">eval</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">put-dead</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subexps</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3adead))" x-target-lift="Figure"></a>Figure&nbsp;5: </span>Dead Code Collecting Semantics</span></p></blockquote><p><div class="SIntrapara">Now when an expression is evaluated, we get an answer and a list of all states
seen by the evaluator, in the order in which they were seen. For example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktRes">'((63 . ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((* (+ 3 4) 9) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((+ 3 4) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(3 () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(4 () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(9 () ()))</span></p></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">Were we to swap <span class="RktSym">List</span> with <span class="RktSym">Set</span> in the monad stack, we would obtain a
<span style="font-style: italic">reachable</span> state semantics, another common form of collecting semantics,
that loses the order and repetition of states.</div></p><p>As another collecting semantics variant, we show how to collect the
<span style="font-style: italic">dead code</span> in a program.  Here we use a monad stack that has an
additional state component (with operations named <span class="RktSym">put-dead</span> and
<span class="RktSym">get-dead</span>) which stores the set of dead expressions.  Initially this
will contain all subexpressions of the program.  As the interpreter
evaluates expressions it will remove them from the dead set.</p><p><div class="SIntrapara"><a href="main.html#%28counter._%28figure._f~3adead%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">5</span></a> defines the monad stack for the dead code
collecting semantics and the <span class="RktSym">ev-dead@</span> component, another
mix-in for an <span class="RktSym">ev&#8320;</span> evaluator to remove the given subexpression
before recurring.  Since computing the dead code requires an outer
wrapper that sets the initial set of dead code to be all of the
subexpressions in the program, we define <span class="RktSym">eval-dead@</span> which
consumes a <span style="font-style: italic">closed evaluator</span>, i.e. something of the form
<span class="RktPn">(</span><span class="RktSym">fix</span><span class="stt"> </span><span class="RktSym">ev</span><span class="RktPn">)</span>. Putting these pieces together, the dead code
collecting semantics is defined:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">eval-dead</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-dead</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div></p><p><div class="SIntrapara">Running a program with the dead code interpreter produces an answer and the set
of expressions that were not evaluated during the running of a program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(cons '(1 . ()) (set 2))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(cons '(((&#955; (x) x) . ()) . ()) (set 'x))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(cons '(failure . ()) (set 3 2))</span></p></td></tr></table></blockquote></div></p><p>Our setup makes it easy not only to express the concrete interpreter,
but also these useful forms of collecting semantics.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._s~3abase)"></a>Abstracting Base Values</h4><p>Our interpreter must become decidable before it can be considered an analysis,
and the first step towards decidability is to abstract the base types of the
language to something finite. We do this for our number base type by
introducing a new <span style="font-style: italic">abstract</span> number, written <span class="RktVal">'</span><span class="RktVal">N</span>, which represents the
set of all numbers. Abstract numbers are introduced by an alternative
interpretation of primitive operations, given in <a href="main.html#%28counter._%28figure._f~3aabs-delta%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">6</span></a>,
which simply produces <span class="RktVal">'</span><span class="RktVal">N</span> in all cases.</p><p>Some care must be taken in the abstraction of <span class="RktVal">'</span><span class="RktVal">quotient</span>. If
the denominator is the abstract number <span class="RktVal">'</span><span class="RktVal">N</span>, then it is
possible the program could fail as a result of divide-by-zero, since
<span class="RktVal">0</span> is contained in the interpretation of
<span class="RktVal">'</span><span class="RktVal">N</span>. Therefore there are <span style="font-style: italic">two</span> possible answers when the
denominator is <span class="RktVal">'</span><span class="RktVal">N</span>: <span class="RktVal">'</span><span class="RktVal">N</span> and <span class="RktVal">'</span><span class="RktVal">failure</span>. Both
answers are <span class="RktSym">return</span>ed by introducing non-determinism
<span class="RktSym">NondetT</span> into the monad stack. Adding non-determinism provides
the <span class="RktSym">mplus</span> operation for combining multiple
answers. Non-determinism is also used in <span class="RktSym">zero?</span>, which returns
both true and false on <span class="RktVal">'</span><span class="RktVal">N</span>.</p><p><div class="SIntrapara">By linking together <span class="RktSym">&#948;^@</span> and the monad stack with
non-determinism, we obtain an evaluator that produces a set of
results:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((N . ()))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((failure . ()) (N . ()))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((4 . ()) (3 . ()))</span></p></td></tr></table></blockquote></div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">monad^@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define-monad</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">&#948;^@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">+</span><span class="hspace">&nbsp;</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktSym">_</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">/</span><span class="hspace">&nbsp;</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">num?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">fail</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">/</span><span class="hspace">&nbsp;</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mplus</span><span class="hspace">&nbsp;</span><span class="RktSym">fail</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">_</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3aabs-delta))" x-target-lift="Figure"></a>Figure&nbsp;6: </span>Abstracting Primitive Operations</span></p></blockquote><p>It is clear that the interpreter will only ever see a finite set of
numbers (including <span class="RktVal">'</span><span class="RktVal">N</span>), but it&rsquo;s definitely not true that the
interpreter halts on all inputs.  First, it&rsquo;s still possible to
generate an infinite number of closures.  Second, there&rsquo;s no way for
the interpreter to detect when it sees a loop.  To make a terminating
abstract interpreter requires tackling both.  We look next at
abstracting closures.</p><h4>3.3<tt>&nbsp;</tt><a name="(part._s~3aabstracting-closures)"></a>Abstracting Closures</h4><p>Closures consist of code&#8212;<wbr></wbr>a lambda term&#8212;<wbr></wbr>and an environment&#8212;<wbr></wbr>a finite map
from variables to addresses.  Since the set of lambda terms and variables is
bounded by the program text, it suffices to finitize closures by finitizing the
set of addresses.  Following the AAM approach, we do this by modifying the
allocation function to produce elements drawn from a finite set.  In order to
retain soundness in the semantics, we modify the store to map addresses to
<span style="font-style: italic">sets</span> of values, model store update as a join, and model dereference as a
non-deterministic choice.</p><p>Any abstraction of the allocation function that produces a finite set will do,
but the choice of abstraction will determine the precision of the resulting
analysis.  A simple choice is to allocate variables using the variable&rsquo;s name
as its address.  This gives a monomorphic, or 0CFA-like, abstraction.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">alloc^@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">alloc</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">store-nd@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">find</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/monad+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">update-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3a0cfa-abs))" x-target-lift="Figure"></a>Figure&nbsp;7: </span>Abstracting Allocation: 0CFA</span></p></blockquote><p><a href="main.html#%28counter._%28figure._f~3a0cfa-abs%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">7</span></a> shows the component <span class="RktSym">alloc^@</span> which
implements monomorphic allocation, and the component
<span class="RktSym">store-nd@</span> for implementing <span class="RktSym">find</span> and <span class="RktSym">ext</span>
which interact with a store mapping to <span style="font-style: italic">sets</span> of values. The
<span class="RktSym">for/monad+</span> form is a convenience for combining a set of
computations with <span class="RktSym">mplus</span>, and is used so <span class="RktSym">find</span> returns
<span style="font-style: italic">all</span> of the values in the store at a given address.  The
<span class="RktSym">ext</span> function joins whenever an address is already allocated,
otherwise it maps the address to a singleton set.  By linking these
components with the same monad stack from before, we obtain an
interpreter that loses precision whenever variables are bound to
multiple values.</p><p>Our abstract interpreter now has a truly finite domain; the next step is to
detect loops in the state-space to achieve termination.</p><h3>4<tt>&nbsp;</tt><a name="(part._s~3acache)"></a>Caching and Finding Fixed-points</h3><p>At this point, the interpreter obtained by linking together
<span class="RktSym">monad^@</span>, <span class="RktSym">&#948;^@</span>, <span class="RktSym">alloc^@</span> and
<span class="RktSym">store-nd@</span> components will only ever visit a finite number of
configurations for a given program. A configuration (<span class="RktSym">&#962;</span>)
consists of an expression (<span class="RktSym">e</span>), environment (<span class="RktSym">&#961;</span>) and
store (<span class="RktSym">&#963;</span>). This configuration is finite because: expressions
are finite in the given program; environments are maps from variables
(again, finite in the program) to addresses; the addresses are finite
thanks to <span class="RktSym">alloc^</span>; the store maps addresses to sets of values;
base values are abstracted to a finite set by <span class="RktSym">&#948;^</span>; and
closures consist of an expression and environment, which are both
finite.</p><p><div class="SIntrapara">Although the interpreter will only ever see a finite set of inputs, it
<span style="font-style: italic">doesn&rsquo;t know it</span>.  A simple loop will cause the interpreter to
diverge:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">with-limit: out of time</span></p></td></tr></table></blockquote></div><div class="SIntrapara">To solve this problem, we introduce a <span style="font-style: italic">cache</span> (<span class="RktSym">$in</span>) as
input to the algorithm, which maps from configurations (<span class="RktSym">&#962;</span>) to
sets of value-and-store pairs (<span class="RktSym">v&#215;&#963;</span>). When a configuration is
reached for the second time, rather than re-evaluating the expression
and entering an infinite loop, the result is looked up from
<span class="RktSym">$in</span>, which acts as an oracle. It is important that the cache
is used co-inductively: it is only safe to use <span class="RktSym">in</span> as an
oracle so long as some progress has been made first.</div></p><p>The results of evaluation are then stored in an output cache
(<span class="RktSym">$out</span>), which after the end of evaluation is &#8220;more defined&#8221;
than the input cache (<span class="RktSym">$in</span>), again following a co-inductive
argument. The least fixed-point <span class="RktSym">$&#8314;</span> of an evaluator which
transforms an oracle <span class="RktSym">$in</span> and outputs a more defined oracle
$racket[out] is then a sound approximation of the program, because it
over-approximates all finite unrollings of the unfixed evaluator.</p><p>The co-inductive caching algorithm is shown in <a href="main.html#%28counter._%28figure._f~3acaching%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">8</span></a>,
along with the monad transformer stack <span class="RktSym">monad-cache@</span> which has
two new components: <span class="RktSym">ReaderT</span> for the input cache <span class="RktSym">$in</span>,
and <span class="RktSym">StateT+</span> for the output cache <span class="RktSym">$out</span>. We use a
<span class="RktSym">StateT+</span> instead of <span class="RktSym">WriterT</span> monad transformer in the
output cache so it can double as tracking the set of seen states. The
<span class="RktSym">+</span> in <span class="RktSym">StateT+</span> signifies that caches for multiple
non-deterministic branches will be merged automatically, producing a
set of results and a single cache, rather than a set of results paired
with individual caches.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">monad-cache@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define-monad</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT+</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-cache@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-env</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">$&#11810;out&#11811;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-cache-out</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">$&#11810;out&#11811;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/monad+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v&#215;&#963;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">$&#11810;out&#11811;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">put-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">$&#11810;in&#11811;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-cache-in</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v&#215;&#963;&#8320;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">$&#11810;in&#11811;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">$&#11810;in&#11811;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">put-cache-out</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">$&#11810;out&#11811;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#963;&#8242;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v&#215;&#963;&#8242;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;&#8242;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">update-cache-out</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">$&#11810;out&#11811;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">$&#11810;out&#11811;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">$&#11810;out&#11811;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;&#8242;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3acaching))" x-target-lift="Figure"></a>Figure&nbsp;8: </span>Co-inductive Caching Algorithm</span></p></blockquote><p>In the algorithm, when a configuration <span class="RktSym">&#962;</span> is first
encountered, we place an entry in the output cache mapping <span class="RktSym">&#962;</span>
to <span class="RktPn">(</span><span class="RktSym">$in</span><span class="stt"> </span><span class="RktSym">&#962;</span><span class="RktPn">)</span>, which is the &#8220;oracle&#8221; result. Also, whenever we
finish computing the result <span class="RktSym">v&#215;&#963;&#8242;</span> of evaluating a
configuration <span class="RktSym">&#962;</span>, we place an entry in the output cache
mapping <span class="RktSym">&#962;</span> to <span class="RktSym">v&#215;&#963;&#8242;</span>. Finally, whenever we reach a
configuration <span class="RktSym">&#962;</span> for which a mapping in the output cache
exists, we use it immediately, <span class="RktSym">return</span>ing each result using
the <span class="RktSym">for/monad+</span> iterator. Therefore, every &#8220;cache hit&#8221; on
<span class="RktSym">$out</span> is in one of two possible states: 1) we have already
seen the configuration, and the result is the oracle result, as
desired; or 2) we have already computed the &#8220;improved&#8221; result
(w.r.t. the oracle), and need not recompute it.</p><p>To compute the least fixed-point <span class="RktSym">$&#8314;</span> for the evaluator
<span class="RktSym">ev-cache</span> we perform a standard Kleene fixed-point iteration
starting from the empty map, the bottom element for the cache, as
shown in <a href="main.html#%28counter._%28figure._f~3afixing%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">9</span></a>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">fix-cache@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">eval</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-env</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">$&#8314;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mlfp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">$</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">put-cache-out</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">put-store</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local-cache-in</span><span class="hspace">&nbsp;</span><span class="RktSym">$</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">get-cache-out</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/monad+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v&#215;&#963;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">$&#8314;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">put-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mlfp</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">loop</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">x&#8242;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">x&#8242;</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">loop</span><span class="hspace">&nbsp;</span><span class="RktSym">x&#8242;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3afixing))" x-target-lift="Figure"></a>Figure&nbsp;9: </span>Finding Fixed-Points in the Cache</span></p></blockquote><p>The algorithm runs the caching evaluator <span class="RktSym">eval</span> on the given
program <span class="RktSym">e</span> from the initial environment and store. This is
done inside of <span class="RktSym">mlfp</span>, a monadic least fixed-point
finder. After finding the least fixed-point, the final values and
store for the initial configuration <span class="RktSym">&#962;</span> are extracted and
returned.</p><p>Termination of the least fixed-point is justified by the monotonicity of the
evaluator (it always returns an &#8220;improved&#8221; oracle), and the finite domain of
the cache, which maps abstract configurations to pairs of values and stores,
all of which are finite.</p><p><div class="SIntrapara">With these pieces in place we construct a complete interpreter:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix-cache</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">When linked with <span class="RktSym">&#948;^</span> and <span class="RktSym">alloc^</span>, this abstract
interpreter is sound and computable, as demonstrated on the following
examples:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'()</span></p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(N)</span></p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(3 2 0)</span></p></td></tr></table></blockquote></div></p><h4><a name="(part._s~3acache~3aformalism)"></a>Formal soundness and termination</h4><p>In this pearl, we have focused on the code and its intuitions rather
than rigorously establishing the usual formal properties of our
abstract interpreter, but this is just a matter of presentation: the
interpreter is indeed proven sound and computable.  We have formalized</p><p>this co-inductive caching algorithm in Appendix A,
where we prove both that it always terminates, and that it computes a
sound over-approximation of concrete evaluation. Here, we give a short
summary of our metatheory approach.</p><p>In formalising the soundness of this caching algorithm, we extend a
standard big-step evaluation semantics into a <span style="font-style: italic">big-step
reachability</span> semantics, which characterizes all intermediate
configurations which are seen between the evaluation of a single
expression and its eventual result. These two
notions&#8212;<span style="font-style: italic">evaluation</span> which relates expressions to fully evaluated
results, and <span style="font-style: italic">reachability</span> which characterizes intermediate
configuration states&#8212;remain distinct throughout the formalism.</p><p>After specifying evaluation and reachability for concrete evaluation,
we develop a <span style="font-style: italic">collecting</span> semantics which gives a precise
specification for any abstract interpreter, and an <span style="font-style: italic">abstract</span>
semantics which partially specifies a sound, over-approximating
algorithm w.r.t. the collecting semantics.</p><p>The final step is to compute an oracle for the <span style="font-style: italic">abstract
evaluation relation</span>, which maps individual configurations to
abstractions of the values they evaluate to. To construct this cache,
we <span style="font-style: italic">mutually</span> compute the least-fixed point of both the
evaluation and reachability relations: based on what is evaluated,
discover new things which are reachable, and based on what is
reachable, discover new results of evaluation. The caching algorithm
developed in this section is a slightly more efficient strategy for
solving the mutual fixed-point, by taking a deep exploration of the
reachability relation (up-to seeing the same configuration twice)
rather than applying just a single rule of inference.</p><h3>5<tt>&nbsp;</tt><a name="(part._s~3areynolds)"></a>Pushdown <span style="font-style: italic">&#224; la</span> Reynolds</h3><p>By combining the finite abstraction of base values and closures with the
termination-guaranteeing cache-based fixed-point algorithm, we have obtained a
terminating abstract interpreter.  But what kind of abstract interpretation did
we get?
We have followed the basic recipe of AAM, but adapted to a compositional
evaluator instead of an abstract machine.  However, we did manage to skip over
one of the key steps in the AAM method: we never store-allocated continuations.
<span style="font-style: italic">In fact, there are no continuations at all!</span></p><p>A traditional abstract machine formulation of the semantics would model the
object-level stack explicitly as an inductively defined data structure. Because
stacks may be arbitrarily large, they must be finitized like base values and
closures, and like closures, the AAM trick is to thread them through the store,
which itself must become finite. But in the definitional interpreter approach,
the story of this paper, the model of the stack is implicit and simply
inherited from the meta-language.</p><p>But here is the remarkable thing: since the stack is inherited from
the meta-language, the abstract interpreter inherits the &ldquo;call-return
matching&rdquo; of the meta-language, which is to say there is no loss of
precision of in the analysis of the control stack.  This is a property
that usually comes at considerable effort and engineering in the
formulations of higher-order flow analysis that model the stack
explicitly.  So-called higher-order &ldquo;pushdown&rdquo; analysis has been the
subject of multiple publications and two dissertations
&nbsp;(<a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Sergey%2C._.Ilya%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Introspective._pushdown._analysis._of._higher-order._programs.In._.Proc..._.Proceedings._of._the._17th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">Christopher et al.</a> <a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Sergey%2C._.Ilya%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Introspective._pushdown._analysis._of._higher-order._programs.In._.Proc..._.Proceedings._of._the._17th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">2012</a>; <a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._control-flow._analysis._of._higher-order._programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">Christopher et al.</a> <a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._control-flow._analysis._of._higher-order._programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">2010</a>; <a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Systematic._abstraction._of._abstract._machines.Journal._of._.Functional._.Programming2012%29" data-pltdoc="x">David and Matthew</a> <a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Systematic._abstraction._of._abstract._machines.Journal._of._.Functional._.Programming2012%29" data-pltdoc="x">2012</a>; <a href="main.html#%28autobib._.Vardoulakis%2C._.Dimitrios._and._.Shivers%2C._.Olin.C.F.A2~3a._a._.Context-.Free.Approach._to._.Control-.Flow.Analysis.Logical._.Methods._in._.Computer._.Science2011%29" data-pltdoc="x">Dimitrios and Olin</a> <a href="main.html#%28autobib._.Vardoulakis%2C._.Dimitrios._and._.Shivers%2C._.Olin.C.F.A2~3a._a._.Context-.Free.Approach._to._.Control-.Flow.Analysis.Logical._.Methods._in._.Computer._.Science2011%29" data-pltdoc="x">2011</a>; <a href="main.html#%28autobib._.Christopher._.Earl.Introspective._.Pushdown._.Analysis._and._.Nebo.University._of._.Utah2014%29" data-pltdoc="x">Earl</a> <a href="main.html#%28autobib._.Christopher._.Earl.Introspective._.Pushdown._.Analysis._and._.Nebo.University._of._.Utah2014%29" data-pltdoc="x">2014</a>; <a href="main.html#%28autobib._.Johnson%2C._.J..._.Ian%2C._.Sergey%2C._.Ilya%2C._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming2014%29" data-pltdoc="x">Ian et al.</a> <a href="main.html#%28autobib._.Johnson%2C._.J..._.Ian%2C._.Sergey%2C._.Ilya%2C._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming2014%29" data-pltdoc="x">2014</a>; <a href="main.html#%28autobib._.Johnson%2C._.J..~7e.Ian._and._.Van._.Horn%2C._.David.Abstracting._.Abstract._.Control.In._.Proc..._.Proceedings._of._the._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014%29" data-pltdoc="x">J.~Ian and David</a> <a href="main.html#%28autobib._.Johnson%2C._.J..~7e.Ian._and._.Van._.Horn%2C._.David.Abstracting._.Abstract._.Control.In._.Proc..._.Proceedings._of._the._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014%29" data-pltdoc="x">2014</a>; <a href="main.html#%28autobib._.Gilray%2C._.Thomas%2C._.Lyde%2C._.Steven%2C._.Adams%2C._.Michael._.D..%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._.Control-flow._.Analysis._for._.Free.In._.Proc..._.Proceedings._of._the._43rd._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2016%29" data-pltdoc="x">Thomas et al.</a> <a href="main.html#%28autobib._.Gilray%2C._.Thomas%2C._.Lyde%2C._.Steven%2C._.Adams%2C._.Michael._.D..%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._.Control-flow._.Analysis._for._.Free.In._.Proc..._.Proceedings._of._the._43rd._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2016%29" data-pltdoc="x">2016</a>; <a href="main.html#%28autobib._.Dimitrios._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Northeastern._.University2012%29" data-pltdoc="x">Vardoulakis</a> <a href="main.html#%28autobib._.Dimitrios._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Northeastern._.University2012%29" data-pltdoc="x">2012</a>). Yet when
formulated in the definitional interpreter style, the pushdown
property requires no mechanics and is simply inherited from the
meta-language.</p><p>Reynolds, in his celebrated paper <span style="font-style: italic">Definitional Interpreters for
Higher-order Programming Languages</span> &nbsp;(<a href="main.html#%28autobib._.Reynolds%2C._.John._.C...Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._%2772~3a._.Proceedings._of._the._.A.C.M._.Annual._.Conference1972%29" data-pltdoc="x">C.</a> <a href="main.html#%28autobib._.Reynolds%2C._.John._.C...Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._%2772~3a._.Proceedings._of._the._.A.C.M._.Annual._.Conference1972%29" data-pltdoc="x">1972</a>),
first observed that when the semantics of a programming language is
presented as a definitional interpreter, the defined language could
inherit semantic properties of the defining metalanguage.  We have now
shown this observation can be extended to <span style="font-style: italic">abstract</span>
interpretation as well, namely in the important case of the pushdown
property.</p><p>In the remainder of this paper, we explore a few natural extensions and
variations on the basic pushdown abstract interpreter we have established up to
this point.</p><h3>6<tt>&nbsp;</tt><a name="(part._s~3awidening)"></a>Widening the Store</h3><p>In this section, we show how to recover the well-known technique of
store-widening in our formulation of a definitional abstract
interpreter.  This example demonstrates the ease of which we can
construct existing abstraction choices.</p><p><div class="SIntrapara">The abstract interpreter we&rsquo;ve constructed so far uses a
store-per-program-state abstraction, which is precise but
prohibitively expensive. A common technique to combat this cost is to
use a global &ldquo;widened&rdquo; store&nbsp;(<a href="main.html#%28autobib._.Might%2C._.Matthew.Environment._analysis._of._higher-order._languages.Georgia._.Institute._of._.Technology2007%29" data-pltdoc="x">Matthew</a> <a href="main.html#%28autobib._.Might%2C._.Matthew.Environment._analysis._of._higher-order._languages.Georgia._.Institute._of._.Technology2007%29" data-pltdoc="x">2007a</a>; <a href="main.html#%28autobib._.Shivers%2C._.Olin.Control-flow._analysis._of._higher-order._languages.Carnegie._.Mellon._.University1991%29" data-pltdoc="x">Olin</a> <a href="main.html#%28autobib._.Shivers%2C._.Olin.Control-flow._analysis._of._higher-order._languages.Carnegie._.Mellon._.University1991%29" data-pltdoc="x">1991</a>), which over-approximates each individual
store in the current set-up. This change is achieved easily in the
monadic setup by re-ordering the monad stack, a technique due to
<a href="main.html#%28autobib._.Darais%2C._.David%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Galois._.Transformers._and._.Modular._.Abstract._.Interpreters~3a._.Reusable._.Metatheory._for._.Program._.Analysis.In._.Proc..._.Proceedings._of._the._2015._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages%2C._and._.Applications2015%29" data-pltdoc="x">David et al.</a>&nbsp;(<a href="main.html#%28autobib._.Darais%2C._.David%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Galois._.Transformers._and._.Modular._.Abstract._.Interpreters~3a._.Reusable._.Metatheory._for._.Program._.Analysis.In._.Proc..._.Proceedings._of._the._2015._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages%2C._and._.Applications2015%29" data-pltdoc="x">2015</a>). Whereas before we had
<span class="RktSym">monad-cache@</span> we instead swap the order of <span class="RktSym">StateT</span> for
the store and <span class="RktSym">NondetT</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT+</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">we get a store-widened variant of the abstract interpreter. Because
<span class="RktSym">StateT</span> for the store appears underneath nondeterminism, it
will be automatically widened. We write <span class="RktSym">StateT+</span> to signify
that the cell of state supports such widening.</div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">precise-&#948;@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">num?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">num?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">+</span><span class="hspace">&nbsp;</span><span class="RktSym">_</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">_</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">_</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">store-crush@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">find</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/monad+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">crush</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">vs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closure?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-add</span><span class="hspace">&nbsp;</span><span class="RktSym">vs</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-filter</span><span class="hspace">&nbsp;</span><span class="RktSym">closure?</span><span class="hspace">&nbsp;</span><span class="RktSym">vs</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">update-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">crush</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3apres-delta))" x-target-lift="Figure"></a>Figure&nbsp;10: </span>An Alternative Abstraction for Precise Primitives</span></p></blockquote><h3>7<tt>&nbsp;</tt><a name="(part._s~3aalt-abstraction)"></a>An Alternative Abstraction</h3><p>In this section, we demonstrate how easy it is to experiment with
alternative abstraction strategies by swapping out components.  In
particular we look at an alternative abstraction of primitive
operations and store joins that results in an abstraction that&#8212;<wbr></wbr>to
the best of our knowledge&#8212;<wbr></wbr>has not been explored in the literature.
This example shows the potential for rapidly prototyping novel
abstractions using our approach.</p><p><a href="main.html#%28counter._%28figure._f~3apres-delta%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">10</span></a> defines two new components:
<span class="RktSym">precise-&#948;@</span> and <span class="RktSym">store-crush@</span>.  The first is an
alternative interpretation for primitive operations that is
<span style="font-style: italic">precision preserving</span>.  Unlike <span class="RktSym">&#948;^@</span>, it does not
introduce abstraction, it merely propagates it.  When two concrete
numbers are added together, the result will be a concrete number, but
if either number is abstract then the result is abstract.</p><p>This interpretation of primitive operations clearly doesn&rsquo;t impose a
finite abstraction on its own, because the state space for concrete
numbers is infinite. If <span class="RktSym">precise-&#948;@</span> is linked with the
<span class="RktSym">store-nd@</span> implementation of the store, termination is
therefore not guaranteed.</p><p><div class="SIntrapara">The <span class="RktSym">store-crush@</span> operations are designed to work with
<span class="RktSym">precise-&#948;@</span> by performing <span style="font-style: italic">widening</span> when joining
multiple concrete values into the store. This abstraction offers a
high-level of precision; for example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Constant arithmetic expressions are computed with full precision.</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(63)</span></p></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Even linear binding and arithmetic preserves precision.</span></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(25)</span></p></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Only when the approximation of binding structure comes in to</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">contact with base values that we see a loss in precision.</span></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(N)</span></p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">This combination of <span class="RktSym">precise-&#948;@</span> and <span class="RktSym">store-crush@</span>
allows termination for most programs, but still not all. In the
following example, <span class="RktSym">id</span> is eventually applied to a widened
argument <span class="RktVal">'</span><span class="RktVal">N</span>, which makes both conditional branches
reachable. The function returns <span class="RktVal">0</span> in the base case, which is
propagated to the recursive call and added to <span class="RktVal">1</span>, which yields
the concrete answer <span class="RktVal">1</span>.  This results in a cycle where the
intermediate sum returns <span class="RktVal">2</span>, <span class="RktVal">3</span>, <span class="RktVal">4</span> when
applied to <span class="RktVal">1</span>, <span class="RktVal">2</span>, <span class="RktVal">3</span>, etc.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">id</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">id</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">id</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktErr">with-limit: out of time</span></p></td></tr></table></blockquote></div><div class="SIntrapara">To ensure termination for all programs, we assume all references to
primitive operations are <span style="font-style: italic">&#951;</span>-expanded, so that store-allocations
also take place at primitive applications, ensuring widening at
repeated bindings. In fact, all programs terminate when using
<span class="RktSym">precise-&#948;@</span>, <span class="RktSym">store-crush@</span> and <span style="font-style: italic">&#951;</span>-expanded
primitives, which means we have a achieved a computable and uniquely
precise abstract interpreter.</div></p><p>Here we see one of the strengths of the extensible, definitional
approach to abstract interpreters. The combination of added precision
and widening is encoded quite naturally. In contrast, it&rsquo;s hard to
imagine how such a combination could be formulated as, say, a
constraint-based flow analysis.</p><h3>8<tt>&nbsp;</tt><a name="(part._s~3asymbolic)"></a>Symbolic execution</h3><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">symbolic-monad@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define-monad</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-symbolic@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-symbolic</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">sym</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">e</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">&#948;-symbolic@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">/</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">fail</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">/</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">/</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">n&#8321;</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#966;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-path-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">num?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">#:when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">&#966;</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">#:when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">&#172;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#966;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">refine</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">refine</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">&#172;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3asymbolic))" x-target-lift="Figure"></a>Figure&nbsp;11: </span>Symbolic Execution Variant</span></p></blockquote><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">&#948;^-symbolic@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">/</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">fail</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">member</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#966;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-path-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3asymbolic-widen))" x-target-lift="Figure"></a>Figure&nbsp;12: </span>Symbolic Execution with Abstract Numbers</span></p></blockquote><p>In this section, we carry out another&#8212;<wbr></wbr>this time more
involved&#8212;<wbr></wbr>example that shows how to instantiate our definitional
abstract interpreter to obtain a symbolic execution engine that
performs sound program verification.  This serves to demonstrate the
range of the approach, capturing forms of analysis typically
considered fairly dissimilar.</p><p>First, we describe the monad stack and metafunctions that implement a
symbolic executor &nbsp;(<a href="main.html#%28autobib._.King%2C._.James._.C...Symbolic._.Execution._and._.Program._.Testing.Commun..._.A.C.M1976%29" data-pltdoc="x">C.</a> <a href="main.html#%28autobib._.King%2C._.James._.C...Symbolic._.Execution._and._.Program._.Testing.Commun..._.A.C.M1976%29" data-pltdoc="x">1976</a>), then we show how
abstractions discussed in previous sections can be applied to enforce
termination, turning a traditional symbolic execution into a
path-sensitive verification engine.</p><p>To support symbolic execution, the syntax of the language is extended to
include symbolic numbers:</p><p><table cellspacing="0" cellpadding="0"><tr><td align="left"><p><span style="font-style: italic">e &#8712; exp</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">::=</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">... | (sym </span><span style="font-style: italic">x</span><span class="stt">)</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">symbolic number</span>]</p></td></tr><tr><td align="left"><p><span style="font-style: italic">&#949; &#8712; pexp</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">::=</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span style="font-style: italic">e</span> <span class="stt">|</span> <span style="font-style: italic">&#172;e</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">path expression</span>]</p></td></tr><tr><td align="left"><p><span style="font-style: italic">&#966; &#8712; pcon</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span class="stt">::=</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p><span style="font-style: italic">P</span>(<span style="font-style: italic">pexp</span>)<span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td align="right"><p>[<span style="font-style: italic">path condition</span>]</p></td></tr></table></p><p><a href="main.html#%28counter._%28figure._f~3asymbolic-widen%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">12</span></a> shows the units needed to turn the
existing interpreter into a symbolic executor. Primitives such as
<span class="RktVal">'</span><span class="RktVal">/</span> now also take as input and return symbolic values. As
standard, symbolic execution employs a path-condition accumulating
assumptions made at each branch, allowing the elimination of provably
infeasible paths and construction of test cases. We represent the
path-condition <span class="RktSym">&#966;</span> as a set of symbolic values or their
negations.  If <span class="RktSym">e</span> is in <span class="RktSym">&#966;</span>, <span class="RktSym">e</span> is assumed to
evaluate to <span class="RktVal">0</span>; if <span class="RktSym">&#172;</span><span class="stt"> </span><span class="RktSym">e</span> is in <span class="RktSym">&#966;</span>, <span class="RktSym">e</span>
is assumed to evaluate to non-<span class="RktVal">0</span>.  This set is another state
component provided by <span class="RktSym">StateT</span> in the monad transformer
stack. Monadic operations <span class="RktSym">get-path-cond</span> and <span class="RktSym">refine</span>
reference and update the path-condition. The metafunction
<span class="RktSym">zero?</span>  works similarly to the concrete counterpart, but also
uses the path-condition to prove that some symbolic numbers are
definitely <span class="RktVal">0</span> or non-<span class="RktVal">0</span>. In case of uncertainty,
<span class="RktSym">zero?</span> returns both answers instead of refining the
path-condition with the assumption made.</p><p><div class="SIntrapara">In the following example, the symbolic executor recognizes that result
<span class="RktVal">3</span> and division-by-0 error are not feasible:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktRes">(set</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes">(cons '(quotient 5 x) (set '(&#172; x)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes">(cons 2 (set 'x)))</span></p></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">A scaled up symbolic executor could implement <span class="RktSym">zero?</span> by
calling out to an SMT solver for more interesting reasoning about
arithmetic, or extend the language with symbolic functions and blame
semantics for sound higher-order symbolic execution, essentially
recreating a pushdown variant of Nguy&#7877;n et
al.&nbsp;(<a href="main.html#%28autobib._.Nguy~e1~bb~85n%2C._.Ph~c3~bac._.C..._and._.Van._.Horn%2C._.David.Relatively._.Complete._.Counterexamples._for._.Higher-order._.Programs.In._.Proc..._.Proceedings._of._the._36th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2015%29" data-pltdoc="x">C. and David</a> <a href="main.html#%28autobib._.Nguy~e1~bb~85n%2C._.Ph~c3~bac._.C..._and._.Van._.Horn%2C._.David.Relatively._.Complete._.Counterexamples._for._.Higher-order._.Programs.In._.Proc..._.Proceedings._of._the._36th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2015%29" data-pltdoc="x">2015</a>; <a href="main.html#%28autobib._.Nguy~e1~bb~85n%2C._.Ph~c3~bac._.C..%2C._.Tobin-.Hochstadt%2C._.Sam%2C._and._.Van._.Horn%2C._.David.Soft._.Contract._.Verification.In._.Proc..._.Proceedings._of._the._19th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2014%29" data-pltdoc="x">C. et al.</a> <a href="main.html#%28autobib._.Nguy~e1~bb~85n%2C._.Ph~c3~bac._.C..%2C._.Tobin-.Hochstadt%2C._.Sam%2C._and._.Van._.Horn%2C._.David.Soft._.Contract._.Verification.In._.Proc..._.Proceedings._of._the._19th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2014%29" data-pltdoc="x">2014</a>; <a href="main.html#%28autobib._.Tobin-.Hochstadt%2C._.Sam._and._.Van._.Horn%2C._.David.Higher-order._symbolic._execution._via._contracts.In._.Proc..._.Proceedings._of._the._.A.C.M._.International._.Conference._on._.Object._.Oriented._.Programming._.Systems._.Languages._and._.Applications2012%29" data-pltdoc="x">Sam and David</a> <a href="main.html#%28autobib._.Tobin-.Hochstadt%2C._.Sam._and._.Van._.Horn%2C._.David.Higher-order._symbolic._execution._via._contracts.In._.Proc..._.Proceedings._of._the._.A.C.M._.International._.Conference._on._.Object._.Oriented._.Programming._.Systems._.Languages._and._.Applications2012%29" data-pltdoc="x">2012</a>).</div></p><p>Traditional symbolic executors mainly aim to find bugs and do not
provide a termination guarantee. However, when we apply to this
symbolic executor the finite abstractions presented in previous
sections, namely base value widening and finite allocation
(<a href="main.html#%28part._s~3abase%29" data-pltdoc="x">Abstracting Base Values</a>), and caching and fixing (<a href="main.html#%28part._s~3acache%29" data-pltdoc="x">Caching and Finding Fixed-points</a>), we turn
the symbolic execution into a sound, path-sensitive program
verification engine.</p><p>There is one wrinkle, which is that operations on symbolic values
introduce a new source of unboundness in the state-space, because the
space of symbolic values is not finite. A simple strategy to ensure
termination is to widen a symbolic value to the abstract number &#11816;&rsquo;N&#11817;
when it shares an address with a different number, similarly to the
precision-preserving abstraction from
<a href="main.html#%28part._s~3aalt-abstraction%29" data-pltdoc="x">An Alternative Abstraction</a>. <a href="main.html#%28counter._%28figure._f~3asymbolic-widen%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">12</span></a> shows
extension to <span class="RktSym">&#948;</span> and <span class="RktSym">zero?</span> in the presence of
<span class="RktVal">'</span><span class="RktVal">N</span>. The different treatments of <span class="RktVal">'</span><span class="RktVal">N</span> and symbolic
values clarifies that abstract values are not symbolic values: the
former stands for a set of multiple values, whereas the latter stands
for an single unknown value. Tests on abstract number <span class="RktVal">'</span><span class="RktVal">N</span> do
not strengthen the path-condition; it is unsound to accumulate any
assumption about <span class="RktVal">'</span><span class="RktVal">N</span>.</p><h3>9<tt>&nbsp;</tt><a name="(part._s~3agc)"></a>Garbage Collection</h3><p>As a denouement to our series of examples, we show how to incorporate
garbage collection into our definitional abstract interpreter.</p><p>This example, like store-widening, is the re-creation of a well-known
technique: abstract garbage collection
&nbsp;(<a href="main.html#%28autobib._.Might%2C._.Matthew._and._.Shivers%2C._.Olin.Improving._.Flow._.Analyses._via._~5c%28~5c.Gamma~5c%29.C.F.A~3a._.Abstract._.Garbage._.Collection._and._.Counting.In._.Proc..._.I.C.F.P%27062006%29" data-pltdoc="x">Matthew and Olin</a> <a href="main.html#%28autobib._.Might%2C._.Matthew._and._.Shivers%2C._.Olin.Improving._.Flow._.Analyses._via._~5c%28~5c.Gamma~5c%29.C.F.A~3a._.Abstract._.Garbage._.Collection._and._.Counting.In._.Proc..._.I.C.F.P%27062006%29" data-pltdoc="x">2006b</a>) mimics the process of reclaiming
unreachable heap addresses as done in garbage-collecting concrete
interpreters.  While garbage collection in the concrete can largely be
considered an implementation detail that doesn&rsquo;t effect the results of
computation (modulo pragmatic issues of memory consumption), in the
abstract semantics, garbage collection can have a significant positive
effect on the precision of analysis results.  This is because store
locations mediate joins, and therefore points of imprecision, in the
abstract semantics.  If an address can be cleared-out and recycled,
this represents the avoidance of a join that would be encountered in a
non-garbage-collecting abstract interpreter.</p><p>In the finite-state-machine model, abstract garbage collection is
fairly straightforward and closely follows concrete formulations
&nbsp;(<a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Abstracting._.Abstract._.Machines.In._.Proc..._.Proceedings._of._the._15th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">David and Matthew</a> <a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Abstracting._.Abstract._.Machines.In._.Proc..._.Proceedings._of._the._15th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">2010</a>; <a href="main.html#%28autobib._.Might%2C._.Matthew._and._.Shivers%2C._.Olin.Improving._.Flow._.Analyses._via._~5c%28~5c.Gamma~5c%29.C.F.A~3a._.Abstract._.Garbage._.Collection._and._.Counting.In._.Proc..._.I.C.F.P%27062006%29" data-pltdoc="x">Matthew and Olin</a> <a href="main.html#%28autobib._.Might%2C._.Matthew._and._.Shivers%2C._.Olin.Improving._.Flow._.Analyses._via._~5c%28~5c.Gamma~5c%29.C.F.A~3a._.Abstract._.Garbage._.Collection._and._.Counting.In._.Proc..._.I.C.F.P%27062006%29" data-pltdoc="x">2006b</a>).
However, incorporating both pushdown control flow and abstract garbage
collection has proved rather involved and required new techniques
&nbsp;(<a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Sergey%2C._.Ilya%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Introspective._pushdown._analysis._of._higher-order._programs.In._.Proc..._.Proceedings._of._the._17th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">Christopher et al.</a> <a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Sergey%2C._.Ilya%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Introspective._pushdown._analysis._of._higher-order._programs.In._.Proc..._.Proceedings._of._the._17th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">2012</a>; <a href="main.html#%28autobib._.Johnson%2C._.J..._.Ian%2C._.Sergey%2C._.Ilya%2C._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming2014%29" data-pltdoc="x">Ian et al.</a> <a href="main.html#%28autobib._.Johnson%2C._.J..._.Ian%2C._.Sergey%2C._.Ilya%2C._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming2014%29" data-pltdoc="x">2014</a>).</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">monad-pdcfa-gc@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define-monad</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT+</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">mrun-pdcfa-gc@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-StateT+</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-ReaderT</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">out-$&#8320;, in-$&#8320;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-StateT</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8709;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-ReaderT</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&#963;&#8320;, &#961;&#8320;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&#968;&#8320;</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3agc-monad))" x-target-lift="Figure"></a>Figure&nbsp;13: </span>Monad Instance with Root Address Set</span></p></blockquote><p>The key difficulty for pushdown machine models, which essentially use
abstract models that are pushdown automata, is that the usual approach
to garbage collection is to crawl the call stack to compute the root
set of reachable addresses &nbsp;(<a href="main.html#%28autobib._.Morrisett%2C._.Greg%2C._.Felleisen%2C._.Matthias%2C._and._.Harper%2C._.Robert.Abstract._.Models._of._.Memory._.Management.In._.Proc..._.Proceedings._of._the._.Seventh._.International._.Conference._on._.Functional._.Programming._.Languages._and._.Computer._.Architecture1995%29" data-pltdoc="x">Greg et al.</a> <a href="main.html#%28autobib._.Morrisett%2C._.Greg%2C._.Felleisen%2C._.Matthias%2C._and._.Harper%2C._.Robert.Abstract._.Models._of._.Memory._.Management.In._.Proc..._.Proceedings._of._the._.Seventh._.International._.Conference._on._.Functional._.Programming._.Languages._and._.Computer._.Architecture1995%29" data-pltdoc="x">1995</a>).
Traversing the stack, however, is not something that can be expressed
by a pushdown automata.</p><p>This difficulty is somewhat exacerbated by the definitional
interpreter approach in that there isn&rsquo;t even a stack to traverse!
Nevertheless, as we demonstrate, this challenge can be overcome to
obtain a pushdown, garbage-collecting abstract interpreter.</p><p>Doing so shows that the definitional abstract interpreter approach
also scales to handle so-called <span style="font-style: italic">introspective</span> pushdown analysis
that require some level of introspection on the stack
&nbsp;(<a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Sergey%2C._.Ilya%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Introspective._pushdown._analysis._of._higher-order._programs.In._.Proc..._.Proceedings._of._the._17th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">Christopher et al.</a> <a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Sergey%2C._.Ilya%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Introspective._pushdown._analysis._of._higher-order._programs.In._.Proc..._.Proceedings._of._the._17th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">2012</a>; <a href="main.html#%28autobib._.Johnson%2C._.J..._.Ian%2C._.Sergey%2C._.Ilya%2C._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming2014%29" data-pltdoc="x">Ian et al.</a> <a href="main.html#%28autobib._.Johnson%2C._.J..._.Ian%2C._.Sergey%2C._.Ilya%2C._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming2014%29" data-pltdoc="x">2014</a>).</p><p>Solving the abstract garbage collection problem for a definitional
abstract interpreter boils down to answer the following question: how
can we track root addresses that are live on the call stack when the
call stack is implicitly defined by the metalanguage?  The answer is
fairly simple: we extend the monad with a set of root addresses.  When
evaluating compound expressions, we calculate the appropriate root
sets for the context.  In essence, we render explicit only the
addresses of the calling context, while still relying on the
metalanguage to implicitly take care of the rest as before.</p><p><a href="main.html#%28counter._%28figure._f~3agc-monad%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">13</span></a> defines the appropriate monad instance.  All
that has changed is there is an added reader component, which will be
used to model the context&rsquo;s current root set.</p><p><div class="SIntrapara">The use of this added component necessitates a change to the caching
and fixed-point calculation, namely we must include the root sets as
part of the configuration.  Compared with the <span class="RktSym">ev-cache@</span>
component of <a href="main.html#%28part._s~3acache%29" data-pltdoc="x">Caching and Finding Fixed-points</a>, we make a simple adjustment to the
first few lines to cache the root set along with the rest of the
configuration:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-env</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-roots</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Similarly, for <span class="RktSym">fix-cache@</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">eval</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-env</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-roots</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>We can now write a <span class="RktSym">ev-collect@</span> component that performs the
garbage collection: it asks for the current roots in the context,
evaluates an expression to a value, then updates the store after
garbage collecting all addresses not reachable from the root set of
the context and the roots in the produced value:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-collect</span><span class="hspace">&nbsp;</span><span class="RktSym">ev0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-roots</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev0</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">update-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">gc</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-union</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">roots-v</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Here, <span class="RktSym">gc</span> and <span class="RktSym">roots-v</span> are (omitted) helper functions
that perform garbage collection and calculate the set of root
addresses in a value, respectively.</div></p><p>All that remains is to define a component that propagates root sets
appropriately from compound expressions to their constituents.
<a href="main.html#%28counter._%28figure._f~3agc-collect-roots%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">14</span></a> gives the <span class="RktSym">ev-roots@</span> component, which
does exactly this.</p><p><div class="SIntrapara">Finally, the pieces are stitched together with the following to obtain
a pushdown, garbage-collecting definitional abstract interpreter:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix-cache</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-cache</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-collect</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-roots</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-roots@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-roots</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-roots</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#968;&#8242;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-union</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">roots</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">roots</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local-roots</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;&#8242;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">truish?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">op2</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-roots</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local-roots</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-union</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">roots</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local-roots</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-union</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">roots-v</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">app</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">ask-roots</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local-roots</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-union</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">roots</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local-roots</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-union</span><span class="hspace">&nbsp;</span><span class="RktSym">&#968;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">roots-v</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lam</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;&#8242;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">alloc</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">local-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#961;&#8242;</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._f~3agc-collect-roots))" x-target-lift="Figure"></a>Figure&nbsp;14: </span>Address Collection and Propagation</span></p></blockquote><h3>10<tt>&nbsp;</tt><a name="(part._s~3arelated-work)"></a>Related work</h3><p>This work draws upon and re-presents many ideas from the literature on
abstract interpretation for higher-order
languages &nbsp;(<a href="main.html#%28autobib._.Midtgaard%2C._.Jan.Control-flow._.Analysis._of._.Functional._.Programs.A.C.M._.Comput..._.Surv..2012%29" data-pltdoc="x">Jan</a> <a href="main.html#%28autobib._.Midtgaard%2C._.Jan.Control-flow._.Analysis._of._.Functional._.Programs.A.C.M._.Comput..._.Surv..2012%29" data-pltdoc="x">2012</a>).  In particular, it
closely follows the abstracting abstract
machines &nbsp;(<a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Abstracting._.Abstract._.Machines.In._.Proc..._.Proceedings._of._the._15th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">David and Matthew</a> <a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Abstracting._.Abstract._.Machines.In._.Proc..._.Proceedings._of._the._15th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">2010</a>, <a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Systematic._abstraction._of._abstract._machines.Journal._of._.Functional._.Programming2012%29" data-pltdoc="x">2012</a>)
approach to deriving abstract interpreters from a small-step
machine. The key difference here is that we operate in the setting of
a monadic definitional interpreter instead of an abstract machine. In
moving to this new setting we developed a novel caching mechanism and
fixed-point algorithm, but otherwise followed the same
recipe. Remarkably, in the setting of definitional interpreters, the
pushdown property for the analysis is simply inherited from the
meta-language rather than requiring explicit instrumentation to the
abstract interpreter.</p><p>Compositionally defined abstract interpretation functions for
higher-order languages were first explored by
<a href="main.html#%28autobib._.Jones%2C._.Neil._.D..._and._.Nielson%2C._.Flemming.Abstract._.Interpretation~3a._.A._.Semantics-based._.Tool._for._.Program._.Analysis.In._.Proc..._.Handbook._of._.Logic._in._.Computer._.Science._%28.Vol..._4%291995%29" data-pltdoc="x">D. and Flemming</a>&nbsp;(<a href="main.html#%28autobib._.Jones%2C._.Neil._.D..._and._.Nielson%2C._.Flemming.Abstract._.Interpretation~3a._.A._.Semantics-based._.Tool._for._.Program._.Analysis.In._.Proc..._.Handbook._of._.Logic._in._.Computer._.Science._%28.Vol..._4%291995%29" data-pltdoc="x">1995</a>), which introduces the technique of
interpreting a higher-order object language directly as terms in a
meta-language to perform abstract interpretation. While their work
lays the foundations for this idea, it does not consider abstractions
for fixed-points in the domain, so although their abstract interpreters
are sound, they are not in general computable. They propose a na&#239;ve
solution of truncating the interpretation of syntactic fixed-points to
some finite depth, but this solution isn&rsquo;t general and doesn&rsquo;t account
for non-syntactic occurrences of bottom in the concrete domain (<span style="font-style: italic">e.g.</span>
<span style="font-style: italic">via</span> Y combinators). Our work develops such an abstraction for concrete
denotational fixed-points using a fixed-point caching algorithm, resulting in
general, computable abstractions for arbitrary definitional interpreters.</p><p>The use of monads and monad transformers to make extensible (concrete)
interpreters is a well-known
idea &nbsp;(<a href="main.html#%28autobib._.Moggi%2C._.Eugenio.An._.Abstract._.View._of._.Programming._.Languages.Edinburgh._.University1989%29" data-pltdoc="x">Eugenio</a> <a href="main.html#%28autobib._.Moggi%2C._.Eugenio.An._.Abstract._.View._of._.Programming._.Languages.Edinburgh._.University1989%29" data-pltdoc="x">1989</a>; <a href="main.html#%28autobib._.Steele%2C.Jr..%2C._.Guy._.L...Building._.Interpreters._by._.Composing._.Monads.In._.Proc..._.Proceedings._of._the._21st._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1994%29" data-pltdoc="x">L.</a> <a href="main.html#%28autobib._.Steele%2C.Jr..%2C._.Guy._.L...Building._.Interpreters._by._.Composing._.Monads.In._.Proc..._.Proceedings._of._the._21st._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1994%29" data-pltdoc="x">1994</a>; <a href="main.html#%28autobib._.Liang%2C._.Sheng%2C._.Hudak%2C._.Paul%2C._and._.Jones%2C._.Mark.Monad._.Transformers._and._.Modular._.Interpreters.In._.Proc..._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995%29" data-pltdoc="x">Sheng et al.</a> <a href="main.html#%28autobib._.Liang%2C._.Sheng%2C._.Hudak%2C._.Paul%2C._and._.Jones%2C._.Mark.Monad._.Transformers._and._.Modular._.Interpreters.In._.Proc..._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995%29" data-pltdoc="x">1995</a>),
which we have extended to work for compositional abstract
interpreters.  The use of monads and monad transformers in machine
based-formulations of abstract interpreters has previously been
explored by <a href="main.html#%28autobib._.Sergey%2C._.Ilya%2C._.Devriese%2C._.Dominique%2C._.Might%2C._.Matthew%2C._.Midtgaard%2C._.Jan%2C._.Darais%2C._.David%2C._.Clarke%2C._.Dave%2C._and._.Piessens%2C._.Frank.Monadic._.Abstract._.Interpreters.In._.Proc..._.Proceedings._of._the._34th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2013%29" data-pltdoc="x">Ilya et al.</a>&nbsp;(<a href="main.html#%28autobib._.Sergey%2C._.Ilya%2C._.Devriese%2C._.Dominique%2C._.Might%2C._.Matthew%2C._.Midtgaard%2C._.Jan%2C._.Darais%2C._.David%2C._.Clarke%2C._.Dave%2C._and._.Piessens%2C._.Frank.Monadic._.Abstract._.Interpreters.In._.Proc..._.Proceedings._of._the._34th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2013%29" data-pltdoc="x">2013</a>) and
<a href="main.html#%28autobib._.Darais%2C._.David%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Galois._.Transformers._and._.Modular._.Abstract._.Interpreters~3a._.Reusable._.Metatheory._for._.Program._.Analysis.In._.Proc..._.Proceedings._of._the._2015._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages%2C._and._.Applications2015%29" data-pltdoc="x">David et al.</a>&nbsp;(<a href="main.html#%28autobib._.Darais%2C._.David%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Galois._.Transformers._and._.Modular._.Abstract._.Interpreters~3a._.Reusable._.Metatheory._for._.Program._.Analysis.In._.Proc..._.Proceedings._of._the._2015._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages%2C._and._.Applications2015%29" data-pltdoc="x">2015</a>), respectively, and inspired our own
adoption of these ideas.  Darais has also shown that certain monad
transformers are also <span style="font-style: italic">Galois transformers</span>, i.e. they compose to
form monads that transport Galois connections.  This idea may pave a
path forward for obtaining both compositional code <span style="font-style: italic">and proofs</span>
for abstract interpreters in the style presented here.</p><p>The caching mechanism used to ensure termination in our abstract interpreter is
similar to that used by <a href="main.html#%28autobib._.Johnson%2C._.J..~7e.Ian._and._.Van._.Horn%2C._.David.Abstracting._.Abstract._.Control.In._.Proc..._.Proceedings._of._the._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014%29" data-pltdoc="x">J.~Ian and David</a>&nbsp;(<a href="main.html#%28autobib._.Johnson%2C._.J..~7e.Ian._and._.Van._.Horn%2C._.David.Abstracting._.Abstract._.Control.In._.Proc..._.Proceedings._of._the._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014%29" data-pltdoc="x">2014</a>). They use a local- and
meta-memoization table in a machine-based interpreter to ensure termination for
a pushdown abstract interpreter.  This mechanism is in turn reminiscent of
Gl&#252;ck&rsquo;s use of memoization in an interpreter for two-way non-deterministic
pushdown automata &nbsp;(<a href="main.html#%28autobib._.Gl~c3~bcck%2C._.Robert.Simulation._of._.Two-.Way._.Pushdown._.Automata._.Revisited.In._.Proc..._.Semantics%2C._.Abstract._.Interpretation%2C._and._.Reasoning._about._.Programs~3a._.Essays._.Dedicated._to._.David._.A..._.Schmidt._on._the._.Occasion._of._his._.Sixtieth._.Birthday%2C~0a._._._._._._._._._._._._._._._.Manhattan%2C._.Kansas%2C._.U.S.A%2C._19-20th._.September._20132013%29" data-pltdoc="x">Robert</a> <a href="main.html#%28autobib._.Gl~c3~bcck%2C._.Robert.Simulation._of._.Two-.Way._.Pushdown._.Automata._.Revisited.In._.Proc..._.Semantics%2C._.Abstract._.Interpretation%2C._and._.Reasoning._about._.Programs~3a._.Essays._.Dedicated._to._.David._.A..._.Schmidt._on._the._.Occasion._of._his._.Sixtieth._.Birthday%2C~0a._._._._._._._._._._._._._._._.Manhattan%2C._.Kansas%2C._.U.S.A%2C._19-20th._.September._20132013%29" data-pltdoc="x">2013</a>).</p><p>Caching recursive, non-deterministic functions is a well-studied
problem in the functional logic programming community under the rubric
of &ldquo;tabling&rdquo; &nbsp;(<a href="main.html#%28autobib._.Tamaki%2C._.Hisao._and._.Sato%2C._.Taisuke.O.L.D._resolution._with._tabulation.In._.Proc..._.International._.Conference._on._.Logic._.Programming1986%29" data-pltdoc="x">Hisao and Taisuke</a> <a href="main.html#%28autobib._.Tamaki%2C._.Hisao._and._.Sato%2C._.Taisuke.O.L.D._resolution._with._tabulation.In._.Proc..._.International._.Conference._on._.Logic._.Programming1986%29" data-pltdoc="x">1986</a>; <a href="main.html#%28autobib._.Bol%2C._.Roland._.N._and._.Degerstedt%2C._.Lars.Tabulated._.Resolution._for._.Well._.Founded._.Semantics...In._.Proc..._.I.L.P.S1993%29" data-pltdoc="x">N and Lars</a> <a href="main.html#%28autobib._.Bol%2C._.Roland._.N._and._.Degerstedt%2C._.Lars.Tabulated._.Resolution._for._.Well._.Founded._.Semantics...In._.Proc..._.I.L.P.S1993%29" data-pltdoc="x">1993</a>; <a href="main.html#%28autobib._.Swift%2C._.Terrance._and._.Warren%2C._.David._.S.X.S.B~3a._.Extending._.Prolog._with._tabled._logic._programming.Theory._and._.Practice._of._.Logic._.Programming._12%281-2%29%2C._pp..._157--1872012%29" data-pltdoc="x">Terrance and S</a> <a href="main.html#%28autobib._.Swift%2C._.Terrance._and._.Warren%2C._.David._.S.X.S.B~3a._.Extending._.Prolog._with._tabled._logic._programming.Theory._and._.Practice._of._.Logic._.Programming._12%281-2%29%2C._pp..._157--1872012%29" data-pltdoc="x">2012</a>; <a href="main.html#%28autobib._.Chen%2C._.Weidong._and._.Warren%2C._.David._.S.Tabled._evaluation._with._delaying._for._general._logic._programs.Journal._of._the._.A.C.M._%28.J.A.C.M%29._43%281%29%2C._pp..._20--741996%29" data-pltdoc="x">Weidong and S</a> <a href="main.html#%28autobib._.Chen%2C._.Weidong._and._.Warren%2C._.David._.S.Tabled._evaluation._with._delaying._for._general._logic._programs.Journal._of._the._.A.C.M._%28.J.A.C.M%29._43%281%29%2C._pp..._20--741996%29" data-pltdoc="x">1996</a>), and has been usefully
applied to program verification and
analysis &nbsp;(<a href="main.html#%28autobib._.Janssens%2C._.Gerda._and._.Sagonas%2C._.Konstantinos._.F.On._the._.Use._of._.Tabling._for._.Abstract._.Interpretation~3a._.An._.Experiment._with._.Abstract._.Equation._.Systems...In._.Proc..._.T.A.P.D1998%29" data-pltdoc="x">Gerda and F</a> <a href="main.html#%28autobib._.Janssens%2C._.Gerda._and._.Sagonas%2C._.Konstantinos._.F.On._the._.Use._of._.Tabling._for._.Abstract._.Interpretation~3a._.An._.Experiment._with._.Abstract._.Equation._.Systems...In._.Proc..._.T.A.P.D1998%29" data-pltdoc="x">1998</a>; <a href="main.html#%28autobib._.Dawson%2C._.Steven%2C._.Ramakrishnan%2C._.C..._.R..%2C._and._.Warren%2C._.David._.S...Practical._.Program._.Analysis._.Using._.General._.Purpose._.Logic._.Programming._.Systems---a._.Case._.Study.In._.Proc..._.Proceedings._of._the._.A.C.M._.S.I.G.P.L.A.N._1996._.Conference._on._.Programming._.Language._.Design._and._.Implementation1996http~3a%2F%2Fdoi..acm..org%2F10..1145%2F231379..231399%29" data-pltdoc="x">Steven et al.</a> <a href="main.html#%28autobib._.Dawson%2C._.Steven%2C._.Ramakrishnan%2C._.C..._.R..%2C._and._.Warren%2C._.David._.S...Practical._.Program._.Analysis._.Using._.General._.Purpose._.Logic._.Programming._.Systems---a._.Case._.Study.In._.Proc..._.Proceedings._of._the._.A.C.M._.S.I.G.P.L.A.N._1996._.Conference._on._.Programming._.Language._.Design._and._.Implementation1996http~3a%2F%2Fdoi..acm..org%2F10..1145%2F231379..231399%29" data-pltdoc="x">1996</a>). Unlike these systems, our approach uses a
shallow embedding of cached non-determinism that can be applied in
general-purpose functional languages.
%
Monad transformers that enable shallow embedding of cached non-determinism are
of continued interest since Hinze&rsquo;s <span style="font-style: italic">Deriving Backtracking Monad
Transformers</span> &nbsp;(<a href="main.html#%28autobib._.Kiselyov%2C._.Oleg%2C._.Shan%2C._.Chung-chieh%2C._.Friedman%2C._.Daniel._.P..%2C._and._.Sabry%2C._.Amr.Backtracking%2C._.Interleaving%2C._and._.Terminating._.Monad._.Transformers~3a._%28.Functional._.Pearl%29.In._.Proc..._.Proceedings._of._the._.Tenth._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2005%29" data-pltdoc="x">Oleg et al.</a> <a href="main.html#%28autobib._.Kiselyov%2C._.Oleg%2C._.Shan%2C._.Chung-chieh%2C._.Friedman%2C._.Daniel._.P..%2C._and._.Sabry%2C._.Amr.Backtracking%2C._.Interleaving%2C._and._.Terminating._.Monad._.Transformers~3a._%28.Functional._.Pearl%29.In._.Proc..._.Proceedings._of._the._.Tenth._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2005%29" data-pltdoc="x">2005</a>; <a href="main.html#%28autobib._.Hinze%2C._.Ralf.Deriving._.Backtracking._.Monad._.Transformers.In._.Proc..._.Proceedings._of._the._.Fifth._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2000%29" data-pltdoc="x">Ralf</a> <a href="main.html#%28autobib._.Hinze%2C._.Ralf.Deriving._.Backtracking._.Monad._.Transformers.In._.Proc..._.Proceedings._of._the._.Fifth._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2000%29" data-pltdoc="x">2000</a>; <a href="main.html#%28autobib._.Fischer%2C._.Sebastian%2C._.Kiselyov%2C._.Oleg%2C._and._.Shan%2C._.Chung-chieh.Purely._functional._lazy._nondeterministic._programming.Journal._of._.Functional._.Programming._21%284-5%29%2C._pp..._413--4652011%29" data-pltdoc="x">Sebastian et al.</a> <a href="main.html#%28autobib._.Fischer%2C._.Sebastian%2C._.Kiselyov%2C._.Oleg%2C._and._.Shan%2C._.Chung-chieh.Purely._functional._lazy._nondeterministic._programming.Journal._of._.Functional._.Programming._21%284-5%29%2C._pp..._413--4652011%29" data-pltdoc="x">2011</a>), and recent work &nbsp;(<a href="main.html#%28autobib._.Vandenbroucke%2C._.Alexander%2C._.Schrijvers%2C._.Tom%2C._and._.Piessens%2C._.Frank.Fixing._non-determinism.In._.Proc..._.I.F.L._2015~3a._.Symposium._on._the._implementation._and._application._of._functional._programming._languages._.Proceedings2016%29" data-pltdoc="x">Alexander et al.</a> <a href="main.html#%28autobib._.Vandenbroucke%2C._.Alexander%2C._.Schrijvers%2C._.Tom%2C._and._.Piessens%2C._.Frank.Fixing._non-determinism.In._.Proc..._.I.F.L._2015~3a._.Symposium._on._the._implementation._and._application._of._functional._programming._languages._.Proceedings2016%29" data-pltdoc="x">2016</a>; <a href="main.html#%28autobib._.Ploeg%2C._.Atze._van._der._and._.Kiselyov%2C._.Oleg.Reflection._without._remorse~3a._revealing._a._hidden._sequence._to._speed._up._monadic._reflection.In._.Proc..._.Proceedings._of._the._2014._.A.C.M._.S.I.G.P.L.A.N._.Symposium._on._.Haskell2014%29" data-pltdoc="x">der and Oleg</a> <a href="main.html#%28autobib._.Ploeg%2C._.Atze._van._der._and._.Kiselyov%2C._.Oleg.Reflection._without._remorse~3a._revealing._a._hidden._sequence._to._speed._up._monadic._reflection.In._.Proc..._.Proceedings._of._the._2014._.A.C.M._.S.I.G.P.L.A.N._.Symposium._on._.Haskell2014%29" data-pltdoc="x">2014</a>) points to potential optimizations and
specializations that can be applied to our relatively naive iteration strategy.</p><p>Vardoulakis, who was the first to develop the idea of a pushdown abstraction
for higher-order flow analysis &nbsp;(<a href="main.html#%28autobib._.Vardoulakis%2C._.Dimitrios._and._.Shivers%2C._.Olin.C.F.A2~3a._a._.Context-.Free.Approach._to._.Control-.Flow.Analysis.Logical._.Methods._in._.Computer._.Science2011%29" data-pltdoc="x">Dimitrios and Olin</a> <a href="main.html#%28autobib._.Vardoulakis%2C._.Dimitrios._and._.Shivers%2C._.Olin.C.F.A2~3a._a._.Context-.Free.Approach._to._.Control-.Flow.Analysis.Logical._.Methods._in._.Computer._.Science2011%29" data-pltdoc="x">2011</a>), formalized
CFA2 using a CPS model, which is similar in spirit to a machine-based model.
However, in his dissertation &nbsp;(<a href="main.html#%28autobib._.Dimitrios._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Northeastern._.University2012%29" data-pltdoc="x">Vardoulakis</a> <a href="main.html#%28autobib._.Dimitrios._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Northeastern._.University2012%29" data-pltdoc="x">2012</a>) he sketches an
alternative presentation dubbed &ldquo;Big CFA2&rdquo; which is a big-step operational
semantics for doing pushdown analysis quite similar in spirit to the approach
presented here.  One key difference is that Big CFA2 fixes a particular coarse
abstraction of base values and closures&#8212;<wbr></wbr>for example, both branches of a
conditional are always evaluated.  Consequently, it only uses a single
iteration of the abstract evaluation function, and avoids the need for the
cache-based fixed-point of <a href="main.html#%28part._s~3acache%29" data-pltdoc="x">Caching and Finding Fixed-points</a>.  We believe Big CFA2 as
stated is sound, however if the underlying abstractions were tightened, it
may then require a more involved fixed-point finding algorithm like the one we
developed.</p><p>Our formulation of a pushdown abstract interpreter computes an abstraction
similar to the many existing variants of pushdown flow analysis
&nbsp;(<a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Sergey%2C._.Ilya%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Introspective._pushdown._analysis._of._higher-order._programs.In._.Proc..._.Proceedings._of._the._17th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">Christopher et al.</a> <a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Sergey%2C._.Ilya%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Introspective._pushdown._analysis._of._higher-order._programs.In._.Proc..._.Proceedings._of._the._17th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">2012</a>; <a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._control-flow._analysis._of._higher-order._programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">Christopher et al.</a> <a href="main.html#%28autobib._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._control-flow._analysis._of._higher-order._programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">2010</a>; <a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Systematic._abstraction._of._abstract._machines.Journal._of._.Functional._.Programming2012%29" data-pltdoc="x">David and Matthew</a> <a href="main.html#%28autobib._.Van._.Horn%2C._.David._and._.Might%2C._.Matthew.Systematic._abstraction._of._abstract._machines.Journal._of._.Functional._.Programming2012%29" data-pltdoc="x">2012</a>; <a href="main.html#%28autobib._.Vardoulakis%2C._.Dimitrios._and._.Shivers%2C._.Olin.C.F.A2~3a._a._.Context-.Free.Approach._to._.Control-.Flow.Analysis.Logical._.Methods._in._.Computer._.Science2011%29" data-pltdoc="x">Dimitrios and Olin</a> <a href="main.html#%28autobib._.Vardoulakis%2C._.Dimitrios._and._.Shivers%2C._.Olin.C.F.A2~3a._a._.Context-.Free.Approach._to._.Control-.Flow.Analysis.Logical._.Methods._in._.Computer._.Science2011%29" data-pltdoc="x">2011</a>; <a href="main.html#%28autobib._.Johnson%2C._.J..._.Ian%2C._.Sergey%2C._.Ilya%2C._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming2014%29" data-pltdoc="x">Ian et al.</a> <a href="main.html#%28autobib._.Johnson%2C._.J..._.Ian%2C._.Sergey%2C._.Ilya%2C._.Earl%2C._.Christopher%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming2014%29" data-pltdoc="x">2014</a>; <a href="main.html#%28autobib._.Johnson%2C._.J..~7e.Ian._and._.Van._.Horn%2C._.David.Abstracting._.Abstract._.Control.In._.Proc..._.Proceedings._of._the._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014%29" data-pltdoc="x">J.~Ian and David</a> <a href="main.html#%28autobib._.Johnson%2C._.J..~7e.Ian._and._.Van._.Horn%2C._.David.Abstracting._.Abstract._.Control.In._.Proc..._.Proceedings._of._the._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014%29" data-pltdoc="x">2014</a>; <a href="main.html#%28autobib._.Gilray%2C._.Thomas%2C._.Lyde%2C._.Steven%2C._.Adams%2C._.Michael._.D..%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._.Control-flow._.Analysis._for._.Free.In._.Proc..._.Proceedings._of._the._43rd._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2016%29" data-pltdoc="x">Thomas et al.</a> <a href="main.html#%28autobib._.Gilray%2C._.Thomas%2C._.Lyde%2C._.Steven%2C._.Adams%2C._.Michael._.D..%2C._.Might%2C._.Matthew%2C._and._.Van._.Horn%2C._.David.Pushdown._.Control-flow._.Analysis._for._.Free.In._.Proc..._.Proceedings._of._the._43rd._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2016%29" data-pltdoc="x">2016</a>; <a href="main.html#%28autobib._.Dimitrios._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Northeastern._.University2012%29" data-pltdoc="x">Vardoulakis</a> <a href="main.html#%28autobib._.Dimitrios._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Northeastern._.University2012%29" data-pltdoc="x">2012</a>).</p><p>The mixing of symbolic execution and abstract interpretation is
similar in spirit to the <span style="font-style: italic">logic flow analysis</span> of Might
&nbsp;(<a href="main.html#%28autobib._.Might%2C._.Matthew.Logic-flow._.Analysis._of._.Higher-order._.Programs.In._.Proc..._.Proceedings._of._the._34th._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2007%29" data-pltdoc="x">Matthew</a> <a href="main.html#%28autobib._.Might%2C._.Matthew.Logic-flow._.Analysis._of._.Higher-order._.Programs.In._.Proc..._.Proceedings._of._the._34th._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2007%29" data-pltdoc="x">2007b</a>), albeit in a pushdown setting and with a
stronger notion of negation; generally, our presentation resembles
traditional formulations of symbolic execution more closely
&nbsp;(<a href="main.html#%28autobib._.King%2C._.James._.C...Symbolic._.Execution._and._.Program._.Testing.Commun..._.A.C.M1976%29" data-pltdoc="x">C.</a> <a href="main.html#%28autobib._.King%2C._.James._.C...Symbolic._.Execution._and._.Program._.Testing.Commun..._.A.C.M1976%29" data-pltdoc="x">1976</a>).  Our approach to symbolic execution
only handles the first-order case of symbolic values, as is common.
However, Nguy&#7877;n&rsquo;s work on higher-order symbolic execution
&nbsp;(<a href="main.html#%28autobib._.Nguy~e1~bb~85n%2C._.Ph~c3~bac._.C..._and._.Van._.Horn%2C._.David.Relatively._.Complete._.Counterexamples._for._.Higher-order._.Programs.In._.Proc..._.Proceedings._of._the._36th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2015%29" data-pltdoc="x">C. and David</a> <a href="main.html#%28autobib._.Nguy~e1~bb~85n%2C._.Ph~c3~bac._.C..._and._.Van._.Horn%2C._.David.Relatively._.Complete._.Counterexamples._for._.Higher-order._.Programs.In._.Proc..._.Proceedings._of._the._36th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2015%29" data-pltdoc="x">2015</a>) demonstrates how to scale to
behavioral symbolic values.  In principle, it should be possible to
handle this case in our approach by adapting Nguy&#7877;n&rsquo;s method to a
formulation in a compositional evaluator, but this remains to be
carried out.</p><p>Now that we have abstract interpreters formulated with a basis in abstract
machines and with a basis in monadic interpreters, an obvious question is can
we obtain a correspondence between them similar to the functional
correspondence between their concrete
counterparts &nbsp;(<a href="main.html#%28autobib._.Ager%2C._.Mads._.S..%2C._.Danvy%2C._.Olivier%2C._and._.Midtgaard%2C._.Jan.A._functional._correspondence._between._monadic._evaluators._and._abstract._machines._for._languages._with._computational._effects.Theoretical._.Computer._.Science2005%29" data-pltdoc="x">S. et al.</a> <a href="main.html#%28autobib._.Ager%2C._.Mads._.S..%2C._.Danvy%2C._.Olivier%2C._and._.Midtgaard%2C._.Jan.A._functional._correspondence._between._monadic._evaluators._and._abstract._machines._for._languages._with._computational._effects.Theoretical._.Computer._.Science2005%29" data-pltdoc="x">2005</a>).  An interesting direction for
future work is to try to apply the usual tools of defunctionalization, CPS, and
refocusing to see if we can interderive these abstract semantic artifacts.</p><h3>11<tt>&nbsp;</tt><a name="(part._s~3aconclusion)"></a>Conclusions</h3><p>We have shown that the AAM methodology can be adapted to definitional
interpreters written in monadic style.  Doing so captures a wide
variety of semantics, such as the usual concrete semantics, collecting
semantics, and various abstract interpretations.  Beyond recreating
existing techniques from the literature such as store-widening and
abstract garbage collection, we can also design novel abstractions and
capture disparate forms of program analysis such as symbolic
execution.  Further, our approach enables the novel combination of
these techniques.</p><p>To our surprise, the definitional abstract interpreter we obtained
implements a form of pushdown control flow abstraction in which calls
and returns are always properly matched in the abstract semantics.
True to the definitional style of Reynolds, the evaluator involves no
explicit mechanics to achieve this property; it is simply inherited
from the metalanguage.</p><p>We believe this formulation of abstract interpretation offers a
promising new foundation towards re-usable components for the static
analysis and verification of higher-order programs.  Moreover, we
believe the definitional abstract interpreter approach to be a
fruitful new perspective on an old topic.  We are left wondering: what
else can be profitably inherited from the metalanguage of an abstract
interpreter?</p><h3><a name="(part._doc-bibliography)"></a>Bibliography</h3><p><table cellspacing="0" cellpadding="0" class="AutoBibliography"><tr><td><p><a name="(autobib._.Vandenbroucke,._.Alexander,._.Schrijvers,._.Tom,._and._.Piessens,._.Frank.Fixing._non-determinism.In._.Proc..._.I.F.L._2015~3a._.Symposium._on._the._implementation._and._application._of._functional._programming._languages._.Proceedings2016)"></a><span class="Autobibentry">Vandenbroucke, Alexander, Schrijvers, Tom, and Piessens, Frank. Fixing non-determinism. In <span style="font-style: italic">Proc. IFL 2015: Symposium on the implementation and application of functional programming languages Proceedings</span>, 2016.</span></p></td></tr><tr><td><p><a name="(autobib._.King,._.James._.C...Symbolic._.Execution._and._.Program._.Testing.Commun..._.A.C.M1976)"></a><span class="Autobibentry">King, James C. Symbolic Execution and Program Testing. <span style="font-style: italic">Commun. ACM</span>, 1976.</span></p></td></tr><tr><td><p><a name="(autobib._.Nguy~e1~bb~85n,._.Ph~c3~bac._.C..._and._.Van._.Horn,._.David.Relatively._.Complete._.Counterexamples._for._.Higher-order._.Programs.In._.Proc..._.Proceedings._of._the._36th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2015)"></a><span class="Autobibentry">Nguy&#7877;n, Ph&#250;c C. and Van Horn, David. Relatively Complete Counterexamples for Higher-order Programs. In <span style="font-style: italic">Proc. Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</span>, 2015.</span></p></td></tr><tr><td><p><a name="(autobib._.Nguy~e1~bb~85n,._.Ph~c3~bac._.C..,._.Tobin-.Hochstadt,._.Sam,._and._.Van._.Horn,._.David.Soft._.Contract._.Verification.In._.Proc..._.Proceedings._of._the._19th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2014)"></a><span class="Autobibentry">Nguy&#7877;n, Ph&#250;c C., Tobin-Hochstadt, Sam, and Van Horn, David. Soft Contract Verification. In <span style="font-style: italic">Proc. Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</span>, 2014.</span></p></td></tr><tr><td><p><a name="(autobib._.Reynolds,._.John._.C...Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._'72~3a._.Proceedings._of._the._.A.C.M._.Annual._.Conference1972)"></a><span class="Autobibentry">Reynolds, John C. Definitional interpreters for higher-order programming languages. In <span style="font-style: italic">Proc. ACM &rsquo;72: Proceedings of the ACM Annual Conference</span>, 1972.</span></p></td></tr><tr><td><p><a name="(autobib._.Earl,._.Christopher,._.Sergey,._.Ilya,._.Might,._.Matthew,._and._.Van._.Horn,._.David.Introspective._pushdown._analysis._of._higher-order._programs.In._.Proc..._.Proceedings._of._the._17th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012)"></a><span class="Autobibentry">Earl, Christopher, Sergey, Ilya, Might, Matthew, and Van Horn, David. Introspective pushdown analysis of higher-order programs. In <span style="font-style: italic">Proc. Proceedings of the 17th ACM SIGPLAN International Conference on Functional Programming</span>, 2012.</span></p></td></tr><tr><td><p><a name="(autobib._.Earl,._.Christopher,._.Might,._.Matthew,._and._.Van._.Horn,._.David.Pushdown._control-flow._analysis._of._higher-order._programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010)"></a><span class="Autobibentry">Earl, Christopher, Might, Matthew, and Van Horn, David. Pushdown control-flow analysis of higher-order programs. In <span style="font-style: italic">Proc. Workshop on Scheme and Functional Programming</span>, 2010.</span></p></td></tr><tr><td><p><a name="(autobib._.Jones,._.Neil._.D..._and._.Nielson,._.Flemming.Abstract._.Interpretation~3a._.A._.Semantics-based._.Tool._for._.Program._.Analysis.In._.Proc..._.Handbook._of._.Logic._in._.Computer._.Science._(.Vol..._4)1995)"></a><span class="Autobibentry">Jones, Neil D. and Nielson, Flemming. Abstract Interpretation: A Semantics-based Tool for Program Analysis. In <span style="font-style: italic">Proc. Handbook of Logic in Computer Science (Vol. 4)</span>, 1995.</span></p></td></tr><tr><td><p><a name="(autobib._.Darais,._.David,._.Might,._.Matthew,._and._.Van._.Horn,._.David.Galois._.Transformers._and._.Modular._.Abstract._.Interpreters~3a._.Reusable._.Metatheory._for._.Program._.Analysis.In._.Proc..._.Proceedings._of._the._2015._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Object-.Oriented._.Programming,._.Systems,._.Languages,._and._.Applications2015)"></a><span class="Autobibentry">Darais, David, Might, Matthew, and Van Horn, David. Galois Transformers and Modular Abstract Interpreters: Reusable Metatheory for Program Analysis. In <span style="font-style: italic">Proc. Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications</span>, 2015.</span></p></td></tr><tr><td><p><a name="(autobib._.Van._.Horn,._.David._and._.Might,._.Matthew.Abstracting._.Abstract._.Machines.In._.Proc..._.Proceedings._of._the._15th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2010)"></a><span class="Autobibentry">Van Horn, David and Might, Matthew. Abstracting Abstract Machines. In <span style="font-style: italic">Proc. Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programming</span>, 2010.</span></p></td></tr><tr><td><p><a name="(autobib._.Van._.Horn,._.David._and._.Might,._.Matthew.Systematic._abstraction._of._abstract._machines.Journal._of._.Functional._.Programming2012)"></a><span class="Autobibentry">Van Horn, David and Might, Matthew. Systematic abstraction of abstract machines. <span style="font-style: italic">Journal of Functional Programming</span>, 2012.</span></p></td></tr><tr><td><p><a name="(autobib._.Ploeg,._.Atze._van._der._and._.Kiselyov,._.Oleg.Reflection._without._remorse~3a._revealing._a._hidden._sequence._to._speed._up._monadic._reflection.In._.Proc..._.Proceedings._of._the._2014._.A.C.M._.S.I.G.P.L.A.N._.Symposium._on._.Haskell2014)"></a><span class="Autobibentry">Ploeg, Atze van der and Kiselyov, Oleg. Reflection without remorse: revealing a hidden sequence to speed up monadic reflection. In <span style="font-style: italic">Proc. Proceedings of the 2014 ACM SIGPLAN Symposium on Haskell</span>, 2014.</span></p></td></tr><tr><td><p><a name="(autobib._.Vardoulakis,._.Dimitrios._and._.Shivers,._.Olin.C.F.A2~3a._a._.Context-.Free.Approach._to._.Control-.Flow.Analysis.Logical._.Methods._in._.Computer._.Science2011)"></a><span class="Autobibentry">Vardoulakis, Dimitrios and Shivers, Olin. CFA2: a Context-FreeApproach to Control-FlowAnalysis. <span style="font-style: italic">Logical Methods in Computer Science</span>, 2011.</span></p></td></tr><tr><td><p><a name="(autobib._.Christopher._.Earl.Introspective._.Pushdown._.Analysis._and._.Nebo.University._of._.Utah2014)"></a><span class="Autobibentry">Christopher Earl. Introspective Pushdown Analysis and Nebo. University of Utah, 2014.</span></p></td></tr><tr><td><p><a name="(autobib._.Moggi,._.Eugenio.An._.Abstract._.View._of._.Programming._.Languages.Edinburgh._.University1989)"></a><span class="Autobibentry">Moggi, Eugenio. An Abstract View of Programming Languages. Edinburgh University, 1989.</span></p></td></tr><tr><td><p><a name="(autobib._.Janssens,._.Gerda._and._.Sagonas,._.Konstantinos._.F.On._the._.Use._of._.Tabling._for._.Abstract._.Interpretation~3a._.An._.Experiment._with._.Abstract._.Equation._.Systems...In._.Proc..._.T.A.P.D1998)"></a><span class="Autobibentry">Janssens, Gerda and Sagonas, Konstantinos F. On the Use of Tabling for Abstract Interpretation: An Experiment with Abstract Equation Systems. In <span style="font-style: italic">Proc. TAPD</span>, 1998.</span></p></td></tr><tr><td><p><a name="(autobib._.Morrisett,._.Greg,._.Felleisen,._.Matthias,._and._.Harper,._.Robert.Abstract._.Models._of._.Memory._.Management.In._.Proc..._.Proceedings._of._the._.Seventh._.International._.Conference._on._.Functional._.Programming._.Languages._and._.Computer._.Architecture1995)"></a><span class="Autobibentry">Morrisett, Greg, Felleisen, Matthias, and Harper, Robert. Abstract Models of Memory Management. In <span style="font-style: italic">Proc. Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture</span>, 1995.</span></p></td></tr><tr><td><p><a name="(autobib._.Tamaki,._.Hisao._and._.Sato,._.Taisuke.O.L.D._resolution._with._tabulation.In._.Proc..._.International._.Conference._on._.Logic._.Programming1986)"></a><span class="Autobibentry">Tamaki, Hisao and Sato, Taisuke. OLD resolution with tabulation. In <span style="font-style: italic">Proc. International Conference on Logic Programming</span>, 1986.</span></p></td></tr><tr><td><p><a name="(autobib._.Johnson,._.J..._.Ian,._.Sergey,._.Ilya,._.Earl,._.Christopher,._.Might,._.Matthew,._and._.Van._.Horn,._.David.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming2014)"></a><span class="Autobibentry">Johnson, J. Ian, Sergey, Ilya, Earl, Christopher, Might, Matthew, and Van Horn, David. Pushdown flow analysis with abstract garbage collection. <span style="font-style: italic">Journal of Functional Programming</span>, 2014.</span></p></td></tr><tr><td><p><a name="(autobib._.Sergey,._.Ilya,._.Devriese,._.Dominique,._.Might,._.Matthew,._.Midtgaard,._.Jan,._.Darais,._.David,._.Clarke,._.Dave,._and._.Piessens,._.Frank.Monadic._.Abstract._.Interpreters.In._.Proc..._.Proceedings._of._the._34th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2013)"></a><span class="Autobibentry">Sergey, Ilya, Devriese, Dominique, Might, Matthew, Midtgaard, Jan, Darais, David, Clarke, Dave, and Piessens, Frank. Monadic Abstract Interpreters. In <span style="font-style: italic">Proc. Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</span>, 2013.</span></p></td></tr><tr><td><p><a name="(autobib._.Johnson,._.J..~7e.Ian._and._.Van._.Horn,._.David.Abstracting._.Abstract._.Control.In._.Proc..._.Proceedings._of._the._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014)"></a><span class="Autobibentry">Johnson, J.~Ian and Van Horn, David. Abstracting Abstract Control. In <span style="font-style: italic">Proc. Proceedings of the 10th ACM Symposium on Dynamic Languages</span>, 2014.</span></p></td></tr><tr><td><p><a name="(autobib._.Midtgaard,._.Jan.Control-flow._.Analysis._of._.Functional._.Programs.A.C.M._.Comput..._.Surv..2012)"></a><span class="Autobibentry">Midtgaard, Jan. Control-flow Analysis of Functional Programs. <span style="font-style: italic">ACM Comput. Surv.</span>, 2012.</span></p></td></tr><tr><td><p><a name="(autobib._.Midtgaard,._.Jan._and._.Jensen,._.Thomas._.P...Control-flow._.Analysis._of._.Function._.Calls._and._.Returns._by._.Abstract._.Interpretation.In._.Proc..._.I.C.F.P._'09~3a._.Proceedings._of._the._14th._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2009)"></a><span class="Autobibentry">Midtgaard, Jan and Jensen, Thomas P. Control-flow Analysis of Function Calls and Returns by Abstract Interpretation. In <span style="font-style: italic">Proc. ICFP &rsquo;09: Proceedings of the 14th ACM SIGPLAN International Conference on Functional Programming</span>, 2009.</span></p></td></tr><tr><td><p><a name="(autobib._.Midtgaard,._.Jan._and._.Jensen,._.Thomas.A._.Calculational._.Approach._to._.Control-.Flow.Analysis._by._.Abstract._.Interpretation.In._.Proc..._.Static._.Analysis._.Symposium2008)"></a><span class="Autobibentry">Midtgaard, Jan and Jensen, Thomas. A Calculational Approach to Control-FlowAnalysis by Abstract Interpretation. In <span style="font-style: italic">Proc. Static Analysis Symposium</span>, 2008.</span></p></td></tr><tr><td><p><a name="(autobib._.Jaskelioff,._.Mauro._.Javier.Lifting._of._operations._in._modular._monadic._semantics.University._of._.Nottingham2009)"></a><span class="Autobibentry">Jaskelioff, Mauro Javier. Lifting of operations in modular monadic semantics. University of Nottingham, 2009.</span></p></td></tr><tr><td><p><a name="(autobib._.Wright,._.Andrew._.K..._and._.Jagannathan,._.Suresh.Polymorphic._splitting~3a._an._effective._polyvariant._flow._analysis.A.C.M._.Trans..._.Program..._.Lang..._.Syst..1998)"></a><span class="Autobibentry">Wright, Andrew K. and Jagannathan, Suresh. Polymorphic splitting: an effective polyvariant flow analysis. <span style="font-style: italic">ACM Trans. Program. Lang. Syst.</span>, 1998.</span></p></td></tr><tr><td><p><a name="(autobib._.Steele,.Jr..,._.Guy._.L...Building._.Interpreters._by._.Composing._.Monads.In._.Proc..._.Proceedings._of._the._21st._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1994)"></a><span class="Autobibentry">Steele,Jr., Guy L. Building Interpreters by Composing Monads. In <span style="font-style: italic">Proc. Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 1994.</span></p></td></tr><tr><td><p><a name="(autobib._.Flatt,._.Matthew._and._.Felleisen,._.Matthias.Units~3a._.Cool._.Modules._for._.H.O.T._.Languages.In._.Proc..._.Proceedings._of._the._.A.C.M._.S.I.G.P.L.A.N._1998._.Conference._on._.Programming._.Language._.Design._and._.Implementation1998)"></a><span class="Autobibentry">Flatt, Matthew and Felleisen, Matthias. Units: Cool Modules for HOT Languages. In <span style="font-style: italic">Proc. Proceedings of the ACM SIGPLAN 1998 Conference on Programming Language Design and Implementation</span>, 1998.</span></p></td></tr><tr><td><p><a name="(autobib._.Flatt,._.Matthew._and._.P.L.T.Reference~3a._.Racket.P.L.T._.Inc..2010)"></a><span class="Autobibentry">Flatt, Matthew and PLT. Reference: Racket. PLT Inc., 2010.</span></p></td></tr><tr><td><p><a name="(autobib._.Might,._.Matthew.Environment._analysis._of._higher-order._languages.Georgia._.Institute._of._.Technology2007)"></a><span class="Autobibentry">Might, Matthew. Environment analysis of higher-order languages. Georgia Institute of Technology, 2007a.</span></p></td></tr><tr><td><p><a name="(autobib._.Might,._.Matthew.Logic-flow._.Analysis._of._.Higher-order._.Programs.In._.Proc..._.Proceedings._of._the._34th._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2007)"></a><span class="Autobibentry">Might, Matthew. Logic-flow Analysis of Higher-order Programs. In <span style="font-style: italic">Proc. Proceedings of the 34th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 2007b.</span></p></td></tr><tr><td><p><a name="(autobib._.Might,._.Matthew._and._.Van._.Horn,._.David.A._.Family._of._.Abstract._.Interpretations._for._.Static._.Analysis._of._.Concurrent._.Higher-.Order.Programs.In._.Proc..._.Static._.Analysis2011)"></a><span class="Autobibentry">Might, Matthew and Van Horn, David. A Family of Abstract Interpretations for Static Analysis of Concurrent Higher-OrderPrograms. In <span style="font-style: italic">Proc. Static Analysis</span>, 2011.</span></p></td></tr><tr><td><p><a name="(autobib._.Might,._.Matthew._and._.Shivers,._.Olin.Environment._analysis._via._~5c(~5c.Delta~5c)-.C.F.A.In._.Proc..._.P.O.P.L._'06~3a._.Conference._record._of._the._33rd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2006)"></a><span class="Autobibentry">Might, Matthew and Shivers, Olin. Environment analysis via \(\Delta\)-CFA. In <span style="font-style: italic">Proc. POPL &rsquo;06: Conference record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 2006a.</span></p></td></tr><tr><td><p><a name="(autobib._.Might,._.Matthew._and._.Shivers,._.Olin.Improving._.Flow._.Analyses._via._~5c(~5c.Gamma~5c).C.F.A~3a._.Abstract._.Garbage._.Collection._and._.Counting.In._.Proc..._.I.C.F.P'062006)"></a><span class="Autobibentry">Might, Matthew and Shivers, Olin. Improving Flow Analyses via \(\Gamma\)CFA: Abstract Garbage Collection and Counting. In <span style="font-style: italic">Proc. ICFP&rsquo;06</span>, 2006b.</span></p></td></tr><tr><td><p><a name="(autobib._.Bol,._.Roland._.N._and._.Degerstedt,._.Lars.Tabulated._.Resolution._for._.Well._.Founded._.Semantics...In._.Proc..._.I.L.P.S1993)"></a><span class="Autobibentry">Bol, Roland N and Degerstedt, Lars. Tabulated Resolution for Well Founded Semantics. In <span style="font-style: italic">Proc. ILPS</span>, 1993.</span></p></td></tr><tr><td><p><a name="(autobib._.Kiselyov,._.Oleg.Typed._tagless._final._interpreters.In._.Proc..._.Generic._and._.Indexed._.Programming2012)"></a><span class="Autobibentry">Kiselyov, Oleg. Typed tagless final interpreters. In <span style="font-style: italic">Proc. Generic and Indexed Programming</span>, 2012.</span></p></td></tr><tr><td><p><a name="(autobib._.Kiselyov,._.Oleg,._.Shan,._.Chung-chieh,._.Friedman,._.Daniel._.P..,._and._.Sabry,._.Amr.Backtracking,._.Interleaving,._and._.Terminating._.Monad._.Transformers~3a._(.Functional._.Pearl).In._.Proc..._.Proceedings._of._the._.Tenth._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2005)"></a><span class="Autobibentry">Kiselyov, Oleg, Shan, Chung-chieh, Friedman, Daniel P., and Sabry, Amr. Backtracking, Interleaving, and Terminating Monad Transformers: (Functional Pearl). In <span style="font-style: italic">Proc. Proceedings of the Tenth ACM SIGPLAN International Conference on Functional Programming</span>, 2005.</span></p></td></tr><tr><td><p><a name="(autobib._.Shivers,._.Olin.Control-flow._analysis._of._higher-order._languages.Carnegie._.Mellon._.University1991)"></a><span class="Autobibentry">Shivers, Olin. Control-flow analysis of higher-order languages. Carnegie Mellon University, 1991.</span></p></td></tr><tr><td><p><a name="(autobib._.Hinze,._.Ralf.Deriving._.Backtracking._.Monad._.Transformers.In._.Proc..._.Proceedings._of._the._.Fifth._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2000)"></a><span class="Autobibentry">Hinze, Ralf. Deriving Backtracking Monad Transformers. In <span style="font-style: italic">Proc. Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</span>, 2000.</span></p></td></tr><tr><td><p><a name="(autobib._.Gl~c3~bcck,._.Robert.Simulation._of._.Two-.Way._.Pushdown._.Automata._.Revisited.In._.Proc..._.Semantics,._.Abstract._.Interpretation,._and._.Reasoning._about._.Programs~3a._.Essays._.Dedicated._to._.David._.A..._.Schmidt._on._the._.Occasion._of._his._.Sixtieth._.Birthday,~0a._._._._._._._._._._._._._._._.Manhattan,._.Kansas,._.U.S.A,._19-20th._.September._20132013)"></a><span class="Autobibentry">Gl&#252;ck, Robert. Simulation of Two-Way Pushdown Automata Revisited. In <span style="font-style: italic">Proc. Semantics, Abstract Interpretation, and Reasoning about Programs: Essays Dedicated to David A. Schmidt on the Occasion of his Sixtieth Birthday,
               Manhattan, Kansas, USA, 19-20th September 2013</span>, 2013.</span></p></td></tr><tr><td><p><a name="(autobib._.Ager,._.Mads._.S..,._.Danvy,._.Olivier,._and._.Midtgaard,._.Jan.A._functional._correspondence._between._monadic._evaluators._and._abstract._machines._for._languages._with._computational._effects.Theoretical._.Computer._.Science2005)"></a><span class="Autobibentry">Ager, Mads S., Danvy, Olivier, and Midtgaard, Jan. A functional correspondence between monadic evaluators and abstract machines for languages with computational effects. <span style="font-style: italic">Theoretical Computer Science</span>, 2005.</span></p></td></tr><tr><td><p><a name="(autobib._.Tobin-.Hochstadt,._.Sam._and._.Van._.Horn,._.David.Higher-order._symbolic._execution._via._contracts.In._.Proc..._.Proceedings._of._the._.A.C.M._.International._.Conference._on._.Object._.Oriented._.Programming._.Systems._.Languages._and._.Applications2012)"></a><span class="Autobibentry">Tobin-Hochstadt, Sam and Van Horn, David. Higher-order symbolic execution via contracts. In <span style="font-style: italic">Proc. Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications</span>, 2012.</span></p></td></tr><tr><td><p><a name="(autobib._.Tobin-.Hochstadt,._.Sam,._.St-.Amour,._.Vincent,._.Culpepper,._.Ryan,._.Flatt,._.Matthew,._and._.Felleisen,._.Matthias.Languages._.As._.Libraries.In._.Proc..._.Proceedings._of._the._32nd._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2011)"></a><span class="Autobibentry">Tobin-Hochstadt, Sam, St-Amour, Vincent, Culpepper, Ryan, Flatt, Matthew, and Felleisen, Matthias. Languages As Libraries. In <span style="font-style: italic">Proc. Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation</span>, 2011.</span></p></td></tr><tr><td><p><a name="(autobib._.Fischer,._.Sebastian,._.Kiselyov,._.Oleg,._and._.Shan,._.Chung-chieh.Purely._functional._lazy._nondeterministic._programming.Journal._of._.Functional._.Programming._21(4-5),._pp..._413--4652011)"></a><span class="Autobibentry">Fischer, Sebastian, Kiselyov, Oleg, and Shan, Chung-chieh. Purely functional lazy nondeterministic programming. <span style="font-style: italic">Journal of Functional Programming</span> 21(4-5), pp. 413&ndash;465, 2011.</span></p></td></tr><tr><td><p><a name="(autobib._.Liang,._.Sheng,._.Hudak,._.Paul,._and._.Jones,._.Mark.Monad._.Transformers._and._.Modular._.Interpreters.In._.Proc..._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995)"></a><span class="Autobibentry">Liang, Sheng, Hudak, Paul, and Jones, Mark. Monad Transformers and Modular Interpreters. In <span style="font-style: italic">Proc. Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 1995.</span></p></td></tr><tr><td><p><a name="(autobib._.Dawson,._.Steven,._.Ramakrishnan,._.C..._.R..,._and._.Warren,._.David._.S...Practical._.Program._.Analysis._.Using._.General._.Purpose._.Logic._.Programming._.Systems---a._.Case._.Study.In._.Proc..._.Proceedings._of._the._.A.C.M._.S.I.G.P.L.A.N._1996._.Conference._on._.Programming._.Language._.Design._and._.Implementation1996http~3a//doi..acm..org/10..1145/231379..231399)"></a><span class="Autobibentry">Dawson, Steven, Ramakrishnan, C. R., and Warren, David S. Practical Program Analysis Using General Purpose Logic Programming Systems&#8212;<wbr></wbr>a Case Study. In <span style="font-style: italic">Proc. Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation</span>, 1996. <a href="http://doi.acm.org/10.1145/231379.231399"><span class="url">http://doi.acm.org/10.1145/231379.231399</span></a></span></p></td></tr><tr><td><p><a name="(autobib._.Jagannathan,._.Suresh,._.Thiemann,._.Peter,._.Weeks,._.Stephen,._and._.Wright,._.Andrew.Single._and._loving._it~3a._must-alias._analysis._for._higher-order._languages.In._.Proc..._.P.O.P.L._'98~3a._.Proceedings._of._the._25th._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1998)"></a><span class="Autobibentry">Jagannathan, Suresh, Thiemann, Peter, Weeks, Stephen, and Wright, Andrew. Single and loving it: must-alias analysis for higher-order languages. In <span style="font-style: italic">Proc. POPL &rsquo;98: Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 1998.</span></p></td></tr><tr><td><p><a name="(autobib._.Jagannathan,._.Suresh._and._.Weeks,._.Stephen.A._unified._treatment._of._flow._analysis._in._higher-order._languages.In._.Proc..._.P.O.P.L._'95~3a._.Proceedings._of._the._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995)"></a><span class="Autobibentry">Jagannathan, Suresh and Weeks, Stephen. A unified treatment of flow analysis in higher-order languages. In <span style="font-style: italic">Proc. POPL &rsquo;95: Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 1995.</span></p></td></tr><tr><td><p><a name="(autobib._.Swift,._.Terrance._and._.Warren,._.David._.S.X.S.B~3a._.Extending._.Prolog._with._tabled._logic._programming.Theory._and._.Practice._of._.Logic._.Programming._12(1-2),._pp..._157--1872012)"></a><span class="Autobibentry">Swift, Terrance and Warren, David S. XSB: Extending Prolog with tabled logic programming. <span style="font-style: italic">Theory and Practice of Logic Programming</span> 12(1-2), pp. 157&ndash;187, 2012.</span></p></td></tr><tr><td><p><a name="(autobib._.Gilray,._.Thomas,._.Lyde,._.Steven,._.Adams,._.Michael._.D..,._.Might,._.Matthew,._and._.Van._.Horn,._.David.Pushdown._.Control-flow._.Analysis._for._.Free.In._.Proc..._.Proceedings._of._the._43rd._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2016)"></a><span class="Autobibentry">Gilray, Thomas, Lyde, Steven, Adams, Michael D., Might, Matthew, and Van Horn, David. Pushdown Control-flow Analysis for Free. In <span style="font-style: italic">Proc. Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 2016.</span></p></td></tr><tr><td><p><a name="(autobib._.Dimitrios._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Northeastern._.University2012)"></a><span class="Autobibentry">Dimitrios Vardoulakis. CFA2: Pushdown Flow Analysis for Higher-Order Languages. Northeastern University, 2012.</span></p></td></tr><tr><td><p><a name="(autobib._.Chen,._.Weidong._and._.Warren,._.David._.S.Tabled._evaluation._with._delaying._for._general._logic._programs.Journal._of._the._.A.C.M._(.J.A.C.M)._43(1),._pp..._20--741996)"></a><span class="Autobibentry">Chen, Weidong and Warren, David S. Tabled evaluation with delaying for general logic programs. <span style="font-style: italic">Journal of the ACM (JACM)</span> 43(1), pp. 20&ndash;74, 1996.</span></p></td></tr></table></p></div></div><div id="contextindicator">&nbsp;</div></body></html>