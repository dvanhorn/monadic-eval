<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>Abstracting Definitional Interpreters </title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="sigplan.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="figure.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="autobib.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="figure.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html" class="tocviewselflink" data-pltdoc="x">Abstracting Definitional Interpreters </a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._.Introduction%29" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._.From_.Machines_to_.Compositional_.Evaluators%29" class="tocviewlink" data-pltdoc="x">From Machines to Compositional Evaluators</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._.A_.Definitional_.Interpreter%29" class="tocviewlink" data-pltdoc="x">A Definitional Interpreter</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._closures%29" class="tocviewlink" data-pltdoc="x">Abstracting Closures</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._cache%29" class="tocviewlink" data-pltdoc="x">Detecting Cycles with a Cache</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._fixing-cache%29" class="tocviewlink" data-pltdoc="x">Fixing the Cache</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._.Pushdown___la_.Reynolds%29" class="tocviewlink" data-pltdoc="x">Pushdown <span style="font-style: italic">&#224; la</span> Reynolds</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._.Widening_the_.Store%29" class="tocviewlink" data-pltdoc="x">Widening the Store</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._.An_.Alternative_.Abstraction%29" class="tocviewlink" data-pltdoc="x">An Alternative Abstraction</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._symbolic%29" class="tocviewlink" data-pltdoc="x">Symbolic Execution and Path-<wbr></wbr>Sensitive Verification</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._.Try_.It_.Out%29" class="tocviewlink" data-pltdoc="x">Try It Out</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._.Related_.Work%29" class="tocviewlink" data-pltdoc="x">Related Work</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._.Conclusions%29" class="tocviewlink" data-pltdoc="x">Conclusions</a></td></tr><tr><td align="right"></td><td><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._doc-bibliography%29" class="tocviewlink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Abstracting_.Definitional_.Interpreters_.Functional_.Pearl%29" class="tocsubseclink" data-pltdoc="x">Abstracting Definitional Interpreters </a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Introduction%29" class="tocsubseclink" data-pltdoc="x">Introduction</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.From_.Machines_to_.Compositional_.Evaluators%29" class="tocsubseclink" data-pltdoc="x">From Machines to Compositional Evaluators</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.A_.Definitional_.Interpreter%29" class="tocsubseclink" data-pltdoc="x">A Definitional Interpreter</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._collecting%29" class="tocsubseclink" data-pltdoc="x">Collecting Variations</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._base%29" class="tocsubseclink" data-pltdoc="x">Abstracting Base Values</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._closures%29" class="tocsubseclink" data-pltdoc="x">Abstracting Closures</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._cache%29" class="tocsubseclink" data-pltdoc="x">Detecting Cycles with a Cache</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._fixing-cache%29" class="tocsubseclink" data-pltdoc="x">Fixing the Cache</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Pushdown___la_.Reynolds%29" class="tocsubseclink" data-pltdoc="x">Pushdown <span style="font-style: italic">&#224; la</span> Reynolds</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#%28part._.Widening_the_.Store%29" class="tocsubseclink" data-pltdoc="x">Widening the Store</a></td></tr><tr><td><span class="tocsublinknumber">9<tt>&nbsp;</tt></span><a href="#%28part._.An_.Alternative_.Abstraction%29" class="tocsubseclink" data-pltdoc="x">An Alternative Abstraction</a></td></tr><tr><td><span class="tocsublinknumber">10<tt>&nbsp;</tt></span><a href="#%28part._symbolic%29" class="tocsubseclink" data-pltdoc="x">Symbolic Execution and Path-<wbr></wbr>Sensitive Verification</a></td></tr><tr><td><span class="tocsublinknumber">10.1<tt>&nbsp;</tt></span><a href="#%28part._.Symbolic_.Execution%29" class="tocsubseclink" data-pltdoc="x">Symbolic Execution</a></td></tr><tr><td><span class="tocsublinknumber">10.2<tt>&nbsp;</tt></span><a href="#%28part._.From_.Symbolic_.Execution_to_.Verification%29" class="tocsubseclink" data-pltdoc="x">From Symbolic Execution to Verification</a></td></tr><tr><td><span class="tocsublinknumber">11<tt>&nbsp;</tt></span><a href="#%28part._.Try_.It_.Out%29" class="tocsubseclink" data-pltdoc="x">Try It Out</a></td></tr><tr><td><span class="tocsublinknumber">12<tt>&nbsp;</tt></span><a href="#%28part._.Related_.Work%29" class="tocsubseclink" data-pltdoc="x">Related Work</a></td></tr><tr><td><span class="tocsublinknumber">13<tt>&nbsp;</tt></span><a href="#%28part._.Conclusions%29" class="tocsubseclink" data-pltdoc="x">Conclusions</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._doc-bibliography%29" class="tocsubseclink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Abstracting_.Definitional_.Interpreters_.Functional_.Pearl)"></a>Abstracting Definitional Interpreters <span class="SSubtitle">Functional Pearl</span></h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author"><span class="SAuthorinfo">David Darais<span class="SAuthorPlace">University of Maryland</span><span class="SAuthorEmail">darais@cs.umd.edu</span></span></p><span class="SAuthorSep"><br/></span><p class="author"><span class="SAuthorinfo">Nicholas Labich<span class="SAuthorPlace">University of Maryland</span><span class="SAuthorEmail">labichn@cs.umd.edu</span></span></p><span class="SAuthorSep"><br/></span><p class="author"><span class="SAuthorinfo">Ph&#250;c C. Nguy&#7877;n<span class="SAuthorPlace">University of Maryland</span><span class="SAuthorEmail">pcn@cs.umd.edu</span></span></p><span class="SAuthorSep"><br/></span><p class="author"><span class="SAuthorinfo">David Van Horn<span class="SAuthorPlace">University of Maryland</span><span class="SAuthorEmail">dvanhorn@cs.umd.edu</span></span></p></span></div><p><div class="SIntrapara"></div><div class="SIntrapara"></div><div class="SIntrapara"></div><div class="SIntrapara"></div></p><blockquote class="abstract"><p>In this paper, we show that a definitional interpreter
written in monadic style can express not only the usual notion of
interpretation, but also a wide variety of collecting semantics,
abstract interpretations, symbolic execution, and their intermixings.
We give a rational reconstruction of a definitional <span style="font-style: italic">abstract</span>
interpreter for a higher-order language by building a series of
components implementing monadic operations.  The denouement of our
story is a computable abstract interpreter that arises from the
composition of simple, independent components.  Remarkably, this
interpreter implements a form of pushdown control flow analysis
(PDCFA) in which calls and returns are always properly matched in the
abstract semantics.  True to the definitional style of Reynolds, the
evaluator involves no explicit mechanics to achieve this property; it
is simply inherited from the defining language.</p></blockquote><p><span class="SKeywords">definitional interpreters, abstract interpretation, pushdown
control flow analysis, symbolic execution</span></p><h3>1<tt>&nbsp;</tt><a name="(part._.Introduction)"></a>Introduction</h3><p>In his landmark paper, <span style="font-style: italic">Definitional interpreters for
higher-order languages</span>&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.John._.Reynolds.Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._.Annual._.Conference1972%29" data-pltdoc="x">16</a>], Reynolds first observed
that when a language is defined by way of an interpreter, it is
possible for the defined language to inherit semantic characteristics
of the defining language of the interpreter.  For example, it is easy
to write a compositional evaluator that defines a call-by-value
language if the defining language is call-by-value, but defines a
call-by-name language if the defining language is call-by-name.</p><p>In this paper, we make the following two observations:</p><ol><li><p>Definitional interpreters, written in monadic style,
can simultaneously define a language&rsquo;s semantics as well as
safe approximations of those semantics.</p></li><li><p>These definitional <span style="font-style: italic">abstract</span> interpreters can inherit
characteristics of the defining language.  In particular, we show that
the abstract interpreter inherits the call and return matching
property of the defining language and therefore realizes an abstract
intpretation in the pushown style of analyses&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Christopher._.Earl%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Pushdown._.Control-.Flow._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">3</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Dimitris._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Ph.D._dissertation%2C._.Northeastern._.University2012%29" data-pltdoc="x">24</a>].</p></li></ol><p>A common problem of past approaches to the control flow analysis of
functional languages is the inability to properly match a function
call with its return in the abstract semantics, leading to infeasible
program (abstract) executions in which a call is made from one point
in the program, but control returns to another.  The CFA2 analysis of
Vardoulakis and Shivers&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Dimitris._.Vardoulakis._and._.Olin._.Shivers.C.F.A2~3a._a._.Context-.Free._.Approach._to._.Control-.Flow._.Analysis.Logical._.Methods._in._.Computer._.Science._7%282~3a3%292011%29" data-pltdoc="x">25</a>] was the first approach that
overcame this shortcoming.  In essence, this kind of analysis can be
viewed as replacing the traditional finite automata abstractions of
programs with pushdown automata&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Christopher._.Earl%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Pushdown._.Control-.Flow._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">3</a>].</p><p>In this paper we investigate the use of definitional interpreters as
the basis for abstract interpretation of higher-order languages.  We
show that a definitional interpreter&#8212;<wbr></wbr>a compositional evaluation
function&#8212;<wbr></wbr>written in a monadic and componential style can express a
wide variety of concrete and abstract interpretations.</p><h3>2<tt>&nbsp;</tt><a name="(part._.From_.Machines_to_.Compositional_.Evaluators)"></a>From Machines to Compositional Evaluators</h3><p>In recent years, there has been considerable effort in the systematic
construction of abstract interpreters for higher-order languages using
abstract machines&#8212;<wbr></wbr>first-order transition systems&#8212;<wbr></wbr>as a semantic
basis.  The so-called <span style="font-style: italic">abstracting abstract machines</span> (AAM)
approach to abstract interpretation&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.David._.Van._.Horn._and._.Matthew._.Might.Abstracting._.Abstract._.Machines.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">22</a>] is a recipe for
transforming a machine semantics into an easily abstractable form.
There are a few essential elements to the transformation:</p><ul><li><p>allocating continuations in the store</p></li><li><p>allocated variable bindings in the store</p></li><li><p>using a store that maps addresses to <span style="font-style: italic">sets</span> of values</p></li><li><p>interpreting store updates as a join</p></li><li><p>interpreting store dereference as a non-deterministic choice</p></li></ul><p>These transformations are semantics-preserving as the original and
derived machines operate in a lock-step correspondence.  But the real
value of the derived semantics stems from the fact that it&rsquo;s possible
to turn the derived machine into an abstract interpreter with two
simple steps:</p><ul><li><p>bounding store allocation to a finite set of addresses</p></li><li><p>widening base values to some abstract domain</p></li></ul><p>Moreover, the soundness of the resulting abstraction is self-evident
and easily proved.</p><p>The AAM approach has been applied to a wide variety of languages and
applications, and given the success of the AAM approach, it&rsquo;s natural
to wonder what is essential about the low-level machine basis of the
semantics and whether a similar approach is possible with a
higher-level formulation of the semantics such as a compositional
evaluation function.</p><p>This paper shows that the essence of the AAM approach can be put on a
high-level semantic basis.  We show that compositional evaluators,
written in monadic style can express similar abstractions to that of
AAM.  Moreover, we show that the high-level semantics offers a number
of benefits not available to the machine model.</p><p>First, as we will see, the definitional interpreter approach is not
formulated as a transformation on the semantics itself, but rather
uses alternative notions of a monad to express the &ldquo;abstracting&rdquo;
transformations.  This means the concrete and abstract interpreters
for a language can share large parts of their implementation; there is
just one interpreter with a multiplicity of interpretations.}</p><p>Second, there is a rich body of work and many tools and techniques for
constructing <span style="font-style: italic">extensible</span> interpreters, all of which applies to
high-level semantics, not machines.  By putting abstract
interpretation for higher-order languages on a high-level semantic
basis, we can bring these results to bear on the construction of
extensible abstract interpreters.  In particular, we use <span style="font-style: italic">monad
transformers</span> to build re-usable components for mixing and matching
the constiuent parts of an abstract interpreter.</p><p>Finally, using definitional interpreters for abstract interpretation
satisfies an intellectual itch that asks whether it can be done at
all.  In solving this technical challenge, we discover a pleasant
surprise about the definitional interpreter approach: it is inherently
&ldquo;pushdown.&rdquo;  Under the interpreter approach, the property follows
for free as a gift from the metalanguage.</p><h3>3<tt>&nbsp;</tt><a name="(part._.A_.Definitional_.Interpreter)"></a>A Definitional Interpreter</h3><p>We begin by first constructing a definitional interpreter for a small
but representative higher-order, functional language.  As our defining
language, we use an applicative subset of Racket, a dialect of
Scheme.<span class="NoteBox"><span class="NoteContent">This choice is largely immaterial: any functional
language would do.</span></span></p><p>The abstract syntax of the language is defined in <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._syntax%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">1</span></a>;
it includes variables, numbers, unary and binary operations on
numbers, conditionals, <span class="stt">letrec</span> expressions, functions, and
applications.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">vbl</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">X</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Variable</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">num</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Number</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Number</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">lam</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">X</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Lambda</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">ifz</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Conditional</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">op1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">O1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Unary</span><span class="hspace">&nbsp;</span><span class="RktCmt">primitive</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">op2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">O2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Binary</span><span class="hspace">&nbsp;</span><span class="RktCmt">primitive</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">app</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Application</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">lrc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">X</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Letrec</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">X</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Symbol</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Variable</span><span class="hspace">&nbsp;</span><span class="RktCmt">name</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">O1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">add1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Unary</span><span class="hspace">&nbsp;</span><span class="RktCmt">operator</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">O2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="nobreak">-</span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Binary</span><span class="hspace">&nbsp;</span><span class="RktCmt">operator</span><span class="RktMeta"></span></td></tr></table></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._syntax))" x-target-lift="Figure"></a>Figure&nbsp;1: </span>Syntax</span></p></blockquote><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">vbl</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">find</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">ifz</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">op1</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">&#948;</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">op2</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">&#948;</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">lrc</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">alloc</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#961;&#8242;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;&#8242;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">local-env</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;&#8242;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">lam</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lam</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">app</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lam</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">alloc</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">local-env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._pcf-eval))" x-target-lift="Figure"></a>Figure&nbsp;2: </span>Definitional interpreter</span></p></blockquote><p><div class="SIntrapara">The interpreter for the language is defined in <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._pcf-eval%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">2</span></a>.
At first glance, it has many conventional aspects:
</div><div class="SIntrapara"><ul><li><p>it is compositionally defined by structural recursion on the syntax
of expressions,</p></li><li><p>it represents functions with a closure data structure that pairs
together the code with the environment in which a function
definition was evaluated,</p></li><li><p>it is structured monadically and uses monad operations to interact
with the environment and store,</p></li><li><p>it relies on a helper function <span class="RktVar">&#948;</span> to interpret primitive operations.</p></li></ul></div></p><p><div class="SIntrapara">There are a few superficial aspects that deserve a quick note:
environments <span class="RktSym">&#961;</span> are finite maps and <span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span> denotes
<span style="font-style: italic">&#961;</span>(<span style="font-style: italic">x</span>)<span style="font-style: italic"></span> while <span class="RktPn">(</span><span class="RktSym">&#961;</span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">)</span> denotes <span style="font-style: italic">&#961;</span>[<span style="font-style: italic">x&#8614;a</span>]<span style="font-style: italic"></span>.  The
<span class="RktSym">do</span>-notation is just shorthand for <span class="RktVar">bind</span>, as usual:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8801;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">bind</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8801;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8801;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">bind</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">_</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8801;</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span></td></tr></table></blockquote></div></p><p>Finally, there are two unconvential aspects worth noting.  First, the
interpreter is written in an <span style="font-style: italic">open recursive style</span>; the
evaluator does not call itself recursively, instead it takes as an
argument a function <span class="RktSym">ev</span> which it calls in order to recur.  (We
have employed a bit of cuteness by naming the first parameter
<span class="RktSym">ev</span>, thereby shadowing the outer <span class="RktSym">ev</span> and making
subsequent calls look like recursive calls.)  This is a standard
encoding for recursive functions in a setting without recursive
binding.  It is up to an external function, such as the Y-combinator,
to close the recursive loop.  As we will see, this open recursive form
will be crucial for interposition to collect information about the
intensional properties of evaluation.</p><p><div class="SIntrapara">Second, the code is clearly <span style="font-style: italic">incomplete</span>.  There are a number
of free variables, noted in italics.  These free variables fall into
a few roles:
</div><div class="SIntrapara"><ul><li><p>providing the underlying monad of the interpreter:
<span class="RktVar">return</span> and <span class="RktVar">bind</span>,</p></li><li><p>providing an interpretation of primitives: <span class="RktVar">&#948;</span> and
<span class="RktVar">zero?</span>,</p></li><li><p>providing environment operations: <span class="RktVar">ask-env</span> for
retreiving the environment and <span class="RktVar">local-env</span> for installing an
environment,</p></li><li><p>providing store operations: <span class="RktVar">ext</span> for updating
the store, and <span class="RktVar">find</span> for dereferencing locations, and</p></li><li><p>a remaining operation for <span class="RktVar">alloc</span>ating store locations,
used to bind variables.</p></li></ul></div></p><p>Going forward, we make frequent use of sets of definitions involving
free variables, so we call such a collection a <span style="font-style: italic">component</span>. We
assume components can be named (in this case, we&rsquo;ve named the
component <span class="RktSym">ev@</span>, indicated by the box in the upper-right
corner) and linked together to eliminate free variables.<span class="NoteBox"><span class="NoteContent">We use
Racket <span style="font-style: italic">units</span>&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Matthew._.Flatt._and._.Matthias._.Felleisen.Units~3a._.Cool._.Modules._for._.H.O.T._.Languages.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._1998._.Conference._on._.Programming._.Language._.Design._and._.Implementation1998%29" data-pltdoc="x">5</a>] to model components in our
implementation.</span></span></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">monad@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">&#948;@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">ovs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">ovs</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">add1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">sub1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sub1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">+</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">*</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVar">fail</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">store@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">find</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">update-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">alloc@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">alloc</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._concrete-components))" x-target-lift="Figure"></a>Figure&nbsp;3: </span>Components for definitional interpreter</span></p></blockquote><p>Let us now examine a set of components for completing the definitional
interpreter.  <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._concrete-components%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">3</span></a> gives the definition
for a series of components that complete the interpreter.  The first
and most magical component is <span class="RktSym">monad@</span>, which uses our
<span class="RktSym">define-monad</span> macro to generate a set of bindings based on a
monad transformer stack.  For this interpreter, we use a failure monad
to model divide-by-zero errors, a state monad to model the store, and
a reader monad to model the environment.  The <span class="RktSym">define-monad</span>
form generates bindings for <span class="RktSym">return</span>, <span class="RktSym">bind</span>,
<span class="RktSym">ask-env</span>, <span class="RktSym">local-env</span>, <span class="RktSym">get-store</span> and
<span class="RktSym">update-store</span>.</p><p><div class="SIntrapara">We also add a <span class="RktSym">mrun</span> operation for running computations, which
kicks off the computation by providing the empty environment and
store:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-StateT</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-ReaderT</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>While the <span class="RktSym">define-monad</span> form is hiding some details, this
component could have equivalently been written out explicitly. For
example, <span class="RktSym">return</span> and <span class="RktSym">bind</span> can be defined as:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">bind</span><span class="hspace">&nbsp;</span><span class="RktSym">ma</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ma</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">s&#8242;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">s&#8242;</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">failure</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">failure</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">And the remaining operations are straightforward, too.  So the use of
monad transformers can be seen as a mere convenience, but as we will
see moving to more and more involved monad stacks, it&rsquo;s a useful one.</div></p><p>The <span class="RktSym">&#948;@</span> component defines the interpretation of primitives,
which is given in terms of the underlying monad.  Finally the
<span class="RktSym">alloc@</span> component provides a definition of <span class="RktSym">alloc</span>,
which fetches the store and uses its size to return a fresh address.</p><p>The <span class="RktSym">store@</span> component defines the derived operations on stores
of <span class="RktSym">find</span> and <span class="RktSym">ext</span> for finding and extending the store
in terms of the monadic operations.</p><p><div class="SIntrapara">The only remaing pieces of the puzzle are a fixed-point combinator,
which is straightforward to define:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">And the main entry-point for the interpreter:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div></p><p><div class="SIntrapara">By taking advantage of Racket&rsquo;s languages-as-libraries
features&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Sam._.Tobin-.Hochstadt%2C._.Vincent._.St-.Amour%2C._.Ryan._.Culpepper%2C._.Matthew._.Flatt%2C._and._.Matthias._.Felleisen.Languages._as._.Libraries.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Programming._.Language._.Design._and._.Implementation2011%29" data-pltdoc="x">20</a>], we can easily construct REPLs
for interacting with this interpreter.  Here are a few examples, which
make use of a concrete syntax for more succinctly writing expressions.
The identity function evaluates to an answer consisting of a closure
over the empty environment together with the empty store:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(((&#955; (x) x) . ()) . ())</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Here&rsquo;s an example showing a non-empty environment and store:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(((&#955; (y) x) . ((x . 0))) . ((0 . 4)))</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Primitive operations work as expected:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(63 . ())</span></p></td></tr></table></blockquote></div><div class="SIntrapara">And divide-by-zero errors result in failures:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(failure . ())</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Because our monad stack places <span class="RktSym">FailT</span> above <span class="RktSym">StateT</span>,
the answer includes the (empty) store at the point of the error.
Had we changed <span class="RktSym">monad@</span> to use:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">failures would not include the store:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'failure</span></p></td></tr></table></blockquote></div></p><p>At this point, we&rsquo;ve defined a fairly run of the mill definitional
interpreter.  Despite these pedestrian beginnings, we essentially have
the complete skeleton for everything to come.  In particular, we will
reuse <span class="RktSym">ev@</span> in all of the remaining interpreters.  Now let&rsquo;s do
something a bit more enchanting.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._collecting)"></a>Collecting Variations</h4><p><div class="SIntrapara">The formal development of abstract interpretation often starts from a
so-called &ldquo;non-standard collecting semantics.&rdquo;  A common form of
collecting semantics is a trace semantics, which collects streams of
states the interpreter reaches.  <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._trace%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">4</span></a> shows the monad
stack for a tracing interpreter and a kind of &ldquo;mix-in&rdquo; for the
evaluator.  The monad stack adds <span class="RktSym">WriterT</span> using
<span class="RktSym">List</span>, which provides a new operation named <span class="RktSym">tell</span> for
writing items to the stream of reached states.  The <span class="RktSym">ev-trace</span>
function is a wrapper around an underlying <span class="RktSym">ev</span> function which
interposes itself between each recursive call by telling the current
state of the evaluator, that is the current expression, environment,
and store.  The top-level evaluation function is then:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-tell</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">trace-monad@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">WriterT</span><span class="hspace">&nbsp;</span><span class="RktSym">List</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-tell@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-tell</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">tell</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._trace))" x-target-lift="Figure"></a>Figure&nbsp;4: </span>Trace collecting semantics</span></p></blockquote><p><div class="SIntrapara">Now when an expression is evaluated, we get the resulting answer and a
list of all the states seen by the evaluator, in the order in which
they were seen.  For example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktRes">'((63 . ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((* (+ 3 4) 9) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((+ 3 4) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(3 () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(4 () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(9 () ()))</span></p></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktRes">'((((&#955; (y) x) . ((x . 0))) . ((0 . 4)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(((&#955; (x) (&#955; (y) x)) 4) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((&#955; (x) (&#955; (y) x)) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(4 () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((&#955; (y) x) ((x . 0)) ((0 . 4))))</span></p></td></tr></table></td></tr></table></blockquote></div></p><p>Were we to swap <span class="RktSym">List</span> with <span class="RktSym">Set</span> in the monad stack, we
would obtain a <span style="font-style: italic">reachable</span> state semantics, another common form
of collecting semantics, that loses the order and repetition of
states.</p><p>As another collecting semantics variant, we can also consider
collecting the <span style="font-style: italic">dead code</span> in a program.  Here we use a monad
stack that has an addition state component (with operations named
<span class="RktSym">put-dead</span> and <span class="RktSym">get-dead</span>), which will the set of dead
expressions.  Initially, this will contain all of the subexpressions
of the program.  As the interpreter recurs through expressions, it
will remove them from the dead set.</p><p><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._dead%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">5</span></a> defines the monad stack for the dead code collecting
semantics and the <span class="RktSym">ev-dead@</span> component which interposes itself
on an <span class="RktSym">ev</span> function to remove the given subexpression before
recurring.  Since computing the dead code requires an outer wrapper
that sets the initial set of dead code to be all of the subexpressions
in the program, it requires a <span class="RktSym">eval-dead@</span> component which
consumes a <span style="font-style: italic">closed evaluator</span>, i.e. something of the form
<span class="RktPn">(</span><span class="RktSym">fix</span><span class="stt"> </span><span class="RktSym">ev</span><span class="RktPn">)</span>.</p><p><div class="SIntrapara">Putting these pieces together, the dead code collecting semantics can
be defined as:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">eval-dead</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-dead</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Running a program with the dead code interpreter produces an answer
and the set of expressions that were not evaluated during the running
of a program:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(cons '(1 . ()) (set 2))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(cons '(63 . ()) (set))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(cons '(((&#955; (x) x) . ()) . ()) (set 'x))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">(cons '(failure . ()) (set 3 2))</span></p></td></tr></table></blockquote></div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">dead-monad@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-dead@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-dead</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#952;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-dead</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">put-dead</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-remove</span><span class="hspace">&nbsp;</span><span class="RktSym">&#952;</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">eval-dead@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">eval-dead</span><span class="hspace">&nbsp;</span><span class="RktSym">eval</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">put-dead</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subexps</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e&#8320;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._dead))" x-target-lift="Figure"></a>Figure&nbsp;5: </span>Dead code collecting semantics</span></p></blockquote><p>So our setup makes it easy not only to express the run of the mill
interpreter, but also different forms of collecting semantics.
Let us now start to look at abstractions.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._base)"></a>Abstracting Base Values</h4><p>One of the things an abstract interpreter must do in order to become
decidable is to have some form of abstraction for the base types of
the language.  A very simple approach is to use a finite-element
abstract domain.  We can do this for our sole base type of numbers by
introducing a new kind of number, written <span class="RktVal">'</span><span class="RktVal">N</span>, which is an
abstract value that stands for all numbers.  Abstract values will be
introduced by alternative interpretation of the primitive operations,
given in <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._abs-delta%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">6</span></a>, which simply produces <span class="RktVal">'</span><span class="RktVal">N</span> in
all cases.  Some care must be taken in the interpretation of
<span class="RktVal">'</span><span class="RktVal">quotient</span> since if the denominator is an abstract value, the
result must include a failure since <span class="RktVal">0</span> is in the set of values
abstracted by <span class="RktVal">'</span><span class="RktVal">N</span>.  This means that dividing a number by an
abstract value must produce <span style="font-style: italic">two answers</span>: <span class="RktVal">'</span><span class="RktVal">N</span> and
<span class="RktVal">'</span><span class="RktVal">failure</span>.  This is done by adding non-determinism to the
monad stack,</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div><div class="SIntrapara">which provides a <span class="RktVar">mplus</span> operation for combining multiple
answers.  Non-determinism is also used in the implementation of
<span class="RktSym">zero?</span>, which returns both true and false on <span class="RktVal">'</span><span class="RktVal">N</span>.</div></p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">&#948;^@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">ovs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">ovs</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">add1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">sub1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">+</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">*</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">n1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">fail</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">fail</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">_</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._abs-delta))" x-target-lift="Figure"></a>Figure&nbsp;6: </span>Abstracting primitive operations</span></p></blockquote><p><div class="SIntrapara">By linking together the abstract variant of <span class="RktSym">&#948;</span> and the monad
stack with non-determinism, we can obtain an evaluator that produces a
set of results:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((N . ()))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((failure . ()) (N . ()))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((3 . ()) (4 . ()))</span></p></td></tr></table></blockquote></div></p><p><div class="SIntrapara">If we were to link together the abstract variant of <span class="RktSym">&#948;</span> with
the <span style="font-style: italic">tracing</span> monad stack with non-determinism added in,
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">WriterT</span><span class="hspace">&nbsp;</span><span class="RktSym">List</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">we would get an evaluator that produces sets of traces:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktRes">(set</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes">'((3 . ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((if0 (add1 0) 3 4) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((add1 0) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(0 () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(3 () ()))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes">'((4 . ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((if0 (add1 0) 3 4) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">((add1 0) () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(0 () ())</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(4 () ())))</span></p></td></tr></table></td></tr></table></blockquote></div></p><p>It should be clear that the interepreter will only ever see a finite
set of numbers (including <span class="RktVal">'</span><span class="RktVal">N</span>), but it&rsquo;s definitly not true
that the interpreter halts on all inputs.  Firstly, it&rsquo;s still
possible to generate an infinite number of closures.  Secondly,
there&rsquo;s no way for the interpreter to detect when it sees a loop.  To
make a terminating abstract interpreter requires tackling both.  Let&rsquo;s
look next at abstracting closures.</p><h3>4<tt>&nbsp;</tt><a name="(part._closures)"></a>Abstracting Closures</h3><p>Closures consist of code&#8212;<wbr></wbr>a lambda term&#8212;<wbr></wbr>and an environment&#8212;<wbr></wbr>a
finite map from variables to addresses.  Since the set of lambda terms
and variables is bounded by the program text, it suffices to abstract
closures by abstracting the set of addresses.  Following the AAM
approach, we can do this by modifying the allocation function to
always produce elements drawn from a finite set.  In order to retain
soundness in the semantics, we will need to modify the store to map
addresses to <span style="font-style: italic">sets</span> of values and model store update as a join
and dereference as a non-deterministic choice.</p><p>Any abstraction of the allocation function that produces a finite set
will do, but the choice of abstraction will determine the precision of
the resulting analysis.  A simple choice is to allocate variable
bindings by using a variable&rsquo;s name as its address.  This gives a
monomorphic, or 0CFA-like, abstraction.</p><p><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._0cfa-abs%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">7</span></a> shows an alternative component for finite
allocation that uses variables names as the notion of addresses and a
component for the derived operations <span class="RktSym">find</span> and <span class="RktSym">ext</span>
when the store uses a <span style="font-style: italic">set</span> as its range.  The
<span class="RktSym">for/monad+</span> form is just a convenience for combining a set of
computations with <span class="RktVar">mplus</span>; in other words, <span class="RktSym">find</span>
returns <span style="font-style: italic">all</span> of the values in the store at a given address.  The
<span class="RktSym">ext</span> function joins whenever an address is already allocated,
otherwise it maps the address to a singleton set.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">alloc^@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">alloc</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">store-nd@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">find</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktSym">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/monad+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">update-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._0cfa-abs))" x-target-lift="Figure"></a>Figure&nbsp;7: </span>Abstracting allocation: 0CFA</span></p></blockquote><p><div class="SIntrapara">By linking these components together with the same monad stack from
<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._base%29" data-pltdoc="x">Abstracting Base Values</a>, we obtain an interpreter that loses precision whenever
variables are bound to multiple values.  For example, this program
binds <span class="RktSym">x</span> to both <span class="RktVal">0</span> and <span class="RktVal">1</span> and therefore
produces both answers when run:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktRes">'((1 . ((x 1 0) (f ((&#955; (x) x) . ()))))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(0 . ((x 1 0) (f ((&#955; (x) x) . ())))))</span></p></td></tr></table></td></tr></table></blockquote></div></p><p>We&rsquo;ve now taken care of making a sound, finite abstraction of the
space of all closures that arise during evaluation.  It would seem we
are very close to having a sound, total abstract interpretation
function.</p><h3>5<tt>&nbsp;</tt><a name="(part._cache)"></a>Detecting Cycles with a Cache</h3><p>At this point, it&rsquo;s worth observing that the interpreter obtained by
linking together <span class="RktSym">&#948;^@</span> and <span class="RktSym">alloc^@</span> components will
only ever visit a finite number of states for a given program.  The
state consists of an expression, environment, and store mapping
addresses to sets of values.  To see that this is a finite set is
pretty straightforward: expressions (in the given program) are finite,
environments are maps from variables (again, finite in a program) to
address.  The addresses are finite thanks to <span class="RktSym">alloc^</span>, so
environments are finite.  The store maps addresses (finite by
<span class="RktSym">alloc^</span>) to sets of values.  The values are base values, which
are finite by <span class="RktSym">&#948;^</span>, or closures which consist of expressions
(in the given program) and an environment, which we just seen are
finite.  Since the elements of the sets are finite, the sets
themselves are finite, and therefore stores, and finally states, are
all finite sets.</p><p>The problem is that while the interpreter only ever see a finite set
of inputs, it <span style="font-style: italic">doesn&rsquo;t know it</span>.  So even a simple loop will
cause the interpreter to diverge:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">with-limit: out of time</span></p></td></tr></table></blockquote><p>To solve this problem, let&rsquo;s introduce a notion of a <span style="font-style: italic">cache</span>
which is a mapping from states to sets of value, store pairs.  The basic idea is
that we will use the cache to do a form of co-inductive programming.
While evaluating a state <span class="RktSym">&#962;</span> for the first time, we may at some
point be asked to evaluate exactly <span class="RktSym">&#962;</span> again.  Should this
happen, we can return the empty set of results.  We will use the cache
to track the encountered states and the results they produce.  By
maintaining the cache, we avoid the possibility of diverging.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-cache&#8242;@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-$</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#931;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/monad+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v&#215;&#963;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">put-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">put-$</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">update-$</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._ev-cache0))" x-target-lift="Figure"></a>Figure&nbsp;8: </span>Caching, first attempt</span></p></blockquote><p><div class="SIntrapara">We use the following monad stack, which adds a &ldquo;cache&rdquo; component,
which will be a finite map from states to sets of values:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT+</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></div></p><p>The <span class="RktSym">StateT+</span> monad transformer provides operations
<span class="RktSym">get-$</span> and <span class="RktSym">update-$</span> for getting and updating the
cache, respectively. It joins its finite maps by union of the range
when <span class="RktSym">mplus</span> is called, because it cannot defer to an
underlying monoid as the outer <span class="RktSym">StateT</span> does with
<span class="RktSym">NondetT</span>.</p><p><div class="SIntrapara"><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._ev-cache0%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">8</span></a> gives an <span class="RktSym">ev</span>-wrapper that interposes
itself on each recursive call to do the following steps:
</div><div class="SIntrapara"><blockquote><p>Check if the
current state is in the cache.  If it&rsquo;s in the cache, return all the
results given in the cache.  If it&rsquo;s not, set the cache for the
current state to the empty set, evaluate the expression,
add the resulting value to the cache for the state, and
return the result.</p></blockquote></div></p><p><div class="SIntrapara">We can now define an evaluation function that mixes in
<span class="RktSym">ev-cache</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>If we were to link this together with <span class="RktSym">alloc@</span> and <span class="RktSym">&#948;@</span>,
we&rsquo;d obtain a concrete interpreter that either 1) produces the empty
set because it encountered a loop, 2) produces a singleton result, or
3) diverges because it encounters an infinite set of states.  But if
we were to link this together with <span class="RktSym">alloc^@</span> and <span class="RktSym">&#948;^@</span>,
we&rsquo;d obtain an abstract interpreter that is <span style="font-style: italic">total</span>: it
terminates on all inputs.</p><p>To see why this, observe that for a given program there only a finite
set of possible caches.  We have already seen that there are a finite
set of states and values, so it follows that there are only a finite
set of maps from states to sets of values.  Now notice that on each
recursive call, either the state is in the cache and it returns
immediately, or the cache grows.  So programs simply cannot run
forever because that would imply the cache would grow forever.</p><p>It should be easy to see that if evaluating a state <span class="RktSym">&#962;</span> requires
recursively evaluating that same state, it will now produce the empty
set since the cache will be updated to map <span class="RktSym">&#962;</span> to <span class="RktSym">&#8709;</span> before
proceeding to the sub-expressions.</p><p><div class="SIntrapara">We can now see that the caching abstract interpreter halts on programs
that loop (for simplicity, the cache and store are omitted from the
printed results):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'()</span></p></td></tr></table></blockquote></div><div class="SIntrapara">This accomplishes the goal of terminating on this example, and it even
gives the right answer&#8212;<wbr></wbr>the empty set&#8212;<wbr></wbr>since this program produces
no results.</div></p><p><div class="SIntrapara">It also works for recursive functions that terminate in the concrete,
but have loops once abstracted:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sub1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(N)</span></p></td></tr></table></blockquote></div></p><p>It may seem we&rsquo;ve accomplished our goal of making a sound and
decidable abstract interpreter.  However this approach is broken in
general: it is not sound in the presence of abstraction.  The problem
here is that when the interpreter reaches &ldquo;the same&rdquo; state it has
seen before, what we mean by &ldquo;the same&rdquo; in the presence of
abstraction is subtle.  For example, imagine evaluating a function
application of some function <span class="RktSym">f</span> to an abstract value
<span class="RktVal">'</span><span class="RktVal">N</span>.  Suppose in evaluating this application we encounter
another application of <span class="RktSym">f</span> to <span class="RktVal">'</span><span class="RktVal">N</span>.  Is it the same
application?  Well, yes and no.  It is the same <span style="font-style: italic">abstract</span> state,
however the abstract state stands for a set of concrete states; in
this case, the application of <span class="RktSym">f</span> to all numbers.  So there are
states stood for in the abstraction that are equal <span style="font-style: italic">and</span> not
equal.  In other words, in the presence of abstraction, when a loop is
detected, there <span style="font-style: italic">may</span> be a loop in the concrete interpretation.
Our naive loop detection set-up however is assuming there <span style="font-style: italic">must</span>
be a loop.</p><p>We can demonstrate the problem with a simple counter-example to
soundness:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sub1</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(0)</span></p></td></tr></table></blockquote><p>Concretely, this program returns <span class="RktVal">2</span>, however with the
combination of loop detection and abstraction, the abstract
interpreter determines that this program produces <span class="RktVal">0</span>, which is
clearly unsound.</p><h3>6<tt>&nbsp;</tt><a name="(part._fixing-cache)"></a>Fixing the Cache</h3><p>The basic problem with the caching solution of <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._cache%29" data-pltdoc="x">Detecting Cycles with a Cache</a> is that
it cuts short the exploration of the program&rsquo;s behavior.  In the
soundness counter-example, the inner call to <span class="RktSym">f</span> is present in
the cache so neither branch of the conditional is taken; it is at this
point of bottoming out that we determine <span class="RktSym">f</span> may return
<span class="RktVal">0</span>.  Of course, now we know that the conditional should have
take the true branch since <span class="RktVal">0</span> could be returned, but it&rsquo;s too
late: the program has terminated.</p><p>To restore soundness, what we need to do is somehow <span style="font-style: italic">iterate</span> the
interpreter so that we can re-explore the behavior knowing that
<span class="RktSym">f</span> may produce <span class="RktVal">0</span>.  A first thought may be to do a
complete evaluation of the program, take the resulting cache, and then
feed that in as the initial cache for a re-evaluation of the program.
But there&rsquo;s an obvious problem... doing so would result in a cache hit
and the saved results would be returned immediately without exploring
any new behavior.</p><p><div class="SIntrapara">The real solution is that we want to use the prior evaluation&rsquo;s cache
as a kind of co-inductive hypothesis: it&rsquo;s only when we detect a loop
that we want to produce all of the results stored in the prior cache.
This suggests a two-cache system in which the prior cache is only used
when initializing the local cache.  In other words, we want to use the
prior cache entry in the place of <span class="RktSym">&#8709;</span>.  When iterating the
interpreter, we always start from an empty local cache and fall back
on the prior cache results when initializing the cache entry before
making a recursive call.  Since the prior cache is never written to,
we can model the prior cache as a reader monad and add it to the
stack:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">the prior cache</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT+</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>The revised <span class="RktSym">ev-cache@</span> component is given in
<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._ev-cache%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">9</span></a>, which uses the <span class="RktVar">ask-&#8869;</span> operation to
retreive the prior cache.  If the prior cache is empty, this code
degenerates into exactly what was given in <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._ev-cache0%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">8</span></a>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-cache@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-$</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#931;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/monad+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v&#215;&#963;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">put-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#931;&#8869;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-&#8869;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">initialize to prior, if exists</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">put-$</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#931;&#8869;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;&#8869;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">update-$</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._ev-cache))" x-target-lift="Figure"></a>Figure&nbsp;9: </span>Caching, with fall-back to prior</span></p></blockquote><p>We are left with two remaining problems; we need to figure out: 1) how
to pipe the cache from one run of the interpreter into the next and 2)
when to stop.  The answer to both is given in <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._cache-fix%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">10</span></a>.</p><p>The <span class="RktSym">fix-cache</span> function takes a closed evaluator,
just like <span class="RktSym">eval-dead</span> from <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._collecting%29" data-pltdoc="x">Collecting Variations</a>,
i.e. something of the form <span class="RktPn">(</span><span class="RktSym">fix</span><span class="stt"> </span><span class="RktSym">ev</span><span class="RktPn">)</span>.  It iteratively runs the
evaluator.  Each run of the evaluator resets the &ldquo;local&rdquo; cache to
empty and uses the cache of the previous run as it&rsquo;s fallback cache
(initially it&rsquo;s empty).  The computation stops when a least
fixed-point in the cache has been reached, that is, when running the
evaluator with a prior gives no changes in the resulting cache.  At
that point, the result is returned.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">fix-cache@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">eval</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">ask-env</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#962;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8788;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">&#961;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mlfp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">put-$</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;-map</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">put-store</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">local-&#8869;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVar">get-$</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-$</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/monad+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v&#215;&#963;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#931;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#962;</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">put-store</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#215;&#963;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mlfp</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">loop</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8709;-map</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">x&#8242;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">x&#8242;</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">void</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">loop</span><span class="hspace">&nbsp;</span><span class="RktSym">x&#8242;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._cache-fix))" x-target-lift="Figure"></a>Figure&nbsp;10: </span>Finding fixed-points in the cache</span></p></blockquote><p><div class="SIntrapara">With these peices in place, we can construct an interpreter as:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mrun</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">fix-cache</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fix</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ev-cache</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">When linked with <span class="RktSym">&#948;^</span> and <span class="RktSym">alloc^</span>, this interpreter is
a computable&#8212;<wbr></wbr>and we conjecture, sound&#8212;<wbr></wbr>abstraction of the original
definitional interpreter.  Note that the iterated evaluator always
terminates: the cache resulting from each run of the evaluator
contains <span style="font-style: italic">at least</span> as much information as the prior cache, each
run of the evaluator terminates, so the iterated evaluator terminates
by the same principle as before: the cache monotonically grows and is
finite in size.</div></p><p>We have thus achieved our goal and can confirm it gives
the expected answers on the previous examples:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'()</span></p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sub1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(N)</span></p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">rec</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sub1</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(0 2 3)</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Let us now take stock of what we&rsquo;ve got.</div></p><h3>7<tt>&nbsp;</tt><a name="(part._.Pushdown___la_.Reynolds)"></a>Pushdown <span style="font-style: italic">&#224; la</span> Reynolds</h3><p>By combining the finite abstraction of base values and closures with
the termination-guaranteeing cache-based fixed-point algorithm, we
have obtained a terminating abstract interpreter.  But what kind of
abstract interpretation are we really doing?</p><p>We have followed the basic recipe of AAM, but adapted to a
compositional evaluator instead of an abstract machine.  However we
did manage to skip over one of the key steps in the AAM method:
we never store-allocated continuations.</p><blockquote class="SCentered"><p><span style="font-style: italic">In fact, there are no continuations at all!</span></p></blockquote><p>The abstract machine formulation of the semantics models the
object-level stack explicitly as an inductively defined data
structure.  Because stacks may be arbitrarily large, they must be
finitized like base values and closures.  Like closures, the AAM trick
is to thread them through the store and then finitize the store.  But
in the definitional interpreter approach, the stack is implicit and
inherited from the meta-language.</p><p>But here is the remarkable thing: since the stack is inherited from
the meta-language, the abstract interpreter inherits the &ldquo;call-return
matching&rdquo; of the meta-language, which is just to say there is no loss
of precision of in the analysis of the control stack.  This is a
property that usually comes at considerable effort and engineering in
the formulations of higher-order flow analysis that model the stack
explicitly.  So-called higher-order &ldquo;pushdown&rdquo; analysis has been the
subject of multiple publications and a dissertation&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Christopher._.Earl%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Pushdown._.Control-.Flow._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">3</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Christopher._.Earl%2C._.Ilya._.Sergey%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Introspective._.Pushdown._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">4</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Thomas._.Gilray%2C._.Steven._.Lyde%2C._.Michael._.D..._.Adams%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Pushdown._.Control-.Flow._.Analysis._for._.Free.In._.Proc..._43rd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._in._.Programming._.Languages2016%29" data-pltdoc="x">7</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.J..._.Ian._.Johnson%2C._.Ilya._.Sergey%2C._.Christopher._.Earl%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming._24%282--3%292014%29" data-pltdoc="x">9</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.J..._.Ian._.Johnson._and._.David._.Van._.Horn.Abstracting._.Abstract._.Control.In._.Proc..._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014%29" data-pltdoc="x">10</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.David._.Van._.Horn._and._.Matthew._.Might.Systematic._.Abstraction._of._.Abstract._.Machines.Journal._of._.Functional._.Programming._22%284--5%292012%29" data-pltdoc="x">23</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Dimitris._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Ph.D._dissertation%2C._.Northeastern._.University2012%29" data-pltdoc="x">24</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Dimitris._.Vardoulakis._and._.Olin._.Shivers.C.F.A2~3a._a._.Context-.Free._.Approach._to._.Control-.Flow._.Analysis.Logical._.Methods._in._.Computer._.Science._7%282~3a3%292011%29" data-pltdoc="x">25</a>].  Yet when formulated in the definitional interpreter
style, the pushdown property requires no mechanics and is simply
inherited from the meta-language.</p><p>Reynolds, in his celebrated paper <span style="font-style: italic">Definitional interpreters for
higher-order languages</span>&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.John._.Reynolds.Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._.Annual._.Conference1972%29" data-pltdoc="x">16</a>], first observed that when
the semantics of a programming language is presented as a definitional
interpreter, the defined language could inherit semantic properties of
the defining language.  We have now shown this observation can be
extended to <span style="font-style: italic">abstract</span> interpretation as well, namely in the
important case of the pushdown property.</p><p>In the remainder of this paper, we harvest some of the fruits of our
labor by exploring a few natural extensions and variations on the
basic pushdown abstract interpreter we have established at this point.</p><h3>8<tt>&nbsp;</tt><a name="(part._.Widening_the_.Store)"></a>Widening the Store</h3><p>The abstract interpreter we&rsquo;ve constructed so far uses a
store-per-program-state abstraction, which while precise can be
unwieldy in terms of cost.  A common technique to combat this cost is
to use a global &ldquo;widenened&rdquo; store, which can be thought of as a
single store that is the join of all the individual stores in the
current set-up.  Thanks to our monad transformer framework, expressing
this change boils down to a simple re-ordering of the monad stack.</p><p><div class="SIntrapara">Whereas before we had:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT+</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">if we change this stack to the following:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT+</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT+</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">we get a store-widened variant of the abstract interpreter.  The idea
here is that we swap the order of the non-determinism transformer and
state transformer that is model the store.  Because stores now need to
be joined together, we have to change <span class="RktSym">StoreT</span> to
<span class="RktSym">StoreT+</span>.  And we are done!</div></p><p><div class="SIntrapara">To see the difference, here is an example without store-widening:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktRes">'((2 . ((x N) (y 2) (z 3)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(3 . ((x N) (y 2) (z 3)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(2 . ((x N) (y 2) (z 4)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(3 . ((x N) (y 1) (z 3)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(1 . ((x N) (y 1) (z 4)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(1 . ((x N) (y 1) (z 3)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(4 . ((x N) (y 2) (z 4)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktRes">(4 . ((x N) (y 1) (z 4))))</span></p></td></tr></table></td></tr></table></blockquote></div><div class="SIntrapara">and with:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'((1 3 2 4) . ((x N) (y 1 2) (z 3 4)))</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Notice that before widening, the result is a set of value, store
pairs.  After widening the result is a pair of a set of values and a
store.  Importantly, the cache, which bounds the overall run-time of
the abstract interpreter, is potentially exponential without
store-widening, but collapses to polynomial after store-widening.</div></p><h3>9<tt>&nbsp;</tt><a name="(part._.An_.Alternative_.Abstraction)"></a>An Alternative Abstraction</h3><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">precise-&#948;@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">ovs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">ovs</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">add1</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">sub1</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sub1</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal"><span class="nobreak">-</span></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">+</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal"><span class="nobreak">-</span></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">*</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVar">fail</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">add1</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">sub1</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">+</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">*</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8322;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">fail</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">_</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">fail</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">_</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">store-crush@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">find</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/monad+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">number*?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">or</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eq?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">crush</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">vs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">number*?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-add</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">for/set</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">v*</span><span class="hspace">&nbsp;</span><span class="RktSym">vs</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">#:when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">not</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">number*?</span><span class="hspace">&nbsp;</span><span class="RktSym">v*</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">v*</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set-add</span><span class="hspace">&nbsp;</span><span class="RktSym">vs</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ext</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">update-store</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">&#963;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">crush</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#963;</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._pres-delta))" x-target-lift="Figure"></a>Figure&nbsp;11: </span>An alternative abstraction for precise primitives</span></p></blockquote><p>In this section, we demonstrate how easy it is to experiment with
alternative abstraction strategies by swapping out components.  In
particular we look at an alternative abstraction of the interpretation
of primitive operations and store joins.</p><p><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._pres-delta%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">11</span></a> defines two new components:
<span class="RktSym">precise-&#948;@</span> and <span class="RktSym">store-crush@</span>.  The first is yet
another interpretation of the primitive operations.  The
distinguishing feature of this varaint of <span class="RktSym">&#948;</span> is that it is
<span style="font-style: italic">precision preserving</span>.  Unlike <span class="RktSym">&#948;^@</span>, it does not
introduce abstraction, it merely propagates it.  So if you add two
concrete numbers together, you will get a concrete number.  But if you
add a concrete and abstract number, you will get an abstract number.</p><p>This interpretation of primitive operations clearly doesn&rsquo;t impose a
finite abstraction on it&rsquo;s own.  And if used in concert with the
<span class="RktSym">store-nd@</span> implementation of the store, termination is not
guaranteed.</p><p><div class="SIntrapara">The <span class="RktSym">store-crush@</span> implementation of the store is designed to
work with the precise version of <span class="RktSym">&#948;</span> by having a different
strategy for joining values into the store.  Using the precise
<span class="RktSym">&#948;</span> and the standard store implementation, it&rsquo;s possible that
an infinite number of base values could be written into a single store
set.  What <span class="RktSym">store-crush@</span> does is widen base values to
<span class="RktVal">'</span><span class="RktVal">N</span> whevener there are multiple concrete numbers in a store
location.  Used together, it should be clear that termination is
ensured since there&rsquo;s no way to write an infinite set of values in a
store location (and there are still a finite number of addresses due
to <span class="RktSym">alloc^</span>).  While still decidable, this abstraction offers a
high-level of precision.  For example, &ldquo;straight-line&rdquo; arithmetic
operations are computed with full precision:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">9</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(63)</span></p></td></tr></table></blockquote></div><div class="SIntrapara">Even linear binding and arithmetic preserves precision:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(25)</span></p></td></tr></table></blockquote></div><div class="SIntrapara">It&rsquo;s only when the approximation of binding structure comes in to
contact with base values that we see a loss in precision:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#955;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'(N)</span></p></td></tr></table></blockquote></div></p><p>If this sets off worries about non-termination, try to construct a
program that computes an infinite set of numbers with a finite number
of variable bindings over the life of the program.  Hint: you won&rsquo;t be
able to.  (This last example suggests an easy refinement to the
<span class="RktSym">store-crush@</span> strategy: only widen when <span style="font-style: italic">different</span> base
values are written to a shared location.  We leave this as an easy
exercise for the reader.)</p><p>Here we see one of the strengths of our approach.  This strategy
appears quite natural, and to the best of our knowledge, is novel.
It&rsquo;s hard to imagine how it could be formulated as, say, a
constraint-based flow analysis.</p><h3>10<tt>&nbsp;</tt><a name="(part._symbolic)"></a>Symbolic Execution and Path-Sensitive Verification</h3><p>As a final exercise in abstract interpretation component engineering,
we develop a monadic view of symbolic execution.</p><p>We present an extension to the monad stack and metafunctions
that gives rise to a symbolic executor&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.James._.C..._.King.Symbolic._.Execution._and._.Program._.Testing.In._.Proc..._.Communications._of._the._.A.C.M1976%29" data-pltdoc="x">11</a>],
then show how abstractions discussed in previous sections
can be applied to enforce termination,
turning a traditional symbolic execution into a path-sensitive
verification engine.</p><h4>10.1<tt>&nbsp;</tt><a name="(part._.Symbolic_.Execution)"></a>Symbolic Execution</h4><p><a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._symbolic%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">12</span></a> shows the units needed to turn the existing interpreter
into a symbolic executor, in addition to adding symbolic numbers <span class="RktPn">(</span><span class="RktSym">sym</span><span class="stt"> </span><span class="RktSym">X</span><span class="RktPn">)</span>
to the language syntax.
Primitives such as <span class="RktVal">'</span><span class="RktVal">quotient</span> now may also take as input
and return symbolic values.
As standard, symbolic execution employs a path-condition
accumulating assumptions made at each branch,
allowing the elimination of infeasible paths and construction of test cases.
We represent the path-condition <span class="RktSym">&#966;</span> as a set of symbolic values
known to have evaluated to <span class="RktVal">0</span>.
This set is another state component provided by <span class="RktSym">StateT</span>.
Monadic operations <span class="RktVar">get-path-cond</span>
and <span class="RktVar">refine</span> reference and update the path-condition.
Metafunction <span class="RktVar">zero?</span> works similarly to the concrete counterpart,
but also uses the path-condition to prove that some symbolic numbers
are definitely <span class="RktVal">0</span> or non-<span class="RktVal">0</span>.
In case of uncertainty, <span class="RktVar">zero?</span> returns both answers
besides refining the path-condition with the assumption made.
Operator <span class="RktVal">'</span><span class="RktVal">&#172;</span> represents negation in our language.</p><p><div class="SIntrapara">In the following example, the symbolic executor recognizes that
result <span class="RktVal">3</span> and division-by-0 error are not feasible:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if0</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="RktRes">(set</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes">(cons '(quotient 5 x) (set '(&#172; x)))</span></p></td></tr><tr><td><p><span class="RktRes"></span><span class="hspace">&nbsp;</span><span class="RktRes">(cons 2 (set 'x)))</span></p></td></tr></table></td></tr></table></blockquote></div></p><p>A scaled up symbolic executor can have <span class="RktVar">zero?</span> calling out
to an SMT solver for interesting arithmetics,
and extend the language with symbolic functions
and blame semantics for sound higher-order symbolic
execution&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Ph~c3~bac._.C..._.Nguy~e1~bb~85n._and._.David._.Van._.Horn.Relatively._.Complete._.Counterexamples._for._.Higher-order._.Programs.In._.Proc..._36th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2015%29" data-pltdoc="x">15</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Sam._.Tobin-.Hochstadt._and._.David._.Van._.Horn.Higher-order._symbolic._execution._via._contracts.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Object._.Oriented._.Programming%2C._.Systems%2C._.Languages%2C._and._.Applications2012%29" data-pltdoc="x">21</a>].</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktSym">E</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">::=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">sym</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">X</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Symbolic</span><span class="hspace">&nbsp;</span><span class="RktCmt">number</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">symbolic-monad@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define-monad</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ReaderT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">FailT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">StateT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">NondetT</span><span class="hspace">&nbsp;</span><span class="RktSym">ID</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">ev-symbolic@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev-symbolic</span><span class="hspace">&nbsp;</span><span class="RktSym">ev&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">sym</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">return</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">e</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ev&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">ev</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">&#948;-symbolic@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">ovs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">ovs</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktVar">fail</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v&#8321;</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">&#172;</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#966;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-path-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">=</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">#:when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">&#966;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">#:when</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#8712;</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">&#172;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#966;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">&#172;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v&#8242;</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8242;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">not</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">refine</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">refine</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">&#172;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></div></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._symbolic))" x-target-lift="Figure"></a>Figure&nbsp;12: </span>Symbolic execution variant</span></p></blockquote><h4>10.2<tt>&nbsp;</tt><a name="(part._.From_.Symbolic_.Execution_to_.Verification)"></a>From Symbolic Execution to Verification</h4><p>Traditional symbolic executors mainly aim to find bugs
and provide no termination guarantee.
We can apply abstracting units presented in previous sections,
namely base value widening (<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._base%29" data-pltdoc="x">Abstracting Base Values</a>), finite allocation (<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._closures%29" data-pltdoc="x">Abstracting Closures</a>),
caching and fixing (<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._cache%29" data-pltdoc="x">Detecting Cycles with a Cache</a> and <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._fixing-cache%29" data-pltdoc="x">Fixing the Cache</a>) to turn
a symbolic execution into a sound, path-sensitive program verification.</p><p>Operations on symbolic values introduce a new source of infinite configurations
by building up new symbolic values.
We therefore straightforwardly widen a symbolic value to the abstract
number <span class="RktVal">'</span><span class="RktVal">N</span> when it shares an address with a different number.
<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._symbolic-widen%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">13</span></a> shows extension to <span class="RktVar">&#948;</span> and <span class="RktVar">zero?</span>
in the presence of <span class="RktVal">'</span><span class="RktVal">N</span>.
The different treatments of <span class="RktVal">'</span><span class="RktVal">N</span> and symbolic values
clarifies that abstract values are not symbolic values:
the former stands for a set of multiple values,
whereas the latter stands for an single unknown value.
Tests on abstract number <span class="RktVal">'</span><span class="RktVal">N</span> do not strengthen the path-condition.
It is unsound to accumulate any assumption about <span class="RktVal">'</span><span class="RktVal">N</span>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="RktSym">&#948;-symbolic@</span></span></p><blockquote class="Rfilecontent"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#948;</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">ovs</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">ovs</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">z?</span><span class="hspace">&nbsp;</span><span class="RktVar">fail</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">quotient</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">n&#8321;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="hspace">&nbsp;</span><span class="RktSym">_</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktSym">v&#8321;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">quotient</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v&#8320;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v&#8321;</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do</span><span class="hspace">&nbsp;</span><span class="RktSym">&#966;</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8592;</span><span class="hspace">&nbsp;</span><span class="RktVar">get-path-cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">N</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mplus</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">return</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></blockquote></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._symbolic-widen))" x-target-lift="Figure"></a>Figure&nbsp;13: </span>Symbolic execution with abstract numbers</span></p></blockquote><h3>11<tt>&nbsp;</tt><a name="(part._.Try_.It_.Out)"></a>Try It Out</h3><p>All of the components discussed in this paper have been implemented as
units&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Matthew._.Flatt._and._.Matthias._.Felleisen.Units~3a._.Cool._.Modules._for._.H.O.T._.Languages.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._1998._.Conference._on._.Programming._.Language._.Design._and._.Implementation1998%29" data-pltdoc="x">5</a>] in Racket&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Matthew._.Flatt._and._.P.L.T.Reference~3a._.Racket.P.L.T._.Design._.Inc..%2C._.P.L.T-.T.R-2010-12010%29" data-pltdoc="x">6</a>].  We have also
implemented a <span class="Smaller"><span class="stt">#lang</span></span> language so that composing and
experimenting with these interpreters is easy.  Assuming Racket is
installed, you can install the <span class="Smaller"><span class="stt">monadic-eval</span></span> package
with (URL redacted for double-blind):</p><blockquote class="SCentered"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">raco pkg install \</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">https://github.com/plum-umd/monadic-eval.git</span></p></td></tr></table></blockquote><p>A <span class="Smaller"><span class="stt">#lang monadic-eval</span></span> program starts with a list of
components, which are linked together, and an expression producing an
evaluator.  Subsequent forms are interpreted as expressions when run.
Programs can be run from the command-line or interactively in the
DrRacket IDE.  For example, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28counter._%28figure._screen%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">14</span></a> shows a screen shot of the PDCFA
evaluator running the example from <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._fixing-cache%29" data-pltdoc="x">Fixing the Cache</a>.</p><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><p><img src="screen.png" alt="" width="500" height="269"/></p></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._screen))" x-target-lift="Figure"></a>Figure&nbsp;14: </span>Screenshot of monadic language</span></p></blockquote><h3>12<tt>&nbsp;</tt><a name="(part._.Related_.Work)"></a>Related Work</h3><p>This work draws upon and re-presents many existing ideas from the
literature on abstract interpretation for higher-order languages.  In
particular, it closely follows the abstracting abstract
machine&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.David._.Van._.Horn._and._.Matthew._.Might.Abstracting._.Abstract._.Machines.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming2010%29" data-pltdoc="x">22</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.David._.Van._.Horn._and._.Matthew._.Might.Systematic._.Abstraction._of._.Abstract._.Machines.Journal._of._.Functional._.Programming._22%284--5%292012%29" data-pltdoc="x">23</a>] approach to deriving abstract interpreters
from semantics for higher-order languages.  The key difference here is
that we have done it in the setting of a monadic definitional
interpreter instead of an abstract machine.  This involved a novel
caching mechanism and fixed-point algorithm, but otherwise followed
the same recipe.  Remarkably, the pushdown property is simply
inherited from the meta-language rather than require explicit
mechanisms within the abstract interpreter.</p><p>The use of monads and monad transformers to make extensible (concrete)
interpreters is a well-known idea&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Sheng._.Liang%2C._.Paul._.Hudak%2C._and._.Mark._.Jones.Monad._transformers._and._modular._interpreters.In._.Proc..._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995%29" data-pltdoc="x">12</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Eugenio._.Moggi.An._abstract._view._of._programming._languages.Edinburgh._.University%2C._.E.C.S-.L.F.C.S-90-1131989%29" data-pltdoc="x">14</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Guy._.L..._.Steele._.Jr...Building._interpreters._by._composing._monads.In._.Proc..._21st._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1994%29" data-pltdoc="x">19</a>], which we have extended to work for compositional
abstract interpreters.  The use of monads and monad transformers in
machine based-formulatons of abstract interpreters has previously been
explored by Sergey, <span style="font-style: italic">et al.</span>&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Ilya._.Sergey%2C._.Dominique._.Divriese%2C._.Matthew._.Might%2C._.Jan._.Midtgaard%2C._.David._.Darais%2C._.Dave._.Clarke%2C._and._.Frank._.Piessens.Monadic._.Abstract._.Interpreters.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Programming._.Language._.Design._and._.Implementation2013%29" data-pltdoc="x">18</a>] and Darais
<span style="font-style: italic">et al.</span>&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.David._.Darais%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Galois._.Transformers._and._.Modular._.Abstract._.Interpreters.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages%2C._and._.Applications2015%29" data-pltdoc="x">2</a>], respectively.  Darais has also
shown that certain monad transformers are also <span style="font-style: italic">Galois
transformers</span>, i.e. they compose to form monads that are Galois
connections.  This idea may pave a path forward for having both
componential code <span style="font-style: italic">and proofs</span> for abstract interpreters in the
style presented here.</p><p>The caching mechanism used to ensure termination in our abstract
interpreter is similar to that used by Johnson and Van
Horn&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.J..._.Ian._.Johnson._and._.David._.Van._.Horn.Abstracting._.Abstract._.Control.In._.Proc..._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014%29" data-pltdoc="x">10</a>].  They use a local- and meta-memoization
table in a machine-based interpreter to ensure termination for a
pushdown abstract interpreter.  This mechanism is in turn reminiscent
of Gl&#252;ck&rsquo;s use of memoization in an interpreter for two-way
non-deterministic pushdown automata&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Robert._.Gl~c3~bcck.Simulation._of._two-way._pushdown._automata._revisited.Semantics%2C._.Abstract._.Interpretation%2C._and._.Reasoning._about._.Programs~3a~0a.Essays._.Dedicated._to._.David._.A..._.Schmidt._on._the._.Occasion._of._his._.Sixtieth~0a.Birthday2013%29" data-pltdoc="x">8</a>].</p><p>Vardoulakis, who was the first to develop the idea of a pushdown
abstraction for higher-order flow analysis&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Dimitris._.Vardoulakis._and._.Olin._.Shivers.C.F.A2~3a._a._.Context-.Free._.Approach._to._.Control-.Flow._.Analysis.Logical._.Methods._in._.Computer._.Science._7%282~3a3%292011%29" data-pltdoc="x">25</a>],
formalized CFA2 using a CPS model, which is similar in spirit to a
machine-based model.  However, in his dissertation&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Dimitris._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Ph.D._dissertation%2C._.Northeastern._.University2012%29" data-pltdoc="x">24</a>] he
sketches an alternative presentation dubbed &ldquo;Big CFA2&rdquo; which is a
big-step operational semantics for doing pushdown analysis quite
similar in spirit to the approach presented here.  One key difference
is that Big CFA2 fixes a particular coarse abstraction of base values
and closures&#8212;<wbr></wbr>for example, both branches of a conditional are always
evaluated.  Consequently, it only uses a single iteration of the
abstract evaluation function, similar to the <span style="font-style: italic">unsound</span> approach
of <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._cache%29" data-pltdoc="x">Detecting Cycles with a Cache</a> and avoids the need for the cache-based fixed-point
of <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28part._fixing-cache%29" data-pltdoc="x">Fixing the Cache</a>.  We don&rsquo;t believe Big CFA2 as stated is
unsound, however if the underlying abstractions were tightened, it
appears it would run in to the same issues identified here.</p><p>Our formulation of a pushdown abstract interpreter computes an
abstraction similar to the many existing variants of pushdown flow
analysis&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Christopher._.Earl%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Pushdown._.Control-.Flow._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010%29" data-pltdoc="x">3</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Christopher._.Earl%2C._.Ilya._.Sergey%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Introspective._.Pushdown._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012%29" data-pltdoc="x">4</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Thomas._.Gilray%2C._.Steven._.Lyde%2C._.Michael._.D..._.Adams%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Pushdown._.Control-.Flow._.Analysis._for._.Free.In._.Proc..._43rd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._in._.Programming._.Languages2016%29" data-pltdoc="x">7</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.J..._.Ian._.Johnson%2C._.Ilya._.Sergey%2C._.Christopher._.Earl%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming._24%282--3%292014%29" data-pltdoc="x">9</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.J..._.Ian._.Johnson._and._.David._.Van._.Horn.Abstracting._.Abstract._.Control.In._.Proc..._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014%29" data-pltdoc="x">10</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.David._.Van._.Horn._and._.Matthew._.Might.Systematic._.Abstraction._of._.Abstract._.Machines.Journal._of._.Functional._.Programming._22%284--5%292012%29" data-pltdoc="x">23</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Dimitris._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Ph.D._dissertation%2C._.Northeastern._.University2012%29" data-pltdoc="x">24</a>, <a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Dimitris._.Vardoulakis._and._.Olin._.Shivers.C.F.A2~3a._a._.Context-.Free._.Approach._to._.Control-.Flow._.Analysis.Logical._.Methods._in._.Computer._.Science._7%282~3a3%292011%29" data-pltdoc="x">25</a>].</p><p>The
mixing of symbolic execution and abstract intrepretation is similar in
spirit to the <span style="font-style: italic">logic flow analysis</span> of Might&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Matthew._.Might.Logic._.Flow._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._34th._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2007%29" data-pltdoc="x">13</a>],
albeit in a pushdown setting and with a stronger notion of negation;
generally, our presentation resembles traditional formulations of
symbolic execution more closely.  Our approach to symbolic execution
only handles the first-order case of symbolic values, as is
traditional.  However, Nguy&#7877;n&rsquo;s work on higher-order symbolic
execution&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Ph~c3~bac._.C..._.Nguy~e1~bb~85n._and._.David._.Van._.Horn.Relatively._.Complete._.Counterexamples._for._.Higher-order._.Programs.In._.Proc..._36th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2015%29" data-pltdoc="x">15</a>] demonstrates how to scale to behavioral
symbolic values.  In principle, it should be possible to handle this
case in our approach by adapting Nguy&#7877;n&rsquo;s method to a formulation in a
compositional evaluator.</p><p>We have eschewed soundness proofs in this paper.  This is done in part
to emphasize the pearly intuitions and constructions of abstract
definitional interpreters and in part because it is far less clear how
to prove soundness when compared to the machine-based formulations.
Part of the difficulty stems from the set-up to support extensibility.
As mentioned previously, perhaps Galois
transformers&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.David._.Darais%2C._.Matthew._.Might%2C._and._.David._.Van._.Horn.Galois._.Transformers._and._.Modular._.Abstract._.Interpreters.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Object-.Oriented._.Programming%2C._.Systems%2C._.Languages%2C._and._.Applications2015%29" data-pltdoc="x">2</a>] can help with this aspect.  But
even if we fixed a particular set of components and monad transformer
stack, we run up against the challenge of having to prove soundness in
the presence of concrete computations which may not terminate.
Handling this in the small-step setting is easy using a preservation
argument, but it&rsquo;s not clear how to do it with our approach.  Rompf
and Amin&rsquo;s recent work on proving type soundness with definitional
interpreters&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Tiark._.Rompf._and._.Nada._.Amin.From._.F._to._.D.O.T~3a._.Type._.Soundness._.Proofs._with._.Definitional._.Interpretersar.Xiv%2C._1510..052162015%29" data-pltdoc="x">17</a>] appears revelant and perhaps paves a way
forward.</p><p>Now that we have abstract interpreters formulated with a basis in
abstract machines and with a basis in monadic interpreters, an obvious
question is can we obtain a correspondence between them similar to the
functional correspondence between their concrete
counterparts&nbsp;[<a href="file:///Users/dvanhorn/git/monadic-eval/monadic-eval/paper/main.html#%28autobib._.Mads._.Sig._.Ager%2C._.Olivier._.Danvy%2C._and._.Jan._.Midtgaard.A._functional._correspondence._between._monadic._evaluators._and._abstract._machines._for._languages._with._computational._effects.Theoretical._.Computer._.Science._342%281%292005%29" data-pltdoc="x">1</a>]?  An interesting direction for future
work is to try to apply the usual tools of defunctionalization, CPS,
and refocusing to see if we can interderive these abstract semantic
artifacts.</p><h3>13<tt>&nbsp;</tt><a name="(part._.Conclusions)"></a>Conclusions</h3><p>We have shown that a definitional interpreter written in monadic style
can express a wide variety of semantics, such as the usual concrete
semantics, collecting semantics, abstract interpretations, symbolic
execution, and several combinations thereof.</p><p>Remarkably, we observe that our abstract interpreter implements a form
of pushdown abstraction in which calls and returns are always properly
matched in the abstract semantics.  True to the definitional style of
Reynolds, the evaluator involves no explicit mechanics to achieve this
property; it is simply inherited from the defining language.</p><p>We believe this formulation of higher-order abstract interpretation
offers a promising new foundation for making re-usable components for
the static analysis and verification of higher-order programs.</p><p><span class="paragraph">Acknowledgments</span> We thank Sam
Tobin-Hochstadt and Dionna Glaze for several fruitful conversations
while developing the ideas in this work.</p><p><span class="balance"></span></p><h3><a name="(part._doc-bibliography)"></a>Bibliography</h3><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="Autocolbibnumber">[1]</span></p></td><td><p><a name="(autobib._.Mads._.Sig._.Ager,._.Olivier._.Danvy,._and._.Jan._.Midtgaard.A._functional._correspondence._between._monadic._evaluators._and._abstract._machines._for._languages._with._computational._effects.Theoretical._.Computer._.Science._342(1)2005)"></a><span class="Autocolbibentry">Mads Sig Ager, Olivier Danvy, and Jan Midtgaard. A functional correspondence between monadic evaluators and abstract machines for languages with computational effects. <span style="font-style: italic">Theoretical Computer Science</span> 342(1), 2005.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[2]</span></p></td><td><p><a name="(autobib._.David._.Darais,._.Matthew._.Might,._and._.David._.Van._.Horn.Galois._.Transformers._and._.Modular._.Abstract._.Interpreters.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Object-.Oriented._.Programming,._.Systems,._.Languages,._and._.Applications2015)"></a><span class="Autocolbibentry">David Darais, Matthew Might, and David Van Horn. Galois Transformers and Modular Abstract Interpreters. In <span style="font-style: italic">Proc. ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications</span>, 2015.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[3]</span></p></td><td><p><a name="(autobib._.Christopher._.Earl,._.Matthew._.Might,._and._.David._.Van._.Horn.Pushdown._.Control-.Flow._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._.Workshop._on._.Scheme._and._.Functional._.Programming2010)"></a><span class="Autocolbibentry">Christopher Earl, Matthew Might, and David Van Horn. Pushdown Control-Flow Analysis of Higher-Order Programs. In <span style="font-style: italic">Proc. Workshop on Scheme and Functional Programming</span>, 2010.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[4]</span></p></td><td><p><a name="(autobib._.Christopher._.Earl,._.Ilya._.Sergey,._.Matthew._.Might,._and._.David._.Van._.Horn.Introspective._.Pushdown._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Functional._.Programming2012)"></a><span class="Autocolbibentry">Christopher Earl, Ilya Sergey, Matthew Might, and David Van Horn. Introspective Pushdown Analysis of Higher-Order Programs. In <span style="font-style: italic">Proc. ACM SIGPLAN International Conference on Functional Programming</span>, 2012.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[5]</span></p></td><td><p><a name="(autobib._.Matthew._.Flatt._and._.Matthias._.Felleisen.Units~3a._.Cool._.Modules._for._.H.O.T._.Languages.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._1998._.Conference._on._.Programming._.Language._.Design._and._.Implementation1998)"></a><span class="Autocolbibentry">Matthew Flatt and Matthias Felleisen. Units: Cool Modules for HOT Languages. In <span style="font-style: italic">Proc. ACM SIGPLAN 1998 Conference on Programming Language Design and Implementation</span>, 1998.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[6]</span></p></td><td><p><a name="(autobib._.Matthew._.Flatt._and._.P.L.T.Reference~3a._.Racket.P.L.T._.Design._.Inc..,._.P.L.T-.T.R-2010-12010)"></a><span class="Autocolbibentry">Matthew Flatt and PLT. Reference: Racket. PLT Design Inc., PLT-TR-2010-1, 2010.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[7]</span></p></td><td><p><a name="(autobib._.Thomas._.Gilray,._.Steven._.Lyde,._.Michael._.D..._.Adams,._.Matthew._.Might,._and._.David._.Van._.Horn.Pushdown._.Control-.Flow._.Analysis._for._.Free.In._.Proc..._43rd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._in._.Programming._.Languages2016)"></a><span class="Autocolbibentry">Thomas Gilray, Steven Lyde, Michael D. Adams, Matthew Might, and David Van Horn. Pushdown Control-Flow Analysis for Free. In <span style="font-style: italic">Proc. 43rd ACM SIGPLAN-SIGACT Symposium on Principles in Programming Languages</span>, 2016.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[8]</span></p></td><td><p><a name="(autobib._.Robert._.Gl~c3~bcck.Simulation._of._two-way._pushdown._automata._revisited.Semantics,._.Abstract._.Interpretation,._and._.Reasoning._about._.Programs~3a~0a.Essays._.Dedicated._to._.David._.A..._.Schmidt._on._the._.Occasion._of._his._.Sixtieth~0a.Birthday2013)"></a><span class="Autocolbibentry">Robert Gl&#252;ck. Simulation of two-way pushdown automata revisited. <span style="font-style: italic">Semantics, Abstract Interpretation, and Reasoning about Programs:
Essays Dedicated to David A. Schmidt on the Occasion of his Sixtieth
Birthday</span>, 2013.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[9]</span></p></td><td><p><a name="(autobib._.J..._.Ian._.Johnson,._.Ilya._.Sergey,._.Christopher._.Earl,._.Matthew._.Might,._and._.David._.Van._.Horn.Pushdown._flow._analysis._with._abstract._garbage._collection.Journal._of._.Functional._.Programming._24(2--3)2014)"></a><span class="Autocolbibentry">J. Ian Johnson, Ilya Sergey, Christopher Earl, Matthew Might, and David Van Horn. Pushdown flow analysis with abstract garbage collection. <span style="font-style: italic">Journal of Functional Programming</span> 24(2&ndash;3), 2014.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[10]</span></p></td><td><p><a name="(autobib._.J..._.Ian._.Johnson._and._.David._.Van._.Horn.Abstracting._.Abstract._.Control.In._.Proc..._10th._.A.C.M._.Symposium._on._.Dynamic._.Languages2014)"></a><span class="Autocolbibentry">J. Ian Johnson and David Van Horn. Abstracting Abstract Control. In <span style="font-style: italic">Proc. 10th ACM Symposium on Dynamic Languages</span>, 2014.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[11]</span></p></td><td><p><a name="(autobib._.James._.C..._.King.Symbolic._.Execution._and._.Program._.Testing.In._.Proc..._.Communications._of._the._.A.C.M1976)"></a><span class="Autocolbibentry">James C. King. Symbolic Execution and Program Testing. In <span style="font-style: italic">Proc. Communications of the ACM</span>, 1976.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[12]</span></p></td><td><p><a name="(autobib._.Sheng._.Liang,._.Paul._.Hudak,._and._.Mark._.Jones.Monad._transformers._and._modular._interpreters.In._.Proc..._22nd._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1995)"></a><span class="Autocolbibentry">Sheng Liang, Paul Hudak, and Mark Jones. Monad transformers and modular interpreters. In <span style="font-style: italic">Proc. 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 1995.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[13]</span></p></td><td><p><a name="(autobib._.Matthew._.Might.Logic._.Flow._.Analysis._of._.Higher-.Order._.Programs.In._.Proc..._34th._.Annual._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages2007)"></a><span class="Autocolbibentry">Matthew Might. Logic Flow Analysis of Higher-Order Programs. In <span style="font-style: italic">Proc. 34th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 2007.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[14]</span></p></td><td><p><a name="(autobib._.Eugenio._.Moggi.An._abstract._view._of._programming._languages.Edinburgh._.University,._.E.C.S-.L.F.C.S-90-1131989)"></a><span class="Autocolbibentry">Eugenio Moggi. An abstract view of programming languages. Edinburgh University, ECS-LFCS-90-113, 1989.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[15]</span></p></td><td><p><a name="(autobib._.Ph~c3~bac._.C..._.Nguy~e1~bb~85n._and._.David._.Van._.Horn.Relatively._.Complete._.Counterexamples._for._.Higher-order._.Programs.In._.Proc..._36th._.A.C.M._.S.I.G.P.L.A.N._.Conference._on._.Programming._.Language._.Design._and._.Implementation2015)"></a><span class="Autocolbibentry">Ph&#250;c C. Nguy&#7877;n and David Van Horn. Relatively Complete Counterexamples for Higher-order Programs. In <span style="font-style: italic">Proc. 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</span>, 2015.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[16]</span></p></td><td><p><a name="(autobib._.John._.Reynolds.Definitional._interpreters._for._higher-order._programming._languages.In._.Proc..._.A.C.M._.Annual._.Conference1972)"></a><span class="Autocolbibentry">John Reynolds. Definitional interpreters for higher-order programming languages. In <span style="font-style: italic">Proc. ACM Annual Conference</span>, 1972.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[17]</span></p></td><td><p><a name="(autobib._.Tiark._.Rompf._and._.Nada._.Amin.From._.F._to._.D.O.T~3a._.Type._.Soundness._.Proofs._with._.Definitional._.Interpretersar.Xiv,._1510..052162015)"></a><span class="Autocolbibentry">Tiark Rompf and Nada Amin. From F to DOT: Type Soundness Proofs with Definitional Interpreters. arXiv, 1510.05216, 2015.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[18]</span></p></td><td><p><a name="(autobib._.Ilya._.Sergey,._.Dominique._.Divriese,._.Matthew._.Might,._.Jan._.Midtgaard,._.David._.Darais,._.Dave._.Clarke,._and._.Frank._.Piessens.Monadic._.Abstract._.Interpreters.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Programming._.Language._.Design._and._.Implementation2013)"></a><span class="Autocolbibentry">Ilya Sergey, Dominique Divriese, Matthew Might, Jan Midtgaard, David Darais, Dave Clarke, and Frank Piessens. Monadic Abstract Interpreters. In <span style="font-style: italic">Proc. ACM SIGPLAN International Conference on Programming Language Design and Implementation</span>, 2013.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[19]</span></p></td><td><p><a name="(autobib._.Guy._.L..._.Steele._.Jr...Building._interpreters._by._composing._monads.In._.Proc..._21st._.A.C.M._.S.I.G.P.L.A.N-.S.I.G.A.C.T._.Symposium._on._.Principles._of._.Programming._.Languages1994)"></a><span class="Autocolbibentry">Guy L. Steele Jr. Building interpreters by composing monads. In <span style="font-style: italic">Proc. 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</span>, 1994.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[20]</span></p></td><td><p><a name="(autobib._.Sam._.Tobin-.Hochstadt,._.Vincent._.St-.Amour,._.Ryan._.Culpepper,._.Matthew._.Flatt,._and._.Matthias._.Felleisen.Languages._as._.Libraries.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Programming._.Language._.Design._and._.Implementation2011)"></a><span class="Autocolbibentry">Sam Tobin-Hochstadt, Vincent St-Amour, Ryan Culpepper, Matthew Flatt, and Matthias Felleisen. Languages as Libraries. In <span style="font-style: italic">Proc. ACM SIGPLAN International Conference on Programming Language Design and Implementation</span>, 2011.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[21]</span></p></td><td><p><a name="(autobib._.Sam._.Tobin-.Hochstadt._and._.David._.Van._.Horn.Higher-order._symbolic._execution._via._contracts.In._.Proc..._.A.C.M._.S.I.G.P.L.A.N._.International._.Conference._on._.Object._.Oriented._.Programming,._.Systems,._.Languages,._and._.Applications2012)"></a><span class="Autocolbibentry">Sam Tobin-Hochstadt and David Van Horn. Higher-order symbolic execution via contracts. In <span style="font-style: italic">Proc. ACM SIGPLAN International Conference on Object Oriented Programming, Systems, Languages, and Applications</span>, 2012.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[22]</span></p></td><td><p><a name="(autobib._.David._.Van._.Horn._and._.Matthew._.Might.Abstracting._.Abstract._.Machines.In._.Proc..._.A.C.M._.International._.Conference._on._.Functional._.Programming2010)"></a><span class="Autocolbibentry">David Van Horn and Matthew Might. Abstracting Abstract Machines. In <span style="font-style: italic">Proc. ACM International Conference on Functional Programming</span>, 2010.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[23]</span></p></td><td><p><a name="(autobib._.David._.Van._.Horn._and._.Matthew._.Might.Systematic._.Abstraction._of._.Abstract._.Machines.Journal._of._.Functional._.Programming._22(4--5)2012)"></a><span class="Autocolbibentry">David Van Horn and Matthew Might. Systematic Abstraction of Abstract Machines. <span style="font-style: italic">Journal of Functional Programming</span> 22(4&ndash;5), 2012.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[24]</span></p></td><td><p><a name="(autobib._.Dimitris._.Vardoulakis.C.F.A2~3a._.Pushdown._.Flow._.Analysis._for._.Higher-.Order._.Languages.Ph.D._dissertation,._.Northeastern._.University2012)"></a><span class="Autocolbibentry">Dimitris Vardoulakis. CFA2: Pushdown Flow Analysis for Higher-Order Languages. PhD dissertation, Northeastern University, 2012.</span></p></td></tr><tr><td><p><span class="Autocolbibnumber">[25]</span></p></td><td><p><a name="(autobib._.Dimitris._.Vardoulakis._and._.Olin._.Shivers.C.F.A2~3a._a._.Context-.Free._.Approach._to._.Control-.Flow._.Analysis.Logical._.Methods._in._.Computer._.Science._7(2~3a3)2011)"></a><span class="Autocolbibentry">Dimitris Vardoulakis and Olin Shivers. CFA2: a Context-Free Approach to Control-Flow Analysis. <span style="font-style: italic">Logical Methods in Computer Science</span> 7(2:3), 2011.</span></p></td></tr></table></p></div></div><div id="contextindicator">&nbsp;</div></body></html>