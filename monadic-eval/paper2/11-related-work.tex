\section{Related Work}

This work draws upon and re-presents many ideas from the literature on abstract
interpretation for higher-order languages.  In particular, it closely follows
the abstracting abstract
machines~\cite{dvanhorn:VanHorn2010Abstracting,dvanhorn:VanHorn2012Systematic}
approach to deriving abstract interpreters from a small-step machine. The key
difference here is that we operate in the setting of a monadic definitional
interpreter instead of an abstract machine.  This involved a novel caching
mechanism and fixed-point algorithm, but otherwise followed the same recipe.
Remarkably, the pushdown property is simply inherited from the meta-language
rather than require explicit mechanisms within the abstract interpreter.

The use of monads and monad transformers to make extensible (concrete)
interpreters is a well-known
idea~\cite{davdar:Moggi:1989:Monads,local:steele-popl94,dvanhorn:Liang1995Monad},
which we have extended to work for compositional abstract interpreters.  The
use of monads and monad transformers in machine based-formulatons of abstract
interpreters has previously been explored by Sergey, \emph{et
al.}~\cite{dvanhorn:Sergey2013Monadic} and Darais \emph{et
al.}~\cite{local:darais-oopsla2015}, respectively.  Darais has also shown that
certain monad transformers are also \emph{Galois transformers}, i.e. they
compose to form monads that are Galois connections.  This idea may pave a path
forward for having both componential code \emph{and proofs} for abstract
interpreters in the style presented here.

The caching mechanism used to ensure termination in our abstract interpreter is
similar to that used by Johnson and Van
Horn~\cite{dvanhorn:Johnson2014Abstracting}.  They use a local- and
meta-memoization table in a machine-based interpreter to ensure termination for
a pushdown abstract interpreter.  This mechanism is in turn reminiscent of
Gl\"{u}ck's use of memoization in an interpreter for two-way non-deterministic
pushdown automata~\cite{local:gluck-schmidtfest13}.

Caching recursive, non-deterministic functions is a well-studied problem in the
functional logic programming community (there termed
``tabling'')~\cite{local:tamaki1986old, local:bol1993tabulated,
  local:chen1996tabled, local:swift2012xsb}, and has been usefully applied to
program verification and analysis~\cite{local:dawson1996practical,
  local:janssens1998use}. Unlike these systems, our approach uses a shallow
embedding of cached non-determinism that can be applied in general-purpose
functional languages.
%
Monad transformers that enable shallow embedding of cached non-determinism are
of continued interest since Hinze's \emph{Deriving Backtracking Monad
  Transformers} ~\cite{local:hinze2000deriving, local:kiselyov2005backtracking,
  local:fischer2011purely}, and recent work~\cite{local:ploeg2014reflection,
  local:vandenbroucke2016fixing} points to potential optimizations and
specializations that can be applied to our relatively naive iteration strategy.

Vardoulakis, who was the first to develop the idea of a pushdown abstraction
for higher-order flow analysis~\cite{dvanhorn:Vardoulakis2011CFA2}, formalized
CFA2 using a CPS model, which is similar in spirit to a machine-based model.
However, in his dissertation~\cite{local:vardoulakis-diss12} he sketches an
alternative presentation dubbed ``Big CFA2'' which is a big-step operational
semantics for doing pushdown analysis quite similar in spirit to the approach
presented here.  One key difference is that Big CFA2 fixes a particular coarse
abstraction of base values and closures---for example, both branches of a
conditional are always evaluated.  Consequently, it only uses a single
iteration of the abstract evaluation function, and avoids the need for the
cache-based fixed-point of Section~\ref{s:cache}.  We don't believe Big CFA2 as
stated is unsound, however if the underlying abstractions were tightened, it
may then require a more involved fixpoint finding algorithm like the one we
developed.

Our formulation of a pushdown abstract interpreter computes an abstraction
similar to the many existing variants of pushdown flow analysis~\cite%
{dvanhorn:Vardoulakis2011CFA2%
,dvanhorn:Earl2010Pushdown%
,local:vardoulakis-diss12%
,dvanhorn:VanHorn2012Systematic%
,dvanhorn:Earl2012Introspective%
,dvanhorn:Johnson2014Abstracting%
,dvanhorn:Johnson2014Pushdown%
,local:p4f%
}.
% @;{ Our incorporation of an
% abstract garbage collector into a pushdown abstract interpreter
% achieves a similar goal as that of so-called @emph{introspective}
% pushdown abstract interpreters@~cite[earl-icfp12 johnson-jfp14].  }
The mixing of symbolic execution and abstract intrepretation is similar in
spirit to the \emph{logic flow analysis} of Might~\cite{local:might-popl07},
albeit in a pushdown setting and with a stronger notion of negation; generally,
our presentation resembles traditional formulations of symbolic execution more
closely.  Our approach to symbolic execution only handles the first-order case
of symbolic values, as is traditional.  However, Nguy$\tilde{\mbox{\^{e}}}$n's work on higher-order % FIXME use unicode
symbolic execution~\cite{dvanhorn:Nguyen2015Relatively} demonstrates how to
scale to behavioral symbolic values.  In principle, it should be possible to
handle this case in our approach by adapting Nguy$\tilde{\mbox{\^{e}}}$n's method to a formulation % FIXME use unicode
in a compositional evaluator.

Now that we have abstract interpreters formulated with a basis in abstract
machines and with a basis in monadic interpreters, an obvious question is can
we obtain a correspondence between them similar to the functional
correspondence between their concrete
counterparts~\cite{dvanhorn:Ager2005Functional}.  An interesting direction for
future work is to try to apply the usual tools of defunctionalization, CPS, and
refocusing to see if we can interderive these abstract semantic artifacts.
