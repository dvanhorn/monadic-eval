\section{Detecting Cycles with a Cache}\label{s:cache}

At this point, the interpreter obtained by linking together ⸨monad^@⸩, ⸨δ^@⸩,
⸨alloc^@⸩ and ⸨store-nd@⸩ components will only ever visit a finite number of
configurations for a given program.  The configuration consists of an
expression, environment, and store mapping addresses to sets of values.  This
configuration is finite because: expressions (in the given program) are finite;
environments are maps from variables (again, finite in a program) to addresses;
the addresses are finite thanks to ⸨alloc^⸩; the store maps addresses (finite
by ⸨alloc^⸩) to sets of values; base values are abstracted to a finite set by
⸨δ^⸩; closures consist of expressions (in the given program) and an
environment, which are both finite.

Although the interpreter will only ever see a finite set of inputs, it
\emph{doesn't know it}.  A simple loop will cause the interpreter to diverge:
ℑ⁅
¦ > (rec f (λ (x) (f x)) (f 0))
ℑ,
¦ timeout
ℑ⁆

To solve this problem, we introduce a \emph{cache} which maps from
configurations to sets of value-and-store pairs. While evaluating a
configuration ⸨ς⸩ for the first time, we may at some point be asked to evaluate
exactly ⸨ς⸩ again. Should this happen, we can return the empty set of results.
We will use the cache to track the encountered configurations and the results
they produce.  By maintaining the cache, we avoid the possibility of diverging.

\begin{figure}
\rfloat{⸨ev-cache′@⸩}
\begin{lstlisting}
¦ (define (((ev-cache ev₀) ev) e)
¦   (do ρ ← ask-env
¦       σ ← get-store
¦       ς ≔ (list e ρ σ)
¦       Σ ← get-¢
¦       (if (∈ ς Σ)
¦           (for/monad+ ([v×σ (Σ ς)])
¦             (do (put-store (cdr v×σ))
¦                 (return (car v×σ))))
¦           (do (put-¢ (Σ ς ∅))
¦               v  ← ((ev₀ ev) e)
¦               (update-¢
¦                 (λ (Σ) 
¦                   (Σ ς (set-add (Σ ς)
¦                                 (cons v σ)))))
¦               (return v)))))
\end{lstlisting}
\caption{Caching, First Attempt}
\label{f:ev-cache0}
\end{figure}

We use the following monad stack, which adds a ``cache'' component,
which will be a finite map from states to sets of values:
\begin{lstlisting}
¦ (ReaderT (FailT (StateT (NondetT (StateT+ ID)))))
\end{lstlisting}

The ⸨StateT+⸩ monad transformer provides operations
⸨get-¢⸩ and ⸨update-¢›⸩ for getting and updating the
cache, respectively. It joins its finite maps by union of the range
when ⸨mplus⸩ is called, because it cannot defer to an
underlying monoid as the outer ⸨StateT⸩ does with
⸨NondetT⸩.

Figure~\ref{f:ev-cache0} gives an ⸨ev⸩-wrapper that interposes
itself on each recursive call to do the following steps:
\begin{displayquote}
Check if the current state is in the cache.  If it's in the cache, return all
the results given in the cache.  If it's not, set the cache for the current
state to the empty set, evaluate the expression, add the resulting value to the
cache for the state, and return the result.
\end{displayquote}

We can now define an evaluation function that mixes in ⸨ev-cache⸩:
\begin{lstlisting}
¦ (define (eval e)
¦   (mrun ((fix (ev-cache ev)) e)))
\end{lstlisting}

If we were to link this together with ⸨alloc@⸩ and ⸨δ@⸩, we'd obtain a concrete
interpreter that either 1) produces the empty set because it encountered a
loop, 2) produces a singleton result, or 3) diverges because it encounters an
infinite set of states.  But if we were to link this together with ⸨alloc^@⸩
and ⸨δ^@⸩, we'd obtain an abstract interpreter that is \emph{total}: it
terminates on all inputs.

To see why this, observe that for a given program there only a finite set of
possible caches.  We have already seen that there are a finite set of states
and values, so it follows that there are only a finite set of maps from states
to sets of values.  Now notice that on each recursive call, either the state is
in the cache and it returns immediately, or the cache grows.  So programs
simply cannot run forever because that would imply the cache would grow
forever.

It should be easy to see that if evaluating a state ⸨ς⸩ requires recursively
evaluating that same state, it will now produce the empty set since the cache
will be updated to map ⸨ς⸩ to ⸨∅⸩ before proceeding to the sub-expressions.

We can now see that the caching abstract interpreter halts on programs that
loop (for simplicity, the cache and store are omitted from the printed
results):
ℑ⁅
¦ > (rec f (λ (x) (f x)) (f 0))
ℑ,
¦ '()
ℑ⁆
This accomplishes the goal of terminating on this example, and it even
gives the right answer---the empty set---since this program produces
no results.

It also works for recursive functions that terminate in the concrete,
but have loops once abstracted:
ℑ⁅
¦ > (rec fact (λ (n)
¦              (if0 n 1 (* n (fact (sub1 n)))))
¦     (fact 5))
ℑ,
¦ '(N)
ℑ⁆

It may seem we've accomplished our goal of making a sound and
decidable abstract interpreter.  However this approach is broken in
general: it is not sound in the presence of abstraction.  The problem
here is that when the interpreter reaches ``the same'' state it has
seen before, what we mean by ``the same'' in the presence of
abstraction is subtle.  For example, imagine evaluating a function
application of some function ⸨f⸩ to an abstract value
⸨'N⸩.  Suppose in evaluating this application we encounter
another application of ⸨f⸩ to ⸨'N⸩.  Is it the same
application?  Well, yes and no.  It is the same \emph{abstract} state,
however the abstract state stands for a set of concrete states; in
this case, the application of ⸨f⸩ to all numbers.  So there are
states stood for in the abstraction that are equal \emph{and} not
equal.  In other words, in the presence of abstraction, when a loop is
detected, there \emph{may} be a loop in the concrete interpretation.
Our naive loop detection set-up however is assuming there \emph{must}
be a loop.

We can demonstrate the problem with a simple counter-example to
soundness:
ℑ⁅
¦ > (rec f (λ (x) 
¦            (if0 x 0 (if0 (f (sub1 x)) 2 3)))
¦      (f (add1 0)))
ℑ,
¦ '(0)
ℑ⁆

Concretely, this program returns ⸨2⸩, however with the
combination of loop detection and abstraction, the abstract
interpreter determines that this program produces ⸨0⸩, which is
clearly unsound.
