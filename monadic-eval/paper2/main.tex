\documentclass[preprint]{sigplanconf}

\usepackage{microtype}
\usepackage{textcomp}
\usepackage[scaled=0.8]{DejaVuSansMono}
\usepackage{setspace}
%\linespread{0.95}

\usepackage{balance}
\usepackage{moresize}
\usepackage{csquotes}
\usepackage{upgreek}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{stmaryrd}

\usepackage{mathpartir}
\usepackage{galois}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}

\usepackage[usenames,dvipsnames]{color}
%\definecolor{PaleBlue}{rgb}{0.90,0.90,1.0}
%\definecolor{LightGray}{rgb}{0.90,0.90,0.90}
%\definecolor{CommentColor}{rgb}{0.76,0.45,0.12}
%\definecolor{OutputColor}{rgb}{0.59,0.00,0.59}

\definecolor{IdentifierColor}{rgb}{0.15,0.15,0.50}
\newcommand{\ID}[1]{{\color{IdentifierColor}#1}}

\definecolor{PuncColor}{rgb}{0.52,0.24,0.14}
\newcommand{\PN}[1]{{\color{PuncColor}#1}}

\definecolor{KeywordColor}{rgb}{0.52,0.24,0.14}
\newcommand{\KY}[1]{{\color{KeywordColor}#1}}

\definecolor{ValueColor}{rgb}{0.13,0.55,0.13}
\newcommand{\VL}[1]{{\color{ValueColor}#1}}

\definecolor{ResultColor}{rgb}{0.10,0.10,0.79}
\newcommand{\RE}[1]{{\color{ResultColor}#1}}

\definecolor{ErrorColor}{rgb}{0.75,0.10,0.10}
\newcommand{\EO}[1]{{\color{ErrorColor}#1}}


\usepackage{listings}
\lstset%
  {language=Lisp
  ,upquote=true
  ,mathescape=true
  ,basicstyle=\ttfamily\color{PuncColor}
  ,alsoletter=+-*/?'\#0123456789^:
  ,identifierstyle=\color{IdentifierColor}
  ,keywords=
    {define,let,match,if
    ,do,define-monad,for/monad+
    ,\#lang
    ,\#:when
    ,\#:unless
    }
  ,keywordstyle=\color{KeywordColor}
  ,emph=
    {return,bind
    ,zero?
    ,ask-env,local-env
    ,ext,find,alloc
    ,get-store,put-store,update-store
    ,tell
    ,get-dead,put-dead,update-dead
    ,fail,mplus
    ,get-,put-,update-
    ,ask-,local-
    ,get-path-cond,refine
    ,ask-cache-in,local-cache-in
    ,get-cache-out,put-cache-out,update-cache-out
    }
  ,emphstyle=\color{IdentifierColor}\emph
  ,literate=
    {‹λ›}{{{\KY{«\uplambda»}}}}1
    {‹δ›}{{{\ID{«\updelta»}}}}1
    {‹σ›}{{{\ID{«\upsigma»}}}}1
    {‹ς›}{{{\ID{«\varsigma»}}}}1
    {‹ρ›}{{{\ID{«\uprho»}}}}1
    {‹φ›}{{{\ID{«\upphi»}}}}1
    {‹θ›}{{{\ID{«\uptheta»}}}}1
    {‹Σ›}{{{\ssmall\ID{«Σ»}}}}1
    {‹∅›}{{{\ID{«∅»}}}}1
    {‹←›}{{{\scriptsize«←»}}}1
    {‹≔›}{{{\scriptsize«≔»}}}1
    {‹₀›}{{{\ID{«\,⸤⦑0⦒⸥»}}}}1
    {‹₁›}{{{\ID{«\,⸤⦑1⦒⸥»}}}}1
    {‹₂›}{{{\ID{«\,⸤⦑2⦒⸥»}}}}1
    {‹′›}{{{\ID{«\,′»}}}}1
    {‹¢›}{{{\ID{\$}}}}1
    {‹∈›}{{{\ID{«∈»}}}}1
    {‹×›}{{{\ssmall\ID{«×»}}}}1
    {‹⊥›}{{{\ssmall\ID{«⊥»}}}}1
    {‹¬›}{{{\ssmall\ID{«¬»}}}}1
    {‹ᴵ›}{{{\ID{\,«⸢⦑I⦒⸣»}}}}1
    {‹ᴼ›}{{{\ID{\,«⸢⦑O⦒⸣»}}}}1
    {‹⁺›}{{{\ID{\,«⸢⦑+⦒⸣»}}}}1
    {‹⸢›in‹⸣›}{{{\ID{«⸢⦑in⦒⸣»}}}}1
    {‹⸢›out‹⸣›}{{{\ID{«⸢⦑out⦒⸣»}}}}2
    {`}{{{\`{}}}}1
    {get-‹¢›}{{{\ID{\emph{get-\$}}}}}5
    {put-‹¢›}{{{\ID{\emph{put-\$}}}}}5
    {update-‹¢›}{{{\ID{\emph{update-\$}}}}}8
    {=}{{{\ID{=}}}}1
  ,classoffset=1
  ,keywords=
    {'add1,'sub1,'+,'-,'*,'/,'failure,'N
    ,\#t,\#f,0,1,2,3,4,5,6,7,8,9
    }
  ,keywordstyle=\color{ValueColor}
  }
\lstdefinestyle{result}
  {basicstyle=\ttfamily\color{ResultColor}
  ,keywordstyle=\color{ResultColor}
  ,identifierstyle=\color{ResultColor}
  ,literate=
    {‹λ›}{{{«\uplambda»}}}1
    {‹δ›}{{{«\updelta»}}}1
    {‹σ›}{{{«\upsigma»}}}1
    {‹ς›}{{{«\varsigma»}}}1
    {‹ρ›}{{{«\uprho»}}}1
    {‹φ›}{{{«\upphi»}}}1
    {‹θ›}{{{«\uptheta»}}}1
    {‹Σ›}{{{\ssmall«Σ»}}}1
    {‹∅›}{{{«∅»}}}1
    {‹←›}{{{«←»}}}1
    {‹≔›}{{{«≔»}}}1
    {‹₀›}{{{«\,⸤⦑0⦒⸥»}}}1
    {‹₁›}{{{«\,⸤⦑1⦒⸥»}}}1
    {‹₂›}{{{«\,⸤⦑2⦒⸥»}}}1
    {‹′›}{{{«\,′»}}}1
    {‹¢›}{{{\$}}}1
    {‹∈›}{{{«∈»}}}1
    {‹×›}{{{\ssmall«×»}}}1
    {‹⊥›}{{{\ssmall«⊥»}}}1
    {‹¬›}{{{\ssmall«¬»}}}1
    {timeout}{{{\EO{\emph{\textbf{timeout}}}}}}7
  }

\newcommand{\rfloat}[1]{\begin{flushright}\fbox{#1}\end{flushright}\vspace{-2.1em}}
\newcommand{\resultskip}{\vspace{-1.2em}}
\newcommand{\figskip}{\vspace{-1.3em}}
\newcommand{\up}[1]{\overbrace{\vphantom{X^X}#1}}
\newcommand{\mathgobble}{-0.25em}
\newcommand{\monadgobble}{-0.5em}

\begin{document}

% <<From Sigplan Template

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

%\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
%\copyrightyear{20yy}
%\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
%\copyrightdoi{nnnnnnn.nnnnnnn}

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

% >>

\title{Abstracting Definitional Interpreters}
%\subtitle{Subtitle Text, if any}

\authorinfo{}{}{}
%\authorinfo{David Darais}
%           {University of Maryland}
%           {darais@cs.umd.edu}
%\authorinfo{Nicholas Labich}
%           {University of Maryland}
%           {labichn@cs.umd.edu}
%\authorinfo{Phúc C. Nguyễn}
%           {University of Maryland}
%           {pcn@cs.umd.edu}
%\authorinfo{David Van Horn}
%           {University of Maryland}
%           {dvanhorn@cs.umd.edu}

\maketitle

\begin{abstract}
In this paper we show that definitional interpreters for programming languages
can express not only the usual notion of interpretation, but also a wide
variety of collecting semantics, abstract interpretations, symbolic executions
and their intermixings.
%
To achieve this we reconstruct a standard definitional interpreter using two
new ingredients: monadic operations and open recursion.
%
The resulting definitional \emph{abstract} interpreter is extensible and we
recover various abstract semantics through its instantiations.

In addition to recovering well-known abstractions, we show that the resulting
abstract interpreter is perfectly precise in modeling call and return flows,
\emph{i.e.} it implements Pushdown Control Flow Analysis (PDCFA).
%
True to the definitional style of Reynolds, the abstract interpreter contains
no explicit mechanics to achieve this property; it is simply inherited from the
defining metalanguage.

In addition to demonstrating our technique, we formalize a systematic
methodology for deriving definitional abstract interpreters, prove it sound,
and make precise its relationship to PDCFA.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}
%\terms term1, term2
%\keywords keyword1, keyword2

\input{01-intro.tex}
\input{02-aam.tex}
\input{03-interp.tex}
\input{04-cache.tex}
\input{05-reynolds.tex}
\input{06-widening.tex}
\input{07-alt-abstraction.tex}
\input{08-symbolic-execution.tex}
\input{09-try-it.tex}
\input{10-formalism.tex}
\input{11-related-work.tex}
\input{12-conclusions.tex}

%\appendix
%\section{Appendix Title}

%\acks
% We thank Sam Tobin-Hochstadt and Dionna Glaze for several fruitful
% conversations while developing the ideas in this work.

\balance
\bibliographystyle{abbrvnat}
\bibliography{davdar,dvanhorn,local}

\end{document}

%\lstset
% {language=Lisp
% ,extendedchars=true
% ,inputencoding=utf8
% ,mathescape=true
% ,escapechar=`
% ,upquote=true
% ,basicstyle=\ttfamily\color{ParenColor}
% ,commentstyle=\color{CommentColor}
% ,alsoletter=+-*/?'\#0123456789^
% ,identifierstyle=\color{IdentifierColor}
% ,emph=%
%  {return,bind
%  ,zero?
%  ,ask-env,local-env
%  ,ext,find,alloc
%  ,get-store,put-store,update-store
%  ,tell
%  ,get-dead,put-dead,update-dead
%  ,fail,mplus
%  ,get-,put-,update-
%  ,ask-,local-
%  }
% ,emphstyle=\color{IdentifierColor}\emph
% ,classoffset=1
% ,keywords={'add1,'sub1,'+,'-,'*,'/,'failure,'N,\#t,\#f,0,1,2,3,4,5,6,7,8,9}
% ,keywordstyle=\color{ValueColor}
% }

