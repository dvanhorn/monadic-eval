\section{A Definitional Interpreter}\label{s:interp}

We begin by constructing a definitional interpreter for a small but
representative higher-order, functional language.  As our defining language, we
use an applicative subset of Racket, a dialect of Scheme.\footnote{This choice
is largely immaterial: any functional language would do.} The abstract syntax
of the language is defined in Figure~\ref{f:syntax}; it includes variables,
numbers, unary and binary operations on numbers, conditionals, {\tt letrec}
expressions, functions and applications.

\begin{figure} %{-{
\rfloat{⸨ev@⸩}
\begin{lstlisting}
¦ (define ((ev ev) e)
¦   (match e
¦     [(num n) (return n)]
¦     [(vbl x)
¦      (do ρ ← ask-env
¦          (find (ρ x)))]    
¦     [(ifz e₀ e₁ e₂) 
¦      (do v  ← (ev e₀)
¦          z? ← (zero? v)
¦          (ev (if z? e₁ e₂)))]
¦     [(op1 o e₀)
¦      (do v ← (ev e₀)
¦          (δ o v))]   
¦     [(op2 o e₀ e₁)
¦      (do v₀ ← (ev e₀)
¦          v₁ ← (ev e₁)
¦          (δ o v₀ v₁))]
¦     [(rec f e₀ e₁) 
¦      (do ρ  ← ask-env
¦          a  ← (alloc f)
¦          ρ′ ≔ (ρ f a)
¦          (ext a (cons e₀ ρ′))
¦          (local-env ρ′
¦            (ev e₁)))]
¦     [(lam x e₀)
¦      (do ρ ← ask-env
¦          (return (cons (lam x e₀) ρ)))]
¦     [(app e₀ e₁)
¦      (do (cons (lam x e₂) ρ) ← (ev e₀)
¦          v₁ ← (ev e₁)
¦          a  ← (alloc x)         
¦          (ext a v₁)
¦          (local-env (ρ x a) 
¦            (ev e₂)))]))
\end{lstlisting}
\caption{The Extensible Definitional Interpreter}
\label{f:interpreter}
\end{figure} %}-}

The interpreter for the language is defined in Figure~\ref{f:interpreter}. At
first glance, it has many conventional aspects:
\begin{itemize}
\item It is compositionally defined by structural recursion on the syntax of
expressions.
\item It represents function values as a closure data structure which pairs the
lambda term with the evaluation environment.
\item It is structured monadically and uses monad operations to interact with
the environment and store.
\item It relies on a helper function ⸨δ⸩ to interpret primitive operations.
\end{itemize}
There are a few superficial aspects that deserve a quick note:
environments ⸨ρ⸩ are finite maps and ⸨(ρ«\ »x)⸩ denotes
«ρ(x)» while ⸨(ρ«\ »x a)⸩ denotes «ρ[x↦a]».  The
⸨do⸩-notation is just shorthand for ⸨bind⸩, as usual:
\begin{alignat*}{2}
                𝔥⸨(do x ←«\ »e . r)⸩ ≡ &\mathrel{} 𝔥⸨(bind e (λ«\ »(x) (do . r)))⸩
\\[\mathgobble]        𝔥⸨(do e . r)⸩ ≡ &\mathrel{} 𝔥⸨(bind e (λ«\ »(_) (do . r)))⸩
\\[\mathgobble] 𝔥⸨(do x ≔«\ »e . r)⸩ ≡ &\mathrel{} 𝔥⸨(let ((x e)) (do . r))⸩
\\[\mathgobble]            𝔥⸨(do b)⸩ ≡ &\mathrel{} 𝔥⸨b⸩
\end{alignat*}
Finally, there are two unconventional aspects worth noting.

First, the interpreter is written in an \emph{open recursive style}; the
evaluator does not call itself recursively, instead it takes as an argument a
function ⸨ev⸩—shadowing the name of the function ⸨ev⸩ being defined—and ⸨ev⸩
(the argument) is called instead of self-recursion.  This is a standard
encoding for recursive functions in a setting without recursive binding.  It is
up to an external function, such as the Y-combinator, to close the recursive
loop.  This open recursive form is crucial for our purposes in that it allows
intercepting recursive calls to perform “deep” instrumentation of the
interpreter.

Second, the code is clearly \emph{incomplete}.  There are a number of free
variables, noted in italics, which must implement the following:
\begin{itemize}
\item The underlying monad of the interpreter: ⸨return⸩ and ⸨bind⸩;
\item An interpretation of primitives: ⸨δ⸩ and ⸨zero?⸩;
\item Environment operations: ⸨ask-env⸩ for retrieving the
environment and ⸨local-env⸩ for installing an environment;
\item Store operations: ⸨ext⸩ for updating the store, and ⸨find⸩ for
dereferencing locations; and
\item An operation for ⸨alloc⸩ating new store locations.
\end{itemize}
Going forward, we make frequent use of definitions involving free variables,
and we call such a collection of such definitions a \emph{component}. We assume
components can be named (in this case, we've named the component ⸨ev@⸩,
indicated by the box in the upper-right corner) and linked together to
eliminate free variables.\footnote{We use Racket
\emph{units}~\cite{local:flatt-pldi98} to model components in our
implementation.}

\begin{figure} %{-{
\rfloat{⸨monad@⸩}
\begin{flalign*}
                  & 𝔥⸨(define-monad⸩ 
& \\[\monadgobble]& ␣␣𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨ID))))⸩ 
& \end{flalign*}
\figskip\rfloat{⸨δ@⸩}
\begin{lstlisting}
¦ (define (δ . ovs)
¦   (match ovs
¦     [(list 'add1 n)  (return (add1 n))]
¦     [(list 'sub1 n)  (return (sub1 n))]
¦     [(list '- n)     (return (- n))]
¦     [(list '+ n₀ n₁) (return (+ n₀ n₁))]
¦     [(list '- n₀ n₁) (return (- n₀ n₁))]
¦     [(list '* n₀ n₁) (return (* n₀ n₁))]
¦     [(list '/ n₀ n₁)
¦      (if (= 0 n₁)
¦          fail
¦          (return (/ n₀ n₁)))]))
¦ (define (zero? v)
¦   (return (= 0 v)))
\end{lstlisting}
\figskip\rfloat{⸨store@⸩}
\begin{lstlisting}
¦ (define (find a)
¦   (do σ ← get-store
¦       (return (σ a))))
¦ (define (ext a v) 
¦   (update-store (λ (σ) (σ a v))))
\end{lstlisting}
\figskip\rfloat{⸨alloc@⸩}
\begin{lstlisting}
¦ (define (alloc x)
¦   (do σ ← get-store
¦       (return (size σ))))
\end{lstlisting}
\caption{Components for Definitional Interpreters}
\label{f:concrete-components}
\end{figure} %}-}

\subsection{Instantiating the Interpreter}

Next we examine a set of components which complete the definitional
interpreter, defined in Figure~\ref{f:concrete-components}. The first component
is ⸨monad@⸩, which uses our ⸨define-monad⸩ macro to generate a set of bindings
based on a monad transformer stack.  For this interpreter, we use a failure
monad to model divide-by-zero errors, a state monad to model the store, and a
reader monad to model the environment.  The ⸨define-monad⸩ form generates
bindings for ⸨return⸩, ⸨bind⸩, ⸨ask-env⸩, ⸨local-env⸩, ⸨get-store⸩ and
⸨update-store⸩, and their definitions are
standard~\cite{dvanhorn:Liang1995Monad}. 

We also add the ⸨mrun⸩ operation for running monadic computations, starting
with the empty environment and store ⸨∅⸩:
\begin{lstlisting}
¦ (define (mrun m)
¦   (run-StateT ∅ (run-ReaderT ∅ m)))
\end{lstlisting}
While the ⸨define-monad⸩ form is hiding some details, this component could have
equivalently been written out explicitly. For example, ⸨return⸩ and ⸨bind⸩ can
be defined as:
\begin{lstlisting}
¦ (define (((return a) r) s) (cons a s))
¦ (define (((bind ma f) r) s)
¦   (match ((ma r) s)
¦     [(cons a s′) (((f a) r) s′)]
¦     ['failure 'failure]))
\end{lstlisting}
The remaining operations are similarly straightforward.  So far our use of
monad transformers can be seen as a mere convenience, but the monad abstraction
will become essential for deriving new analyses later on.

The ⸨δ@⸩ component defines the interpretation of primitives, which is given in
terms of the underlying monad.  Finally the ⸨alloc@⸩ component provides a
definition of ⸨alloc⸩, which fetches the store and uses its size to return a
fresh address (assuming the invariant «𝔥⸨(∈«\ »a σ)⸩ ⇔ 𝔥⸨a⸩ < 𝔥⸨(size σ)⸩»).
The ⸨store@⸩ component defines ⸨find⸩ and ⸨ext⸩ for finding and extending the
store in terms of the monadic operations.

The only remaining pieces of the puzzle are a fixed-point combinator, which is
straightforward to define:
\begin{lstlisting}
¦ (define ((fix f) x) ((f (fix f)) x))
\end{lstlisting}
and the main entry-point for the interpreter:
\begin{lstlisting}
¦ (define (eval e) (mrun ((fix ev) e)))
\end{lstlisting}
By taking advantage of Racket's languages-as-libraries
features~\cite{dvanhorn:TobinHochstadt2011Languages}, we construct REPLs for
interacting with this interpreter.  Here are a few examples, which make use of
a concrete syntax for more succinctly writing expressions. The identity
function evaluates to an answer consisting of a closure over the empty
environment together with the empty store:
ℑ⁅
¦ > (λ (x) x)
ℑ,
¦ '(((λ (x) x) . ()) . ())
ℑ⁆
Here's an example showing a non-empty environment and store:
ℑ⁅
¦ > ((λ (x) (λ (y) x)) 4)
ℑ,
¦ '(((λ (y) x) . ((x . 0))) . ((0 . 4)))
ℑ⁆
Primitive operations work as expected:
ℑ⁅
¦ > (* (+ 3 4) 9)
ℑ,
¦ '(63 . ())
ℑ⁆
And divide-by-zero errors result in failures:
ℑ⁅
¦ > (/ 5 (- 3 3))
ℑ,
¦ '(failure . ())
ℑ⁆
Because our monad stack places ⸨FailT⸩ above ⸨StateT⸩, the answer includes the
(empty) store at the point of the error. Had we changed ⸨monad@⸩ to use:
\begin{alignat*}{1}
& ␣␣𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨ID))))⸩
\end{alignat*}
failures would not include the store:
ℑ⁅
¦ > (/ 5 (- 3 3))
ℑ,
¦ 'failure
ℑ⁆
At this point we've defined a simple definitional interpreter, although the
extensible components involved—monadic operations and open recursion—will allow
us to instantiate the same interpreter to achieve a wide range of useful
abstract interpretations.

\subsection{Collecting Variations}\label{s:collecting}

The formal development of abstract interpretation often starts from a so-called
``non-standard collecting semantics.''  A common form of collecting semantics
is a trace semantics, which collects streams of states the interpreter reaches.
Figure~\ref{f:trace} shows the monad stack for a tracing interpreter and a
``mix-in'' for the evaluator.  The monad stack adds ⸨WriterT⸩ using ⸨List⸩,
which provides a new operation ⸨tell⸩ for writing items to the stream of
reached states.  The ⸨ev-trace⸩ function is a wrapper around an underlying
⸨ev₀⸩ unfixed evaluator, and interposes itself between each recursive call by
⸨tell⸩ing the current state of the evaluator, that is the current expression,
environment, and store.  The top-level evaluation function is then:
\begin{lstlisting}
¦ (define (eval e) 
¦   (mrun ((fix (ev-tell ev)) e)))
\end{lstlisting}

\begin{figure} %{-{
\rfloat{⸨trace-monad@⸩}
\begin{flalign*}
                  & 𝔥⸨(define-monad⸩
& \\[\monadgobble]& ␣␣𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨WriterT List⸩}⸢traces⸣\ 𝔥⸨ID)))))⸩
& \end{flalign*}
\figskip\rfloat{⸨ev-tell@⸩}
\begin{lstlisting}
¦ (define (((ev-tell ev₀) ev) e)
¦   (do ρ ← ask-env
¦       σ ← get-store
¦       (tell (list e ρ σ))
¦       ((ev₀ ev) e)))
\end{lstlisting}
\caption{Trace Collecting Semantics}
\label{f:trace}
\end{figure} %}-}

Now when an expression is evaluated, we get the resulting answer and a list of
all the states seen by the evaluator, in the order in which they were seen. For
example:
ℑ⁅
¦ > (* (+ 3 4) 9)
ℑ,
¦ '((63 . ())    
¦   ((* (+ 3 4) 9)()())    ((+ 3 4)()()) 
¦   (3()())    (4()())    (9()()))
ℑ⁆
% ℑ⁅
% ¦ > ((λ (x) (λ (y) x)) 4)
% ℑ,
% ¦ '((((λ (y) x) . ((x . 0))) . ((0 . 4)))
% ¦   (((λ (x) (λ (y) x)) 4) () ())
% ¦   ((λ (x) (λ (y) x)) () ())
% ¦   (4 () ())
% ¦   ((λ (y) x) ((x . 0)) ((0 . 4))))
% ℑ⁆
Were we to swap ⸨List⸩ with ⸨Set⸩ in the monad stack, we would obtain a
\emph{reachable} state semantics, another common form of collecting semantics,
that loses the order and repetition of states.

As another collecting semantics variant, we show how to collect the \emph{dead
code} in a program.  Here we use a monad stack that has an additional state
component (with operations named ⸨put-dead⸩ and ⸨get-dead⸩) which stores the
set of dead expressions.  Initially this will contain all of the subexpressions
of the program.  As the interpreter recurs through expressions it will remove
them from the dead set.

Figure~\ref{f:dead} defines the monad stack for the dead code collecting
semantics and the ⸨ev-dead@⸩ component, another mix-in for an ⸨ev₀⸩ evaluator
to remove the given subexpression before recurring.  Since computing the dead
code requires an outer wrapper that sets the initial set of dead code to be all
of the subexpressions in the program, we define ⸨eval-dead@⸩ which consumes a
\emph{closed evaluator}, i.e. something of the form ⸨(fix ev)⸩.

Putting these pieces together, the dead code collecting semantics is defined:
\begin{lstlisting}
¦ (define (eval e)
¦   (mrun ((eval-dead (fix (ev-dead ev))) e)))
\end{lstlisting}
Running a program with the dead code interpreter produces an answer and the set
of expressions that were not evaluated during the running of a program:
ℑ⁅
¦ > (if0 0 1 2)
ℑ,
¦ (cons '(1 . ()) (set 2))
ℑ;
¦ > (* (+ 3 4) 9)
ℑ,
¦ (cons '(63 . ()) (set))
ℑ;
¦ > (λ (x) x)
ℑ,
¦ (cons '(((λ (x) x) . ()) . ()) (set 'x))
ℑ;
¦ > (if0 (/ 1 0) 2 3)]
ℑ,
¦ (cons '(failure . ()) (set 3 2))
ℑ⁆

\begin{figure} %{-{
\rfloat{⸨dead-monad@⸩}
\begin{flalign*}
          & 𝔥⸨(define-monad⸩
& \\[\monadgobble]& ␣␣𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢dead⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨ID)))))⸩
& \end{flalign*}
\figskip\rfloat{⸨ev-dead@⸩}
\begin{lstlisting}
¦ (define (((ev-dead ev₀) ev) e)
¦   (do θ  ← get-dead       
¦       (put-dead (set-remove θ e))
¦       ((ev₀ ev) e)))
\end{lstlisting}
\figskip\rfloat{⸨eval-dead@⸩}
\begin{lstlisting}
¦ (define ((eval-dead eval) e₀)
¦   (do (put-dead (subexps e₀))
¦       (eval e₀)))
\end{lstlisting}
\caption{Dead Code Collecting Semantics}
\label{f:dead}
\end{figure} %}-}

Our setup makes it easy not only to express the concrete interpreter, but also
different forms of collecting semantics. Let us now look at abstractions.

\subsection{Abstracting Base Values}\label{s:base}

Our interpreter must become decidable before it can be considered an analysis,
and the first step towards decidability is to abstract the base types of the
language to something finite. We do this for our number base type by
introducing a new \emph{abstract} number, written ⸨'N⸩, which represents the
set of all numbers. Abstract numbers are introduced by an alternative
interpretation of primitive operations, given in Figure~\ref{f:abs-delta},
which simply produces ⸨'N⸩ in all cases. 

Some care must be taken in the abstract interpretation of ⸨'/⸩. If the
denominator is the abstract number ⸨'N⸩, then it is possible the program could
fail as a result of divide-by-zero, since ⸨0⸩ is contained in the
representation of ⸨'N⸩. Therefore there are \emph{two} possible answers when
the denominator is ⸨'N⸩: ⸨'N⸩ and ⸨'failure⸩. Both answers are ⸨return⸩ed by
introducing non-determinism ⸨NondetT⸩ into the monad stack ⸨monad^@⸩.
Adding non-determinism provides the ⸨mplus⸩ operation for combining multiple
answers. Non-determinism is also used in the implementation of ⸨zero?⸩, which
returns both true and false on ⸨'N⸩.

\begin{figure} %{-{
\rfloat{⸨monad^@⸩}
\begin{flalign*}
                  & 𝔥⸨(define-monad⸩
& \\[\monadgobble]& ␣␣𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣𝔥\ 𝔥⸨(⸩\!\up{𝔥⸨NondetT⸩}⸢mplus⸣\ 𝔥⸨ID)))))⸩
& \end{flalign*}
\figskip\rfloat{⸨δ^@⸩}
\begin{lstlisting}
¦ (define (δ . ovs)
¦   (match ovs
¦     [(list 'add1 n)  (return 'N)]
¦     [(list '+ n₀ n₁) (return 'N)]
¦     [(list '/ n₀ (? number? n₁))
¦      (if (= 0 n₁) fail (return 'N))]
¦     [(list '/ n₀ 'N)
¦      (mplus fail (return 'N))] ... ))
¦ (define (zero? v)
¦   (match v
¦     ['N (mplus (return #t) (return #f))]
¦     [_  (return (= 0 v))]))
\end{lstlisting}
\caption{Abstracting Primitive Operations}
\label{f:abs-delta}
\end{figure} %}-}

By linking together ⸨δ^@⸩ and the monad stack with non-determinism, we obtain
an evaluator that produces a set of results:
ℑ⁅
¦ > (* (+ 3 4) 9)
ℑ,
¦ '((N . ()))
ℑ;
¦ > (/ 5 (add1 2))
ℑ,
¦ '((failure . ()) (N . ()))
ℑ;
¦ > (if0 (add1 0) 3 4)
ℑ,
¦ '((3 . ()) (4 . ()))
ℑ⁆
If we link ⸨δ^@⸩ with the \emph{tracing} monad stack plus non-determinism:
\begin{alignat*}{1}
                 & 𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨WriterT List⸩}⸢traces⸣
\\[\monadgobble] & ␣␣𝔥⸨(⸩\!\up{𝔥⸨NondetT⸩}⸢mplus⸣\ 𝔥⸨ID)))))⸩
\end{alignat*}
we get an evaluator that produces sets of traces:
ℑ⁅
¦ > (if0 (add1 0) 3 4)
ℑ,
¦ (set '((3 . ())
¦        ((if0 (add1 0) 3 4) () ())
¦        ((add1 0) () ())    (0 () ())    (3 () ()))    
¦      '((4 . ())
¦        ((if0 (add1 0) 3 4) () ())
¦        ((add1 0) () ())    (0 () ())    (4 () ())))
ℑ⁆

It is clear that the interpreter will only ever see a finite set of numbers
(including ⸨'N⸩), but it's definitely not true that the interpreter halts on
all inputs.  First, it's still possible to generate an infinite number of
closures.  Second, there's no way for the interpreter to detect when it sees a
loop.  To make a terminating abstract interpreter requires tackling both.  We
look next at abstracting closures.

\subsection{Abstracting Closures}

Closures consist of code---a lambda term---and an environment---a finite map
from variables to addresses.  Since the set of lambda terms and variables is
bounded by the program text, it suffices to finitize closures by finitizing the
set of addresses.  Following the AAM approach, we do this by modifying the
allocation function produce elements drawn from a finite set.  In order to
retain soundness in the semantics, we modify the store to map addresses to
\emph{sets} of values, model store update as a join, and model dereference as a
non-deterministic choice.

Any abstraction of the allocation function that produces a finite set will do,
but the choice of abstraction will determine the precision of the resulting
analysis.  A simple choice is to allocate variables using the variable's name
as its address.  This gives a monomorphic, or 0CFA-like, abstraction.

Figure~\ref{f:0cfa-abs} shows the component ⸨alloc^@⸩ which implements
monomorphic allocation, and the component ⸨store-nd@⸩ for implementing ⸨find⸩
and ⸨ext⸩ which interact with a store mapping to \emph{sets} of values. The
⸨for/monad+⸩ form is a convenience for combining a set of computations with
⸨mplus⸩, and is used so ⸨find⸩ returns \emph{all} of the values in the store at
a given address.  The ⸨ext⸩ function joins whenever an address is already
allocated, otherwise it maps the address to a singleton set.

\begin{figure} %{-{
\rfloat{⸨alloc^@⸩}
\begin{lstlisting}
¦ (define (alloc x) (return x))
\end{lstlisting}
\figskip\rfloat{⸨store-nd@⸩}
\begin{lstlisting}
¦ (define (find a)
¦   (do σ ← get-store
¦       (for/monad+ ([v (σ a)])
¦         (return v))))
¦ (define (ext a v)
¦   (update-store
¦     (λ (σ) (σ a (if (∈ a σ) 
¦                     (set-add (σ a) v) 
¦                     (set v))))))
\end{lstlisting}
\caption{Abstracting Allocation: 0CFA}
\label{f:0cfa-abs}
\end{figure} %}-}

By linking these components with the same monad stack from before, we obtain an
interpreter that loses precision whenever variables are bound to multiple
values.  For example, this program binds ⸨x⸩ to both ⸨0⸩ and ⸨1⸩ and therefore
produces both answers when run:
ℑ⁅
¦ > (let f (λ (x) x)
¦     (let _ (f 0) (f 1)))]
ℑ,
¦ '((0 . ((x 1 0) (f ((λ (x) x) . ()))))
¦   (1 . ((x 1 0) (f ((λ (x) x) . ())))))
ℑ⁆
Our abstract interpreter now has a truly finite domain; the next step is to
detect loops in the state-space to achieve termination.
