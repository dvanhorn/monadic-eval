\section{A Definitional Interpreter}\label{s:interp}

\begin{wrapfigure}{R}{0.5\textwidth} %{{{ f:syntax
  \begin{mdframed}
    \begin{alignat*}{4}
      e ∈ &&\mathrel{}   exp ⩴ &\mathrel{} 𝔥⸨(vbl⸩\ x𝔥⸨)⸩         &\hspace{3em} [⦑\emph{variable}⦒]
      \\[\mathgobble]     &&\mathrel{}       ∣ &\mathrel{} 𝔥⸨(num⸩\ n𝔥⸨)⸩         &\hspace{3em} [⦑\emph{number}⦒]
      \\[\mathgobble]     &&\mathrel{}       ∣ &\mathrel{} 𝔥⸨(if0⸩\ e\ e\ e𝔥⸨)⸩   &\hspace{3em} [⦑\emph{conditional}⦒]
      \\[\mathgobble]     &&\mathrel{}       ∣ &\mathrel{} 𝔥⸨(op2⸩\ b\ e\ e𝔥⸨)⸩   &\hspace{3em} [⦑\emph{binary op}⦒]
      \\[\mathgobble]     &&\mathrel{}       ∣ &\mathrel{} 𝔥⸨(app⸩\ e\ e𝔥⸨)⸩      &\hspace{3em} [⦑\emph{application}⦒]
      \\[\mathgobble]     &&\mathrel{}       ∣ &\mathrel{} 𝔥⸨(rec⸩\ x\ ℓ\ e𝔥⸨)⸩   &\hspace{3em} [⦑\emph{letrec}⦒]
      \\[\mathgobble]     &&\mathrel{}       ∣ &\mathrel{} ℓ                     &\hspace{3em} [⦑\emph{lambda}⦒]
      \\[\mathgobble]ℓ ∈ &&\mathrel{}   lam ⩴ &\mathrel{} 𝔥⸨(lam⸩\ x\ e𝔥⸨)⸩      &\hspace{3em} [⦑\emph{function defn}⦒]
      \\[\mathgobble] x ∈ &&\mathrel{}   var ≔ &\mathrel{} ❴𝔥⸨x⸩, 𝔥⸨y⸩, …❵        &\hspace{3em} [⦑\emph{variable names}⦒]
      %\\[\mathgobble] u ∈ &&\mathrel{}  unop ≔ &\mathrel{} ❴𝔥⸨add1⸩, …❵           &\hspace{3em} [⦑\emph{unary prim}⦒]
      \\[\mathgobble] b ∈ &&\mathrel{} binop ≔ &\mathrel{} ❴𝔥⸨+⸩, 𝔥⸨-⸩, …❵        &\hspace{3em} [⦑\emph{binary prim}⦒]
    \end{alignat*}
    \captionskip{Programming Language Syntax}
    \label{f:syntax}
  \end{mdframed}
\end{wrapfigure} %}}}



We begin by constructing a definitional interpreter for a small but
representative higher-order, functional language.  The abstract syntax
of the language is defined in Figure~\ref{f:syntax}; it includes variables,
numbers, binary operations on numbers, conditionals, {\tt letrec} expressions,
functions and applications.

The interpreter for the language is defined in
Figure~\ref{f:interpreter}. At first glance, it has many conventional
aspects: it is compositionally defined by structural recursion on the
syntax of expressions; it represents function values as a closure data
structure which pairs the lambda term with the evaluation environment;
it is structured monadically and uses monad operations to interact
with the environment and store; and it relies on a helper function ⸨δ⸩
to interpret primitive operations.

There are a few superficial aspects that deserve a quick note:
environments ⸨ρ⸩ are finite maps and the syntax ⸨(ρ«\ »x)⸩ denotes
«ρ(x)» while ⸨(ρ«\ »x a)⸩ denotes «ρ[x↦a]».  For simplicity, recursive function
definitions (⸨rec⸩) are assumed to be syntactic values.  The
⸨do⸩-notation is just shorthand for ⸨bind⸩, as usual:
\begin{alignat*}{2}
                𝔥⸨(do x ←«\ »e . r)⸩ ≡ &\mathrel{} 𝔥⸨(bind e (λ«\ »(x) (do . r)))⸩
\\[\mathgobble]        𝔥⸨(do e . r)⸩ ≡ &\mathrel{} 𝔥⸨(bind e (λ«\ »(_) (do . r)))⸩
\\[\mathgobble] 𝔥⸨(do x ≔«\ »e . r)⸩ ≡ &\mathrel{} 𝔥⸨(let ((x e)) (do . r))⸩
\\[\mathgobble]            𝔥⸨(do b)⸩ ≡ &\mathrel{} 𝔥⸨b⸩
\end{alignat*}
Finally, there are two unconventional aspects worth noting.


First, the interpreter is written in an \emph{open recursive style}; the
evaluator does not call itself recursively, instead it takes as an argument a
function ⸨ev⸩—shadowing the name of the function ⸨ev⸩ being defined—and ⸨ev⸩
(the argument) is called instead of self-recursion.  This is a standard
encoding for recursive functions in a setting without recursive binding.  It is
up to an external function, such as the Y-combinator, to close the recursive
loop.  This open recursive form is crucial because it allows intercepting
recursive calls to perform “deep” instrumentation of the interpreter.

Second, the code is clearly \emph{incomplete}.  There are a number of free
variables, typeset as italics, which implement the following:
\begin{itemize}
\item The underlying monad of the interpreter: ⸨return⸩ and ⸨bind⸩;
\item An interpretation of primitives: ⸨δ⸩ and ⸨zero?⸩;
\item Environment operations: ⸨ask-env⸩ for retrieving the
environment and ⸨local-env⸩ for installing an environment;
\item Store operations: ⸨ext⸩ for updating the store, and ⸨find⸩ for
dereferencing locations; and
\item An operation for ⸨alloc⸩ating new store locations.
\end{itemize}
Going forward, we make frequent use of definitions involving free variables,
and we call such a collection of such definitions a \emph{component}. We assume
components can be named (in this case, we've named the component ⸨ev@⸩,
indicated by the box in the upper-right corner) and linked together to
eliminate free variables.\footnote{We use Racket
\emph{units}~\cite{local:flatt-pldi98} to model components in our
implementation.}

%% HACK: the explicit number of short lines is because the equations
%% seem to screw up the calculation.  This shit is totally fragile and
%% has to be adjusted whenever things shift.
\begin{wrapfigure}[26]{R}{0.5\textwidth} %{{{
\begin{mdframed}
\rfloat{⸨ev@⸩}
\begin{lstlisting}
¦ (define ((ev ev) e)
¦   (match e
¦     [(num n)
¦      (return n)]
¦     [(vbl x)
¦      (do ρ ← ask-env
¦          (find (ρ x)))]    
¦     [(if0 e₀ e₁ e₂)
¦      (do v  ← (ev e₀)  z? ← (zero? v)
¦          (ev (if z? e₁ e₂)))]
¦     [(op2 o e₀ e₁)
¦      (do v₀ ← (ev e₀)  v₁ ← (ev e₁)
¦          (δ o v₀ v₁))]
¦     [(rec f l e)
¦      (do ρ  ← ask-env  a  ← (alloc f)
¦          ρ′ ≔ (ρ f a)
¦          (ext a (cons l ρ′))
¦          (local-env ρ′ (ev e)))]
¦     [(lam x e₀)
¦      (do ρ ← ask-env
¦          (return (cons (lam x e₀) ρ)))]
¦     [(app e₀ e₁)
¦      (do (cons (lam x e₂) ρ) ← (ev e₀)
¦           v₁ ← (ev e₁)
¦           a  ← (alloc x)
¦           (ext a v₁)
¦           (local-env (ρ x a) (ev e₂)))]))
\end{lstlisting}
\captionskip{The Extensible Definitional Interpreter}
\label{f:interpreter}
\end{mdframed}
\end{wrapfigure} %}}}
%¦     [(op1 o e₀)
%¦      (do v ← (ev e₀)
%¦          (δ o v))]   


\subsection{Instantiating the Interpreter}

Next we examine a set of components which complete the definitional
interpreter, shown in Figure~\ref{f:concrete-components}. The first component
⸨monad@⸩ uses a macro ⸨define-monad⸩ which generates a set of bindings based on
a monad transformer stack.  We use a failure monad to model divide-by-zero
errors, a state monad to model the store, and a reader monad to model the
environment.  The ⸨define-monad⸩ form generates bindings for ⸨return⸩, ⸨bind⸩,
⸨ask-env⸩, ⸨local-env⸩, ⸨get-store⸩ and ⸨update-store⸩; their definitions are
standard~\cite{dvanhorn:Liang1995Monad}. 

We also define ⸨mrun⸩ for running monadic computations, starting with the empty
environment and store ⸨∅⸩:

\begin{minipage}{0.4\textwidth}
\begin{alignat*}{1}
  & 𝔥⸨(define (mrun m)⸩\\
  & ␣𝔥⸨(run-StateT ∅⸩\ 𝔥⸨(run-ReaderT ∅⸩\ 𝔥⸨m)))⸩\\
\end{alignat*}
\end{minipage}

\noindent
While the ⸨define-monad⸩ form is hiding some details, this component could have
equivalently been written out explicitly. For example, ⸨return⸩ and ⸨bind⸩ can
be defined as:

\begin{minipage}{0.4\textwidth}
\begin{alignat*}{1}
& 𝔥⸨(define (((return a) r) s) (cons a s))⸩ \\
& 𝔥⸨(define (((bind ma f) r) s)⸩ \\
  &␣𝔥⸨(match ((ma r) s)⸩ \\
    &␣␣𝔥⸨[(cons a s′) (((f a) r) s′)]⸩ \\
    &␣␣𝔥⸨['failure 'failure]))⸩\\
\end{alignat*}
\end{minipage}

\noindent
So far our use of monad transformers is as a mere convenience, however the
monad abstraction will become essential for easily deriving new analyses later
on.

\begin{figure} %{-{
\begin{mdframed}
\rfloat{⸨monad@⸩}
\begin{flalign*}
& 𝔥⸨(define-monad⸩ ␣𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨ID))))⸩ &
\end{flalign*}
\figskip\rfloat{⸨δ@⸩}
\begin{lstlisting}
¦ (define (δ o n₀ n₁)
¦   (match o
¦     ['+ (return (+ n₀ n₁))]
¦     ['- (return (- n₀ n₁))]
¦     ['* (return (* n₀ n₁))]
¦     ['/ (if (= 0 n₁) fail (return (/ n₀ n₁)))]))
¦ (define (zero? v) (return (= 0 v)))
\end{lstlisting}
\figskip\rfloat{⸨store@⸩}
\begin{lstlisting}
¦ (define (find a)  (do σ ← get-store
¦                       (return (σ a))))
¦ (define (ext a v) (update-store (λ (σ) (σ a v))))
\end{lstlisting}
\figskip\rfloat{⸨alloc@⸩}
\begin{lstlisting}
¦ (define (alloc x) (do σ ← get-store
¦                       (return (size σ))))
\end{lstlisting}
\captionskip{Components for Definitional Interpreters}
\label{f:concrete-components}
\end{mdframed}
\end{figure} %}-}

The ⸨δ@⸩ component defines the interpretation of primitives, which is given in
terms of the underlying monad.  
%
The ⸨alloc@⸩ component provides a definition of ⸨alloc⸩, which fetches
the store and uses its size to return a fresh address, assuming the
invariant «𝔥⸨(∈«\ »a σ)⸩ ⇔ 𝔥⸨a⸩ < 𝔥⸨(size σ)⸩».  The ⸨alloc⸩ function
takes a single argument, which is the name of the variable whose
binding is being allocated.  For the time being, it is ignored, but
will become relevant when abstracting closures
(\S\ref{s:abstracting-closures}).
%
The ⸨store@⸩ component defines ⸨find⸩ and ⸨ext⸩ for finding and extending
values in the store.

\begin{figure} %{-{ ␣
\begin{mdframed}
\rfloat{⸨trace-monad@⸩}
\begin{flalign*}
& 𝔥⸨(define-monad⸩ \ 𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨WriterT List⸩}⸢traces⸣\ 𝔥⸨ID)))))⸩
& \end{flalign*}
\figskip\rfloat{⸨ev-tell@⸩}
\begin{lstlisting}
¦ (define (((ev-tell ev₀) ev) e)
¦   (do ρ ← ask-env  σ ← get-store
¦       (tell (list e ρ σ))
¦       ((ev₀ ev) e)))
\end{lstlisting}
\captionskip{Trace Collecting Semantics}
\label{f:trace}
\end{mdframed}
\end{figure} %}-}

The only remaining pieces of the puzzle are a fixed-point combinator and the
main entry-point for the interpreter, which are straightforward to define:
%
\begin{alignat*}{1}
& 𝔥⸨(define ((fix f) x) ((f (fix f)) x))⸩ \\
& 𝔥⸨(define (eval e) (mrun ((fix ev) e)))⸩
\end{alignat*}

%% By taking advantage of Racket's languages-as-libraries
%% features~\cite{dvanhorn:TobinHochstadt2011Languages}, we construct REPLs for
%% interacting with this interpreter.  Here are a few examples, which make use of
%% a concrete syntax for more succinctly writing expressions. The identity
%% function evaluates to a closure over the empty environment paired with the
%% empty store:
%% ℑ⁅
%% ¦ > (λ (x) x)
%% ℑ,
%% ¦ '(((λ (x) x) . ()) . ())
%% ℑ⁆
%% Here's an example showing a non-empty environment and store:
%% ℑ⁅
%% ¦ > ((λ (x) (λ (y) x)) 4)
%% ℑ,
%% ¦ '(((λ (y) x) . ((x . 0))) . ((0 . 4)))
%% ℑ⁆
%% Primitive operations work as expected:
%% ℑ⁅
%% ¦ > (* (+ 3 4) 9)
%% ℑ,
%% ¦ '(63 . ())
%% ℑ⁆
%% And divide-by-zero errors result in failures:
%% ℑ⁅
%% ¦ > (/ 5 (- 3 3))
%% ℑ,
%% ¦ '(failure . ())
%% ℑ⁆

By taking advantage of Racket's languages-as-libraries
features~\cite{dvanhorn:TobinHochstadt2011Languages}, we construct REPLs for
interacting with this interpreter.  Here are a few evaluation examples in a
succinct concrete syntax:
ℑ⁅
¦ > (λ (x) x)              ;; => Closure over the empty environment paired with the empty store.
ℑ,
¦ '(((λ (x) x) . ()) . ())
ℑ;
¦ > ((λ (x) (λ (y) x)) 4)  ;; => Closure over a non-empty environment and store.
ℑ,
¦ '(((λ (y) x) . ((x . 0))) . ((0 . 4)))
ℑ;
¦ > (* (+ 3 4) 9)          ;; Primitive operations work as expected.
ℑ,
¦ '(63 . ())
ℑ;
¦ > (/ 5 (- 3 3))          ;; Divide-by-zero errors result in failures.
ℑ,
¦ '(failure . ())
ℑ⁆
Because our monad stack places ⸨FailT⸩ above ⸨StateT⸩, the answer includes the
(empty) store at the point of the error. Had we changed ⸨monad@⸩ to use
⸨(ReaderT (StateT (FailT ID))))⸩ then failures would not include the store:
ℑ⁅
¦ > (/ 5 (- 3 3))
ℑ,
¦ 'failure
ℑ⁆
At this point we've defined a simple definitional interpreter, although the
extensible components involved—monadic operations and open recursion—will allow
us to instantiate the same interpreter to achieve a wide range of useful
abstract interpretations.

\subsection{Collecting Variations}\label{s:collecting}

The formal development of abstract interpretation often starts from a so-called
``non-standard collecting semantics.''  A common form of collecting semantics
is a trace semantics, which collects streams of states the interpreter reaches.
Figure~\ref{f:trace} shows the monad stack for a tracing interpreter and a
``mix-in'' for the evaluator.  The monad stack adds ⸨WriterT List⸩, which
provides a new operation ⸨tell⸩ for writing lists of items to the stream of
reached states.  The ⸨ev-tell⸩ function is a wrapper around an underlying
⸨ev₀⸩ unfixed evaluator, and interposes itself between each recursive call by
⸨tell⸩ing the current state of the evaluator: the current expression,
environment and store.  The top-level evaluation function is then:
\begin{alignat*}{1}
&𝔥⸨(define (eval e) (mrun ((fix (ev-tell ev)) e)))⸩
\end{alignat*}

Now when an expression is evaluated, we get an answer and a list of all states
seen by the evaluator, in the order in which they were seen. For example (not
showing ⸨ρ⸩ or ⸨σ⸩ in results):
ℑ⁅
¦ > (* (+ 3 4) 9)
ℑ,
¦ '((63 . ()) (* (+ 3 4) 9) (+ 3 4) 3 4 9)
ℑ⁆
% ℑ⁅
% ¦ > ((λ (x) (λ (y) x)) 4)
% ℑ,
% ¦ '((((λ (y) x) . ((x . 0))) . ((0 . 4)))
% ¦   (((λ (x) (λ (y) x)) 4) () ())
% ¦   ((λ (x) (λ (y) x)) () ())
% ¦   (4 () ())
% ¦   ((λ (y) x) ((x . 0)) ((0 . 4))))
% ℑ⁆
Were we to swap ⸨List⸩ with ⸨Set⸩ in the monad stack, we would obtain a
\emph{reachable} state semantics, another common form of collecting semantics,
that loses the order and repetition of states.

As another collecting semantics variant, we show how to collect the \emph{dead
code} in a program.  Here we use a monad stack that has an additional state
component (with operations named ⸨put-dead⸩ and ⸨get-dead⸩) which stores the
set of dead expressions.  Initially this will contain all subexpressions of the
program.  As the interpreter evaluates expressions it will remove them from the
dead set.

Figure~\ref{f:dead} defines the monad stack for the dead code collecting
semantics and the ⸨ev-dead@⸩ component, another mix-in for an ⸨ev₀⸩ evaluator
to remove the given subexpression before recurring.  Since computing the dead
code requires an outer wrapper that sets the initial set of dead code to be all
of the subexpressions in the program, we define ⸨eval-dead@⸩ which consumes a
\emph{closed evaluator}, i.e. something of the form ⸨(fix ev)⸩. Putting these
pieces together, the dead code collecting semantics is defined:
\begin{alignat*}{1}
  & 𝔥⸨(define (eval e) (mrun ((eval-dead (fix (ev-dead ev))) e)))⸩
\end{alignat*}

Running a program with the dead code interpreter produces an answer and the set
of expressions that were not evaluated during the running of a program:
ℑ⁅
¦ > (if0 0 1 2)
ℑ,
¦ (cons '(1 . ()) (set 2))
ℑ;
¦ > (λ (x) x)
ℑ,
¦ (cons '(((λ (x) x) . ()) . ()) (set 'x))
ℑ;
¦ > (if0 (/ 1 0) 2 3)]
ℑ,
¦ (cons '(failure . ()) (set 3 2))
ℑ⁆

Our setup makes it easy not only to express the concrete interpreter, but also
these useful forms of collecting semantics.

\begin{figure} %{-{
\begin{mdframed}
\rfloat{⸨dead-monad@⸩}
\begin{flalign*}
& 𝔥⸨(define-monad⸩\ 𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢dead⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨ID)))))⸩
& \end{flalign*}
\figskip\rfloat{⸨ev-dead@⸩}
\begin{lstlisting}
¦ (define (((ev-dead ev₀) ev) e)
¦   (do θ ← get-dead       
¦       (put-dead (set-remove θ e))
¦       ((ev₀ ev) e)))
\end{lstlisting}
\figskip\rfloat{⸨eval-dead@⸩}
\begin{lstlisting}
¦ (define ((eval-dead eval) e₀)
¦   (do (put-dead (subexps e₀))
¦       (eval e₀)))
\end{lstlisting}
\captionskip{Dead Code Collecting Semantics}
\label{f:dead}
\end{mdframed}
\end{figure} %}-}

\subsection{Abstracting Base Values}\label{s:base}

Our interpreter must become decidable before it can be considered an analysis,
and the first step towards decidability is to abstract the base types of the
language to something finite. We do this for our number base type by
introducing a new \emph{abstract} number, written ⸨'N⸩, which represents the
set of all numbers. Abstract numbers are introduced by an alternative
interpretation of primitive operations, given in Figure~\ref{f:abs-delta},
which simply produces ⸨'N⸩ in all cases. 

Some care must be taken in the abstraction of ⸨'/⸩. If the denominator is the
abstract number ⸨'N⸩, then it is possible the program could fail as a result of
divide-by-zero, since ⸨0⸩ is contained in the representation of ⸨'N⸩. Therefore
there are \emph{two} possible answers when the denominator is ⸨'N⸩: ⸨'N⸩ and
⸨'failure⸩. Both answers are ⸨return⸩ed by introducing non-determinism
⸨NondetT⸩ into the monad stack. Adding non-determinism provides the ⸨mplus⸩
operation for combining multiple answers. Non-determinism is also used in
⸨zero?⸩, which returns both true and false on ⸨'N⸩.

By linking together ⸨δ^@⸩ and the monad stack with non-determinism, we obtain
an evaluator that produces a set of results:
ℑ⁅
¦ > (* (+ 3 4) 9)
ℑ,
¦ '((N . ()))
ℑ;
¦ > (/ 5 (+ 1 2))
ℑ,
¦ '((failure . ()) (N . ()))
ℑ;
¦ > (if0 (+ 1 0) 3 4)
ℑ,
¦ '((3 . ()) (4 . ()))
ℑ⁆
If we link ⸨δ^@⸩ with the \emph{tracing} monad stack plus non-determinism:
\begin{alignat*}{1}
𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨WriterT List⸩}⸢traces⸣
𝔥⸨(⸩\!\up{𝔥⸨NondetT⸩}⸢mplus⸣\ 𝔥⸨ID)))))⸩
\end{alignat*}
we get an evaluator that produces sets of traces (again not showing ⸨ρ⸩ or ⸨σ⸩
in the results):
ℑ⁅
¦ > (if0 (+ 1 0) 3 4)
ℑ,
¦ (set '((3 . ()) (if0 (+ 1 0) 3 4) (+ 1 0) 0 3)
¦      '((4 . ()) (if0 (+ 1 0) 3 4) (+ 1 0) 0 4))
ℑ⁆

\begin{figure} %{-{
\begin{mdframed}
\rfloat{⸨monad^@⸩}
\begin{flalign*}
& 𝔥⸨(define-monad⸩\ 𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨NondetT⸩}⸢mplus⸣\ 𝔥⸨ID)))))⸩ &
\end{flalign*}
\figskip\rfloat{⸨δ^@⸩}
\begin{lstlisting}
¦ (define (δ o n₀ n₁)
¦   (match* (o n₀ n₁)
¦     [('+ _ _       ) (return 'N)]
¦     [('/ _ (? num?)) (if (= 0 n₁) fail (return 'N))]
¦     [('/ _ 'N      ) (mplus fail (return 'N))] ... ))
¦ (define (zero? v)
¦   (match v
¦     ['N (mplus (return #t) (return #f))]
¦     [_  (return (= 0 v))]))
\end{lstlisting}
\captionskip{Abstracting Primitive Operations}
\label{f:abs-delta}
\end{mdframed}
\end{figure} %}-}

It is clear that the interpreter will only ever see a finite set of numbers
(including ⸨'N⸩), but it's definitely not true that the interpreter halts on
all inputs.  First, it's still possible to generate an infinite number of
closures.  Second, there's no way for the interpreter to detect when it sees a
loop.  To make a terminating abstract interpreter requires tackling both.  We
look next at abstracting closures.

\subsection{Abstracting Closures}
\label{s:abstracting-closures}

Closures consist of code---a lambda term---and an environment---a finite map
from variables to addresses.  Since the set of lambda terms and variables is
bounded by the program text, it suffices to finitize closures by finitizing the
set of addresses.  Following the AAM approach, we do this by modifying the
allocation function to produce elements drawn from a finite set.  In order to
retain soundness in the semantics, we modify the store to map addresses to
\emph{sets} of values, model store update as a join, and model dereference as a
non-deterministic choice.

Any abstraction of the allocation function that produces a finite set will do,
but the choice of abstraction will determine the precision of the resulting
analysis.  A simple choice is to allocate variables using the variable's name
as its address.  This gives a monomorphic, or 0CFA-like, abstraction.

\begin{figure} %{-{
\begin{mdframed}
\rfloat{⸨alloc^@⸩}
\begin{lstlisting}
¦ (define (alloc x) (return x))
\end{lstlisting}
\figskip\rfloat{⸨store-nd@⸩}
\begin{lstlisting}
¦ (define (find a)
¦   (do σ ← get-store
¦       (for/monad+ ([v (σ a)])
¦         (return v))))
¦ (define (ext a v)
¦   (update-store (λ (σ) (σ a (if (∈ a σ) (set-add (σ a) v) (set v))))))
\end{lstlisting}
\captionskip{Abstracting Allocation: 0CFA}
\label{f:0cfa-abs}
\end{mdframed}
\end{figure} %}-}


Figure~\ref{f:0cfa-abs} shows the component ⸨alloc^@⸩ which implements
monomorphic allocation, and the component ⸨store-nd@⸩ for implementing ⸨find⸩
and ⸨ext⸩ which interact with a store mapping to \emph{sets} of values. The
⸨for/monad+⸩ form is a convenience for combining a set of computations with
⸨mplus⸩, and is used so ⸨find⸩ returns \emph{all} of the values in the store at
a given address.  The ⸨ext⸩ function joins whenever an address is already
allocated, otherwise it maps the address to a singleton set.
By linking these components with the same monad stack from before, we obtain an
interpreter that loses precision whenever variables are bound to multiple
values.
% KEEP IF POSSIBLE
% For example, this program binds ⸨x⸩ to both ⸨0⸩ and ⸨1⸩ and produces
%both answers when run:
%ℑ⁅
%¦ > (let f (λ (x) x)
%¦     (let _ (f 0) (f 1)))]
%ℑ,
%¦ '((0 . ((x 1 0) (f ((λ (x) x) . ()))))
%¦   (1 . ((x 1 0) (f ((λ (x) x) . ())))))
%ℑ⁆

Our abstract interpreter now has a truly finite domain; the next step is to
detect loops in the state-space to achieve termination.

