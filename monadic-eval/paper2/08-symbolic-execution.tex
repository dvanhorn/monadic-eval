\section{Symbolic execution}\label{s:symbolic}

\begin{figure} %{-{
\begin{mdframed}
\rfloat{‚∏®symbolic-monad@‚∏©}
\begin{flalign*}
  & ùî•‚∏®(define-monad‚∏©\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®ReaderT‚∏©}‚∏¢env‚∏£\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®FailT‚∏©}‚∏¢errors‚∏£\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®StateT‚∏©}‚∏¢store‚∏£\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®StateT‚∏©}‚∏¢path‚∏£\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®NondetT‚∏©}‚∏¢mplus‚∏£\ ùî•‚∏®ID))))))‚∏© &
\end{flalign*}
\figskip\rfloat{‚∏®ev-symbolic@‚∏©}
\begin{lstlisting}
¬¶ (define (((ev-symbolic ev‚ÇÄ) ev) e)
¬¶   (match e [(sym x) (return x)]
¬¶            [e       ((ev‚ÇÄ ev) e)]))
\end{lstlisting}
\figskip\rfloat{‚∏®Œ¥-symbolic@‚∏©}
\begin{lstlisting}
¬¶ (define (Œ¥ o n‚ÇÄ n‚ÇÅ)
¬¶   (match* (o n‚ÇÄ n‚ÇÅ)
¬¶     [('/ n‚ÇÄ n‚ÇÅ) (do z? ‚Üê (zero? n‚ÇÅ)
¬¶                     (cond [z? fail]
¬¶                           [(and (num? n‚ÇÄ) (num? n‚ÇÅ)) (return (/ n‚ÇÄ n‚ÇÅ))]
¬¶                           [else (return `(/ ,n‚ÇÄ ,n‚ÇÅ))]))] ... ))
¬¶ (define (zero? v)
¬¶   (do œÜ ‚Üê get-path-cond
¬¶       (match v
¬¶         [(? num? n)             (return (= 0 n))]
¬¶         [v #:when (‚àà v œÜ)       (return #t)]
¬¶         [v #:when (‚àà `(¬¨ ,v) œÜ) (return #f)]
¬¶         [v (mplus (do (refine v)       (return #t))
¬¶                   (do (refine `(¬¨ ,v)) (return #f)))])))
\end{lstlisting}
\captionskip{Symbolic Execution Variant}
\label{f:symbolic}
\end{mdframed}
\end{figure} %}-}

\begin{figure} %{-{
\begin{mdframed}
\rfloat{‚∏®Œ¥^-symbolic@‚∏©}
\begin{lstlisting}
¬¶ (define (Œ¥ o n‚ÇÄ n‚ÇÅ)
¬¶   (match* (o n‚ÇÄ n‚ÇÅ)
¬¶     [('/ n‚ÇÄ n‚ÇÅ) (do z? ‚Üê (zero? n‚ÇÅ)
¬¶                     (cond [z? fail]
¬¶                           [(member 'N (list n‚ÇÄ n‚ÇÅ)) (return 'N)]
¬¶                           ... ))]
¬¶     ... ))
¬¶ (define (zero? v)
¬¶   (do œÜ ‚Üê get-path-cond
¬¶       (match v ['N (mplus (return #t) (return #f))] ... )))
\end{lstlisting}
\captionskip{Symbolic Execution with Abstract Numbers}
\label{f:symbolic-widen}
\end{mdframed}
\end{figure} %}-}

In this section, we carry out another---this time more
involved---example that shows how to instantiate our definitional
abstract interpreter to obtain a symbolic execution engine that
performs sound program verification.  This serves to demonstrate the
range of the approach, capturing forms of analysis typically
considered fairly dissimilar.

First we describe the monad stack and metafunctions that implement a
symbolic executor~\cite{dvanhorn:King1976Symbolic}, then show how
abstractions discussed in previous sections can be applied to enforce
termination, turning a traditional symbolic execution into a
path-sensitive verification engine.

%\subsection{Symbolic Execution}
To support symbolic execution, first we extend the syntax of the language to
support symbolic numbers:
\begin{alignat*}{4}
   e ‚àà &&\mathrel{}     exp ‚©¥ &\mathrel{} ‚Ä¶ ‚à£ ùî•‚∏®(sym‚∏©\ xùî•‚∏®)‚∏© &\hspace{1em} [‚¶ë\emph{symbolic number}‚¶í]
\\ Œµ ‚àà &&\mathrel{}    pexp ‚©¥ &\mathrel{} e ‚à£ ¬¨e             &\hspace{1em} [‚¶ë\emph{path expression}‚¶í]
\\ œÜ ‚àà &&\mathrel{}    pcon ‚âî &\mathrel{} ‚Ñò(pexp)   &\hspace{1em} [‚¶ë\emph{path condition}‚¶í]
\end{alignat*}
Figure~\ref{f:symbolic-widen} shows the units needed to turn the existing interpreter
into a symbolic executor. Primitives such as ‚∏®'/‚∏© now also take as input and
return symbolic values. As standard, symbolic execution employs a
path-condition accumulating assumptions made at each branch, allowing the
elimination of infeasible paths and construction of test cases. We represent
the path-condition ‚∏®œÜ‚∏© as a set of symbolic values or their negations.
If ‚∏®e‚∏© is in ‚∏®œÜ‚∏©, ‚∏®e‚∏© is assumed to evaluate to ‚∏®0‚∏©;
if ‚∏®¬¨ e‚∏© is in ‚∏®œÜ‚∏©, ‚∏®e‚∏© is assumed to evaluate to non-‚∏®0‚∏©.
This set is another state component provided by ‚∏®StateT‚∏© in the monad
transformer stack. Monadic operations ‚∏®get-path-cond‚∏© and ‚∏®refine‚∏© reference
and update the path-condition. The metafunction ‚∏®zero?‚∏© works similarly to the
concrete counterpart, but also uses the path-condition to prove that some
symbolic numbers are definitely ‚∏®0‚∏© or non-‚∏®0‚∏©. In case of uncertainty, ‚∏®zero?‚∏©
returns both answers instead of refining the path-condition with the assumption
made.

In the following example, the symbolic executor recognizes that result ‚∏®3‚∏© and
division-by-0 error are not feasible:
‚Ñë‚ÅÖ
¬¶ > (if0 'x (if0 'x 2 3) (/ 5 'x))
‚Ñë,
¬¶ (set (cons '(/ 5 x) (set '(¬¨ x)))
¬¶      (cons 2 (set 'x)))
‚Ñë‚ÅÜ
A scaled up symbolic executor could implement ‚∏®zero?‚∏© by calling out to an SMT
solver for interesting arithmetics, or extend the language with symbolic
functions and blame semantics for sound higher-order symbolic
execution~\cite{dvanhorn:TobinHochstadt2012Higherorder,dvanhorn:Nguyen2015Relatively}.

\newcommand{\lamif}{¬´Œª‚¶ëIF‚¶í¬ª }

%\paragraph{From Symbolic Execution to Verification}

Traditional symbolic executors mainly aim to find bugs and do not
provide a termination guarantee. However, when we apply to this
symbolic executor the finite abstractions presented in previous
sections, namely base value widening and finite allocation
(Section~\ref{s:base}), and caching and fixing
(Section~\ref{s:cache}), we turn the symbolic execution into a sound,
path-sensitive program verification engine.

There is one wrinkle, which is that operations on symbolic values
introduce a new source of unboundness in the state-space, because the
space of symbolic values is not finite. We therefore widen a symbolic
value to the abstract number ‚∏®'N‚∏© when it shares an address with a
different number, similarly to the precision-preserving abstraction
from Section~\ref{s:alt-abstraction}. Figure~\ref{f:symbolic-widen}
shows extension to ‚∏®Œ¥‚∏© and ‚∏®zero?‚∏© in the presence of ‚∏®'N‚∏©. The
different treatments of ‚∏®'N‚∏© and symbolic values clarifies that
abstract values are not symbolic values: the former stands for a set
of multiple values, whereas the latter stands for an single unknown
value. Tests on abstract number ‚∏®'N‚∏© do not strengthen the
path-condition; it is unsound to accumulate any assumption about ‚∏®'N‚∏©.

