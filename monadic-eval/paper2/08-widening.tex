\section{Widening the Store}\label{s:widening}

The abstract interpreter we've constructed so far uses a
store-per-program-state abstraction, which while precise can be
unwieldy in terms of cost.  A common technique to combat this cost is
to use a global ``widenened'' store, which can be thought of as a
single store that is the join of all the individual stores in the
current set-up.  Thanks to our monad transformer framework, expressing
this change boils down to a simple re-ordering of the monad stack.

Whereas before we had:
\begin{lstlisting}
¦ (ReaderT (FailT (StateT (NondetT
¦   (ReaderT (StateT+ ID))))))
\end{lstlisting}
if we change this stack to the following:
\begin{lstlisting}
¦ (ReaderT (FailT (NondetT (StateT+
¦   (ReaderT (StateT+ ID))))))
\end{lstlisting}
we get a store-widened variant of the abstract interpreter.  The idea
here is that we swap the order of the non-determinism transformer and
state transformer that is model the store.  Because stores now need to
be joined together, we have to change ⸨StoreT⸩ to
⸨StoreT+⸩.  And we are done!

To see the difference, here is an example without store-widening:
ℑ⁅
¦ (let x (add1 0)
¦   (let y (if0 x 1 2)
¦     (let z (if0 x 3 4)
¦       (if0 x y z))))
ℑ,
¦ '((4 . ((x N) (y 2) (z 4)))
¦   (1 . ((x N) (y 1) (z 3)))
¦   (2 . ((x N) (y 2) (z 3)))
¦   (3 . ((x N) (y 1) (z 3)))
¦   (1 . ((x N) (y 1) (z 4)))
¦   (3 . ((x N) (y 2) (z 3)))
¦   (2 . ((x N) (y 2) (z 4)))
¦   (4 . ((x N) (y 1) (z 4))))
ℑ⁆
and with:
ℑ⁅
¦ (let x (add1 0)
¦   (let y (if0 x 1 2)
¦     (let z (if0 x 3 4)
¦       (if0 x y z))))
ℑ,
¦ '((1 3 2 4) . ((x N) (y 1 2) (z 3 4)))
ℑ⁆
Notice that before widening, the result is a set of value, store
pairs.  After widening the result is a pair of a set of values and a
store.  Importantly, the cache, which bounds the overall run-time of
the abstract interpreter, is potentially exponential without
store-widening, but collapses to polynomial after store-widening.
