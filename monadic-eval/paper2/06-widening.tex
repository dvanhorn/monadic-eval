\section{Widening the Store}\label{s:widening}

The abstract interpreter we've constructed so far uses a
store-per-program-state abstraction, which is precise but prohibitively
expensive. A common technique to combat this cost is to use a global
``widened'' store~\cite{dvanhorn:might-phd,dvanhorn:Shivers:1991:CFA}, which over-approximates each individual store in the
current set-up. This change is achieved easily in the monadic setup by
re-ordering the monad stack, a technique due to \citet{local:darais-oopsla2015}. Whereas before we had ⸨monad-cache@⸩ we
instead swap the order of ⸨StateT⸩ for the store and ⸨NondetT⸩:
\begin{alignat*}{1}
& 𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨NondetT⸩}⸢mplus⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT+⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢in-\$⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT+⸩}⸢out-\$⸣\ 𝔥⸨ID))))))⸩
\end{alignat*}
we get a store-widened variant of the abstract interpreter. Because ⸨StateT⸩
for the store appears underneath nondeterminism, it will be automatically
widened. We write ⸨StateT+⸩ to signify that the cell of state supports such
widening. 

% To see the difference, here is an example without store-widening:
% ℑ⁅
% ¦ (let x (+ 1 0)
% ¦   (let y (if0 x 1 2)
% ¦     (let z (if0 x 3 4)
% ¦       (if0 x y z))))
% ℑ,
% ¦ '((4 . ((x N) (y 2) (z 4)))
% ¦   (1 . ((x N) (y 1) (z 3)))
% ¦   (2 . ((x N) (y 2) (z 3)))
% ¦   (3 . ((x N) (y 1) (z 3)))
% ¦   (1 . ((x N) (y 1) (z 4)))
% ¦   (3 . ((x N) (y 2) (z 3)))
% ¦   (2 . ((x N) (y 2) (z 4)))
% ¦   (4 . ((x N) (y 1) (z 4))))
% ℑ⁆
% and with:
% ℑ⁅
% ¦ (let x (+ 1 0)
% ¦   (let y (if0 x 1 2)
% ¦     (let z (if0 x 3 4)
% ¦       (if0 x y z))))
% ℑ,
% ¦ '((1 3 2 4) . ((x N) (y 1 2) (z 3 4)))
% ℑ⁆
% Notice that before widening, the result is a set of value, store
% pairs.  After widening the result is a pair of a set of values and a
% store.  Importantly, the cache, which bounds the overall run-time of
% the abstract interpreter, is potentially exponential without
% store-widening, but collapses to polynomial after store-widening.

\begin{figure} %{-{
\begin{mdframed}
\rfloat{⸨precise-δ@⸩}
\begin{lstlisting}
¦ (define (δ o n₀ n₁)
¦   (match* (o n₀ n₁)
¦     [('+ (? num?) (? num?)) (return (+ n₀ n₁))]
¦     [('+ _        _       ) (return 'N)] ... ))
¦ (define (zero? v)
¦   (match v
¦     ['N (mplus (return #t) (return #f))]
¦     [_  (return (zero? v))]))
\end{lstlisting}
\figskip\rfloat{⸨store-crush@⸩}
\begin{lstlisting}
¦ (define (find a)
¦   (do σ ← get-store
¦       (for/monad+ ([v (σ a)]) (return v))))
¦ (define (crush v vs)
¦   (if (closure? v)
¦       (set-add vs v)
¦       (set-add (set-filter closure? vs) 'N)))
¦ (define (ext a v)
¦   (update-store (λ (σ) (if (∈ a σ)
¦                            (σ a (crush v (σ a)))
¦                            (σ a (set v))))))
\end{lstlisting}
\captionskip{An Alternative Abstraction for Precise Primitives}
\label{f:pres-delta}
\end{mdframed}
\end{figure} %}-}
