\section{Widening the Store}\label{s:widening}

The abstract interpreter we've constructed so far uses a
store-per-program-state abstraction, which while precise is also prohibitively
expensive. A common technique to combat this cost is to use a global
``widenened'' store, which over-approximates all the individual stores in the
current set-up.  Thanks to our monad transformer framework, this change can be
achieved simply by re-ordering of the monad stack, a technique due to Darais
\emph{et al}~\cite{local:darais-oopsla2015}. Whereas before we had:
\begin{alignat*}{1}
  & 𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT⸩}⸢store⸣\ 𝔥⸨(⸩\!\up{𝔥⸨NondetT⸩}⸢mplus⸣
\\[\monadgobble]& ␣␣𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢in-\$⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT+⸩}⸢out-\$⸣\ 𝔥⸨ID))))))⸩
\end{alignat*}
we instead swap the order of ⸨StateT⸩ for the store and ⸨NondetT⸩:
\begin{alignat*}{1}
  & 𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢env⸣\ 𝔥⸨(⸩\!\up{𝔥⸨FailT⸩}⸢errors⸣\ 𝔥⸨(⸩\!\up{𝔥⸨NondetT⸩}⸢mplus⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT+⸩}⸢store⸣
\\[\monadgobble]& ␣␣𝔥⸨(⸩\!\up{𝔥⸨ReaderT⸩}⸢in-\$⸣\ 𝔥⸨(⸩\!\up{𝔥⸨StateT+⸩}⸢out-\$⸣\ 𝔥⸨ID))))))⸩
\end{alignat*}
we get a store-widened variant of the abstract interpreter. Because ⸨StateT⸩
for the store appears underneath nondeterminism, it will be automatically
widened. We write ⸨StateT+⸩ to signify that the cell of state supports such
widening. 

% To see the difference, here is an example without store-widening:
% ℑ⁅
% ¦ (let x (+ 1 0)
% ¦   (let y (if0 x 1 2)
% ¦     (let z (if0 x 3 4)
% ¦       (if0 x y z))))
% ℑ,
% ¦ '((4 . ((x N) (y 2) (z 4)))
% ¦   (1 . ((x N) (y 1) (z 3)))
% ¦   (2 . ((x N) (y 2) (z 3)))
% ¦   (3 . ((x N) (y 1) (z 3)))
% ¦   (1 . ((x N) (y 1) (z 4)))
% ¦   (3 . ((x N) (y 2) (z 3)))
% ¦   (2 . ((x N) (y 2) (z 4)))
% ¦   (4 . ((x N) (y 1) (z 4))))
% ℑ⁆
% and with:
% ℑ⁅
% ¦ (let x (+ 1 0)
% ¦   (let y (if0 x 1 2)
% ¦     (let z (if0 x 3 4)
% ¦       (if0 x y z))))
% ℑ,
% ¦ '((1 3 2 4) . ((x N) (y 1 2) (z 3 4)))
% ℑ⁆
% Notice that before widening, the result is a set of value, store
% pairs.  After widening the result is a pair of a set of values and a
% store.  Importantly, the cache, which bounds the overall run-time of
% the abstract interpreter, is potentially exponential without
% store-widening, but collapses to polynomial after store-widening.
