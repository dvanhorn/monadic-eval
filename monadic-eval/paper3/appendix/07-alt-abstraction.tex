\section{An Alternative Abstraction}\label{s:alt-abstraction}

In this section, we demonstrate how easy it is to experiment with
alternative abstraction strategies by swapping out components.  In
particular we look at an alternative abstraction of primitive
operations and store joins that results in an abstraction that---to
the best of our knowledge---has not been explored in the literature.
This example shows the potential for rapidly prototyping novel
abstractions using our approach.

Figure~\ref{f:pres-delta} defines two new components: ⸨precise-δ@⸩ and
⸨store-crush@⸩.  The first is an alternative interpretation for primitive
operations that is \emph{precision preserving}.  Unlike ⸨δ^@⸩, it does not
introduce abstraction, it merely propagates it.  When two concrete
numbers are added together, the result will be a concrete number, but if either
number is abstract then the result is abstract.

This interpretation of primitive operations clearly doesn't impose a finite
abstraction on its own, because the state space for concrete numbers is
infinite. If ⸨precise-δ@⸩ is linked with the ⸨store-nd@⸩ implementation of the
store, termination is therefore not guaranteed.  

The ⸨store-crush@⸩ operations are designed to work with ⸨precise-δ@⸩ by
performing \emph{widening} when joining multiple concrete values into the
store. This abstraction offers a high-level of precision; for example:
ℑ⁅
¦ > (* (+ 3 4) 9)        ;; Constant arithmetic expressions are computed with full precision.
ℑ,
¦ '(63)
ℑ;
¦ > ((λ (x) (* x x)) 5)  ;; Even linear binding and arithmetic preserves precision.
ℑ,
¦ '(25)
ℑ;
¦ > (let f (λ (x) x)     ;; Only when the approximation of binding structure comes in to
¦     (* (f 5) (f 5)))   ;; contact with base values that we see a loss in precision.
ℑ,
'(N)
ℑ⁆
This combination of ⸨precise-δ@⸩ and ⸨store-crush@⸩ allows termination for most
programs, but still not all. In the following example, ⸨id⸩ is eventually
applied to a widened argument ⸨'N⸩, which makes both conditional branches
reachable. The function returns ⸨0⸩ in the base case, which is propagated to
the recursive call and added to ⸨1⸩, which yields the concrete answer ⸨1⸩.
This results in a cycle where the intermediate sum returns ⸨2⸩, ⸨3⸩, ⸨4⸩ when
applied to ⸨1⸩, ⸨2⸩, ⸨3⸩, etc.
ℑ⁅
¦ > (rec id (λ (n) (if0 n 0 (+ 1 (id (- n 1)))))
¦     (id 3))
ℑ,
¦ timeout
ℑ⁆
To ensure termination for all programs, we assume all references to
primitive operations are $η$-expanded, so that store-allocations also
take place at primitive applications, ensuring widening at repeated
bindings. In fact, all programs terminate when using ⸨precise-δ@⸩,
⸨store-crush@⸩ and «η»-expanded primitives, which means we have a
achieved a computable and uniquely precise abstract interpreter.

Here we see one of the strengths of the extensible, definitional approach to
abstract interpreters. The combination of added precision and widening is
encoded quite naturally. In contrast, it's hard to imagine how such a
combination could be formulated as, say, a constraint-based flow analysis.
