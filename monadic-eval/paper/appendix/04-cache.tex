\section{Caching and Finding Fixed-points}\label{s:cache}

At this point, the interpreter obtained by linking together ‚∏®monad^@‚∏©, ‚∏®Œ¥^@‚∏©,
‚∏®alloc^@‚∏© and ‚∏®store-nd@‚∏© components will only ever visit a finite number of
configurations for a given program. A configuration (‚∏®œÇ‚∏©) consists of an
expression (‚∏®e‚∏©), environment (‚∏®œÅ‚∏©) and store (‚∏®œÉ‚∏©). This configuration is
finite because: expressions are finite in the given program; environments are
maps from variables (again, finite in the program) to addresses; the addresses
are finite thanks to ‚∏®alloc^‚∏©; the store maps addresses to sets of values; base
values are abstracted to a finite set by ‚∏®Œ¥^‚∏©; and closures consist of an
expression and environment, which are both finite.

Although the interpreter will only ever see a finite set of inputs, it
\emph{doesn't know it}.  A simple loop will cause the interpreter to diverge:
‚Ñë‚ÅÖ
¬¶ > (rec f (Œª (x) (f x)) (f 0))
‚Ñë,
¬¶ timeout
‚Ñë‚ÅÜ
To solve this problem, we introduce a \emph{cache} (‚∏®¬¢‚∏¢in‚∏£‚∏©) as input to the
algorithm, which maps from configurations (‚∏®œÇ‚∏©) to sets of value-and-store
pairs (‚∏®v√óœÉ‚∏©). When a configuration is reached for the second time, rather than
re-evaluating the expression and entering an infinite loop, the result is
looked up from ‚∏®¬¢‚∏¢in‚∏£‚∏©, which acts as an oracle. It is important that the cache
is used co-inductively: it is only safe to use ‚∏®¬¢‚∏¢in‚∏£‚∏© as an oracle so long as
some progress has been made first. 

The results of evaluation are then stored in an output cache (‚∏®¬¢‚∏¢out‚∏£‚∏©), which
after the end of evaluation is ‚Äúmore defined‚Äù than the input cache (‚∏®¬¢‚∏¢in‚∏£‚∏©),
again following a co-inductive argument. The least fixed-point ‚∏®¬¢‚Å∫‚∏© of an
evaluator which transforms an oracle ‚∏®¬¢‚∏¢in‚∏£‚∏© and outputs a more defined oracle
‚∏®¬¢‚∏¢out‚∏£‚∏© is then a sound approximation of the program, because it
over-approximates all finite unrollings of the unfixed evaluator. 

The co-inductive caching algorithm is shown in Figure~\ref{f:caching}, along
with the monad transformer stack ‚∏®monad-cache@‚∏© which has two new components:
‚∏®ReaderT‚∏© for the input cache ‚∏®¬¢‚∏¢in‚∏£‚∏©, and ‚∏®StateT+‚∏© for the output cache
‚∏®¬¢‚∏¢out‚∏£‚∏©. We use a ‚∏®StateT+‚∏© instead of ‚∏®WriterT‚∏© monad transformer in the
output cache so it can double as tracking the set of seen states. The ‚∏®+‚∏© in
‚∏®StateT+‚∏© signifies that caches for multiple non-deterministic branches will be
merged automatically, producing a set of results and a single cache, rather
than a set of results paired with individual caches.

\begin{figure} %{-{
\begin{mdframed}
\rfloat{‚∏®monad-cache@‚∏©}
\begin{flalign*}
& ùî•‚∏®(define-monad (‚∏©\!\up{ùî•‚∏®ReaderT‚∏©}‚∏¢env‚∏£\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®FailT‚∏©}‚∏¢errors‚∏£\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®StateT‚∏©}‚∏¢store‚∏£\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®NondetT‚∏©}‚∏¢mplus‚∏£\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®ReaderT‚∏©}‚∏¢in-\$‚∏£\ ùî•‚∏®(‚∏©\!\up{ùî•‚∏®StateT+‚∏©}‚∏¢out-\$‚∏£\ ùî•‚∏®ID)))))))‚∏© &
\end{flalign*}
\figskip\rfloat{‚∏®ev-cache@‚∏©}
\begin{lstlisting}
¬¶ (define (((ev-cache ev‚ÇÄ) ev) e)
¬¶   (do œÅ   ‚Üê ask-env  œÉ ‚Üê get-store
¬¶       œÇ   ‚âî (list e œÅ œÉ)
¬¶       ¬¢‚∏¢out‚∏£ ‚Üê get-cache-out
¬¶       (if (‚àà œÇ ¬¢‚∏¢out‚∏£)
¬¶           (for/monad+ ([v√óœÉ (¬¢‚∏¢out‚∏£ œÇ)])
¬¶             (do (put-store (cdr v√óœÉ))
¬¶                 (return (car v√óœÉ))))
¬¶           (do ¬¢‚∏¢in‚∏£    ‚Üê ask-cache-in
¬¶               v√óœÉ‚ÇÄ  ‚âî (if (‚àà œÇ ¬¢‚∏¢in‚∏£) (¬¢‚∏¢in‚∏£ œÇ) ‚àÖ)
¬¶               (put-cache-out (¬¢‚∏¢out‚∏£ œÇ v√óœÉ‚ÇÄ))
¬¶               v     ‚Üê ((ev‚ÇÄ ev) e)
¬¶               œÉ‚Ä≤    ‚Üê get-store
¬¶               v√óœÉ‚Ä≤  ‚âî (cons v œÉ‚Ä≤)
¬¶               (update-cache-out (Œª (¬¢‚∏¢out‚∏£) (¬¢‚∏¢out‚∏£ œÇ (set-add (¬¢‚∏¢out‚∏£ œÇ) v√óœÉ‚Ä≤))))
¬¶               (return v)))))
\end{lstlisting}
\captionskip{Co-inductive Caching Algorithm}
\label{f:caching}
\end{mdframed}
\end{figure} %}-}

In the algorithm, when a configuration ‚∏®œÇ‚∏© is first encountered, we place an
entry in the output cache mapping ‚∏®œÇ‚∏© to ¬´ùî•‚∏®(¬¢‚∏¢in‚∏£‚∏©\ ùî•‚∏®œÇ)‚∏©¬ª, which is the
‚Äúoracle‚Äù result. Also, whenever we finish computing the result ‚∏®v√óœÉ'‚∏© of
evaluating a configuration ‚∏®œÇ‚∏©, we place an entry in the output cache mapping
‚∏®œÇ‚∏© to ‚∏®v√óœÉ‚Ä≤‚∏©. Finally, whenever we reach a configuration ‚∏®œÇ‚∏© for which a
mapping in the output cache exists, we use it immediately, ‚∏®return‚∏©ing each
result using the ‚∏®for/monad+‚∏© iterator. Therefore, every ‚Äúcache hit‚Äù on
‚∏®¬¢‚∏¢out‚∏£‚∏© is in one of two possible states: 1) we have already seen the
configuration, and the result is the oracle result, as desired; or 2) we have
already computed the ‚Äúimproved‚Äù result (w.r.t. the oracle), and need not
recompute it.

To compute the least fixed-point ‚∏®¬¢‚Å∫‚∏© for the evaluator ‚∏®ev-cache‚∏© we perform a
standard Kleene fixed-point iteration starting from the empty map, the bottom
element for the cache, as shown in Figure~\ref{f:fixing}.

\begin{figure} %{-{
\begin{mdframed}
\rfloat{‚∏®fix-cache@‚∏©}
\begin{lstlisting}
¬¶ (define ((fix-cache eval) e)  
¬¶   (do œÅ ‚Üê ask-env  œÉ ‚Üê get-store
¬¶       œÇ ‚âî (list e œÅ œÉ)
¬¶       ¬¢‚Å∫ ‚Üê (mlfp (Œª (¬¢) (do (put-cache-out ‚àÖ)
¬¶                             (put-store œÉ)
¬¶                             (local-cache-in ¬¢ (eval e))
¬¶                             get-cache-out)))
¬¶       (for/monad+ ([v√óœÉ (¬¢‚Å∫ œÇ)])
¬¶         (do (put-store (cdr v√óœÉ))
¬¶             (return (car v√óœÉ))))))
¬¶ (define (mlfp f)
¬¶   (let loop ([x ‚àÖ])
¬¶     (do x‚Ä≤ ‚Üê (f x)
¬¶         (if (equal? x‚Ä≤ x) (return x) (loop x‚Ä≤)))))
\end{lstlisting}
\captionskip{Finding Fixed-Points in the Cache}
\label{f:fixing}
\end{mdframed}
\end{figure} %}-}

The algorithm runs the caching evaluator ‚∏®eval‚∏© on the given program ‚∏®e‚∏© from
the initial environment and store. This is done inside of ‚∏®mlfp‚∏©, a monadic
least fixed-point finder. After finding the least fixed-point, the final values
and store for the initial configuration ‚∏®œÇ‚∏© are extracted and returned.

Termination of the least fixed-point is justified by the monotonicity of the
evaluator (it always returns an ‚Äúimproved‚Äù oracle), and the finite domain of
the cache, which maps abstract configurations to pairs of values and stores,
all of which are finite.


With these pieces in place we construct a complete interpreter:
\begin{alignat*}{1}
& ùî•‚∏®(define (eval e) (mrun ((fix-cache (fix (ev-cache ev))) e)))‚∏©
\end{alignat*}
When linked with ‚∏®Œ¥^‚∏© and ‚∏®alloc^‚∏©, this abstract interpreter is sound and
computable, as demonstrated on the following examples:
‚Ñë‚ÅÖ
¬¶ > (rec f (Œª (x) (f x))
¬¶     (f 0))
‚Ñë,
¬¶ '()
‚Ñë;
¬¶ > (rec f (Œª (n) (if0 n 1 (* n (f (- n 1)))))
¬¶     (f 5))
‚Ñë,
¬¶ '(N)
‚Ñë;
¬¶ > (rec f (Œª (x) (if0 x 0 (if0 (f (- x 1)) 2 3)))
¬¶      (f (+ 1 0)))
‚Ñë,
¬¶ '(0 2 3)
‚Ñë‚ÅÜ

\subsection*{Formal soundness and termination}\label{s:cache:formalism}

In this pearl, we have focused on the code and its intuitions rather
than rigorously establishing the usual formal properties of our
abstract interpreter, but this is just a matter of presentation: the
interpreter is indeed proven sound and computable.  We have formalized
this co-inductive caching algorithm in Appendix~\ref{s:formalism},
where we prove both that it always terminates, and that it computes a
sound over-approximation of concrete evaluation. Here, we give a short
summary of our metatheory approach.

In formalising the soundness of this caching algorithm, we extend a standard
big-step evaluation semantics into a \emph{big-step reachability} semantics,
which characterizes all intermediate configurations which are seen between the
evaluation of a single expression and its eventual result. These two
notions‚Äî\emph{evaluation} which relates expressions to fully evaluated results,
and \emph{reachability} which characterizes intermediate configuration
states‚Äîremain distinct throughout the formalism.

After specifying evaluation and reachability for concrete evaluation, we
develop a \emph{collecting} semantics which gives a precise specification for
any abstract interpreter, and an \emph{abstract} semantics which partially
specifies a sound, over-approximating algorithm w.r.t. the collecting
semantics.

The final step is to compute an oracle for the \emph{abstract evaluation
relation}, which maps individual configurations to abstractions of the values
they evaluate to. To construct this cache, we \emph{mutually} compute the
least-fixed point of both the evaluation and reachability relations: based on
what is evaluated, discover new things which are reachable, and based on what
is reachable, discover new results of evaluation. The caching algorithm
developed in this section is a slightly more efficient strategy for solving the
mutual fixed-point, by taking a deep exploration of the reachability relation
(up-to seeing the same configuration twice) rather than applying just a single
rule of inference.
